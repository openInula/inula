{"version":3,"sources":["../../../../node_modules/.pnpm/@babel+helper-plugin-utils@7.24.0/node_modules/@babel/helper-plugin-utils/src/index.ts","../../../../node_modules/.pnpm/@babel+plugin-syntax-decorators@7.24.1_@babel+core@7.23.9/node_modules/@babel/plugin-syntax-decorators/src/index.ts","../src/index.ts","../../babel-preset-inula-next/src/index.ts","../../babel-preset-inula-next/src/pluginProvider.ts","../../babel-preset-inula-next/src/const.ts","../../babel-preset-inula-next/src/plugin.ts","../../error-handler/src/index.ts","../../view-parser/src/error.ts","../../view-parser/src/parser.ts","../../view-parser/src/index.ts","../../jsx-parser/src/parser.ts","../../jsx-parser/src/index.ts","../../reactivity-parser/src/error.ts","../../reactivity-parser/src/parser.ts","../../reactivity-parser/src/index.ts","../../view-generator/src/HelperGenerators/BaseGenerator.ts","../../view-generator/src/HelperGenerators/LifecycleGenerator.ts","../../view-generator/src/HelperGenerators/PropViewGenerator.ts","../../view-generator/src/HelperGenerators/ElementGenerator.ts","../../view-generator/src/HelperGenerators/ForwardPropGenerator.ts","../../view-generator/src/NodeGenerators/CompGenerator.ts","../../view-generator/src/error.ts","../../view-generator/src/HelperGenerators/HTMLPropGenerator.ts","../../view-generator/src/NodeGenerators/HTMLGenerator.ts","../../view-generator/src/NodeGenerators/TemplateGenerator.ts","../../view-generator/src/NodeGenerators/ForGenerator.ts","../../view-generator/src/HelperGenerators/CondGenerator.ts","../../view-generator/src/NodeGenerators/IfGenerator.ts","../../view-generator/src/NodeGenerators/EnvGenerator.ts","../../view-generator/src/NodeGenerators/TextGenerator.ts","../../view-generator/src/NodeGenerators/ExpGenerator.ts","../../view-generator/src/NodeGenerators/SnippetGenerator.ts","../../view-generator/src/NodeGenerators/SwitchGenerator.ts","../../view-generator/src/NodeGenerators/TryGenerator.ts","../../view-generator/src/ViewGenerator.ts","../../view-generator/src/MainViewGenerator.ts","../../view-generator/src/SnippetGenerator.ts","../../view-generator/src/index.ts","../../class-transformer/src/pluginProvider.ts","../../class-transformer/src/plugin.ts","../../class-transformer/src/index.ts"],"sourcesContent":["import type {\n  PluginAPI,\n  PluginObject,\n  PluginPass,\n  PresetAPI,\n  PresetObject,\n} from \"@babel/core\";\n\ntype APIPolyfillFactory<T extends keyof PluginAPI> = (\n  api: PluginAPI,\n) => PluginAPI[T];\n\ntype APIPolyfills = {\n  assertVersion: APIPolyfillFactory<\"assertVersion\">;\n};\n\nconst apiPolyfills: APIPolyfills = {\n  // Not supported by Babel 7 and early versions of Babel 7 beta.\n  // It's important that this is polyfilled for older Babel versions\n  // since it's needed to report the version mismatch.\n  assertVersion: (api: PluginAPI) => (range: number | string) => {\n    throwVersionError(range, api.version);\n  },\n};\nif (!process.env.BABEL_8_BREAKING) {\n  Object.assign(apiPolyfills, {\n    // This is supported starting from Babel 7.13\n    targets: () => () => {\n      return {};\n    },\n    // This is supported starting from Babel 7.13\n    assumption: () => () => {\n      return undefined;\n    },\n  });\n}\n\nexport function declare<State = {}, Option = {}>(\n  builder: (\n    api: PluginAPI,\n    options: Option,\n    dirname: string,\n  ) => PluginObject<State & PluginPass>,\n): (\n  api: PluginAPI,\n  options: Option,\n  dirname: string,\n) => PluginObject<State & PluginPass> {\n  return (api, options: Option, dirname: string) => {\n    let clonedApi: PluginAPI;\n\n    for (const name of Object.keys(\n      apiPolyfills,\n    ) as (keyof typeof apiPolyfills)[]) {\n      if (api[name]) continue;\n\n      clonedApi ??= copyApiObject(api);\n      clonedApi[name] = apiPolyfills[name](clonedApi);\n    }\n\n    // @ts-expect-error options || {} may not be assigned to Options\n    return builder(clonedApi ?? api, options || {}, dirname);\n  };\n}\n\nexport const declarePreset = declare as <Option = {}>(\n  builder: (api: PresetAPI, options: Option, dirname: string) => PresetObject,\n) => (api: PresetAPI, options: Option, dirname: string) => PresetObject;\n\nfunction copyApiObject(api: PluginAPI): PluginAPI {\n  // Babel >= 7 <= beta.41 passed the API as a new object that had\n  // babel/core as the prototype. While slightly faster, it also\n  // means that the Object.assign copy below fails. Rather than\n  // keep complexity, the Babel 6 behavior has been reverted and this\n  // normalizes all that for Babel 7.\n  let proto = null;\n  if (typeof api.version === \"string\" && /^7\\./.test(api.version)) {\n    proto = Object.getPrototypeOf(api);\n    if (\n      proto &&\n      (!Object.hasOwn(proto, \"version\") ||\n        !Object.hasOwn(proto, \"transform\") ||\n        !Object.hasOwn(proto, \"template\") ||\n        !Object.hasOwn(proto, \"types\"))\n    ) {\n      proto = null;\n    }\n  }\n\n  return {\n    ...proto,\n    ...api,\n  };\n}\n\nfunction throwVersionError(range: string | number, version: string) {\n  if (typeof range === \"number\") {\n    if (!Number.isInteger(range)) {\n      throw new Error(\"Expected string or integer value.\");\n    }\n    range = `^${range}.0.0-0`;\n  }\n  if (typeof range !== \"string\") {\n    throw new Error(\"Expected string or integer value.\");\n  }\n\n  const limit = Error.stackTraceLimit;\n\n  if (typeof limit === \"number\" && limit < 25) {\n    // Bump up the limit if needed so that users are more likely\n    // to be able to see what is calling Babel.\n    Error.stackTraceLimit = 25;\n  }\n\n  let err;\n  if (version.slice(0, 2) === \"7.\") {\n    err = new Error(\n      `Requires Babel \"^7.0.0-beta.41\", but was loaded with \"${version}\". ` +\n        `You'll need to update your @babel/core version.`,\n    );\n  } else {\n    err = new Error(\n      `Requires Babel \"${range}\", but was loaded with \"${version}\". ` +\n        `If you are sure you have a compatible version of @babel/core, ` +\n        `it is likely that something in your build process is loading the ` +\n        `wrong version. Inspect the stack trace of this error to look for ` +\n        `the first entry that doesn't mention \"@babel/core\" or \"babel-core\" ` +\n        `to see what is calling Babel.`,\n    );\n  }\n\n  if (typeof limit === \"number\") {\n    Error.stackTraceLimit = limit;\n  }\n\n  throw Object.assign(err, {\n    code: \"BABEL_VERSION_UNSUPPORTED\",\n    version,\n    range,\n  } as any);\n}\n","import { declare } from \"@babel/helper-plugin-utils\";\n\nexport interface Options {\n  // TODO(Babel 8): Remove\n  legacy?: boolean;\n  // TODO(Babel 8): Remove \"2018-09\", \"2021-12\", '2022-03', '2023-01' and '2023-05'\n  version?:\n    | \"legacy\"\n    | \"2018-09\"\n    | \"2021-12\"\n    | \"2022-03\"\n    | \"2023-01\"\n    | \"2023-05\"\n    | \"2023-11\";\n  // TODO(Babel 8): Remove\n  decoratorsBeforeExport?: boolean;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  let { version } = options;\n\n  if (process.env.BABEL_8_BREAKING) {\n    if (version === undefined) {\n      throw new Error(\n        \"The decorators plugin requires a 'version' option, whose value must be one of: \" +\n          \"'2023-11', '2023-05', '2023-01', '2022-03', '2021-12', '2018-09', or 'legacy'.\",\n      );\n    }\n    if (\n      version !== \"2023-11\" &&\n      version !== \"2023-05\" &&\n      version !== \"2023-01\" &&\n      version !== \"2022-03\" &&\n      version !== \"2021-12\" &&\n      version !== \"legacy\"\n    ) {\n      throw new Error(\"Unsupported decorators version: \" + version);\n    }\n    if (options.legacy !== undefined) {\n      throw new Error(\n        `The .legacy option has been removed in Babel 8. Use .version: \"legacy\" instead.`,\n      );\n    }\n    if (options.decoratorsBeforeExport !== undefined) {\n      throw new Error(\n        `The .decoratorsBeforeExport option has been removed in Babel 8.`,\n      );\n    }\n  } else {\n    const { legacy } = options;\n\n    if (legacy !== undefined) {\n      if (typeof legacy !== \"boolean\") {\n        throw new Error(\".legacy must be a boolean.\");\n      }\n      if (version !== undefined) {\n        throw new Error(\n          \"You can either use the .legacy or the .version option, not both.\",\n        );\n      }\n    }\n\n    if (version === undefined) {\n      version = legacy ? \"legacy\" : \"2018-09\";\n    } else if (\n      version !== \"2023-11\" &&\n      version !== \"2023-05\" &&\n      version !== \"2023-01\" &&\n      version !== \"2022-03\" &&\n      version !== \"2021-12\" &&\n      version !== \"2018-09\" &&\n      version !== \"legacy\"\n    ) {\n      // Fallback to print the invalid version option regardless of the type\n      // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n      throw new Error(\"Unsupported decorators version: \" + version);\n    }\n\n    // eslint-disable-next-line no-var\n    var { decoratorsBeforeExport } = options;\n    if (decoratorsBeforeExport === undefined) {\n      if (version === \"2021-12\" || version === \"2022-03\") {\n        decoratorsBeforeExport = false;\n      } else if (version === \"2018-09\") {\n        throw new Error(\n          \"The decorators plugin, when .version is '2018-09' or not specified,\" +\n            \" requires a 'decoratorsBeforeExport' option, whose value must be a boolean.\",\n        );\n      }\n    } else {\n      if (\n        version === \"legacy\" ||\n        version === \"2022-03\" ||\n        version === \"2023-01\"\n      ) {\n        throw new Error(\n          `'decoratorsBeforeExport' can't be used with ${version} decorators.`,\n        );\n      }\n      if (typeof decoratorsBeforeExport !== \"boolean\") {\n        throw new Error(\"'decoratorsBeforeExport' must be a boolean.\");\n      }\n    }\n  }\n\n  return {\n    name: \"syntax-decorators\",\n\n    manipulateOptions({ generatorOpts }, parserOpts) {\n      if (version === \"legacy\") {\n        parserOpts.plugins.push(\"decorators-legacy\");\n      } else if (process.env.BABEL_8_BREAKING) {\n        parserOpts.plugins.push(\n          [\"decorators\", { allowCallParenthesized: false }],\n          \"decoratorAutoAccessors\",\n        );\n      } else {\n        if (\n          version === \"2023-01\" ||\n          version === \"2023-05\" ||\n          version === \"2023-11\"\n        ) {\n          parserOpts.plugins.push(\n            [\"decorators\", { allowCallParenthesized: false }],\n            \"decoratorAutoAccessors\",\n          );\n        } else if (version === \"2022-03\") {\n          parserOpts.plugins.push(\n            [\n              \"decorators\",\n              { decoratorsBeforeExport: false, allowCallParenthesized: false },\n            ],\n            \"decoratorAutoAccessors\",\n          );\n        } else if (version === \"2021-12\") {\n          parserOpts.plugins.push(\n            [\"decorators\", { decoratorsBeforeExport }],\n            \"decoratorAutoAccessors\",\n          );\n          generatorOpts.decoratorsBeforeExport = decoratorsBeforeExport;\n        } else if (version === \"2018-09\") {\n          parserOpts.plugins.push([\"decorators\", { decoratorsBeforeExport }]);\n          generatorOpts.decoratorsBeforeExport = decoratorsBeforeExport;\n        }\n      }\n    },\n  };\n});\n","import { transform } from '@babel/core';\r\nimport dlight, { type DLightOption } from '../../babel-preset-inula-next';\r\nimport { minimatch } from 'minimatch';\r\nimport { Plugin, TransformResult } from 'vite';\r\nexport default function (options: DLightOption = {}): Plugin {\r\n  const {\r\n    files: preFiles = '**/*.{js,jsx,ts,tsx}',\r\n    excludeFiles: preExcludeFiles = '**/{dist,node_modules,lib}/*.{js,ts}',\r\n  } = options;\r\n  const files = Array.isArray(preFiles) ? preFiles : [preFiles];\r\n  const excludeFiles = Array.isArray(preExcludeFiles) ? preExcludeFiles : [preExcludeFiles];\r\n\r\n  return {\r\n    name: 'dlight',\r\n    enforce: 'pre',\r\n    transform(code: string, id: string) {\r\n      let enter = false;\r\n      for (const allowedPath of files) {\r\n        if (minimatch(id, allowedPath)) {\r\n          enter = true;\r\n          break;\r\n        }\r\n      }\r\n      for (const notAllowedPath of excludeFiles) {\r\n        if (minimatch(id, notAllowedPath)) {\r\n          enter = false;\r\n          break;\r\n        }\r\n      }\r\n      if (!enter) return;\r\n      return transform(code, {\r\n        babelrc: false,\r\n        configFile: false,\r\n        presets: [[dlight, options]],\r\n        sourceMaps: true,\r\n        filename: id,\r\n      }) as TransformResult;\r\n    },\r\n  };\r\n}\r\n","import syntaxDecorators from '@babel/plugin-syntax-decorators';\r\nimport dlight from './plugin';\r\nimport { type DLightOption } from './types';\r\nimport { type ConfigAPI, type TransformOptions } from '@babel/core';\r\nimport { plugin as fn2Class } from '@inula/class-transformer';\r\n\r\nexport default function (_: ConfigAPI, options: DLightOption): TransformOptions {\r\n  return {\r\n    plugins: [\r\n      ['@babel/plugin-syntax-jsx'],\r\n      ['@babel/plugin-syntax-typescript', { isTSX: true }],\r\n      [syntaxDecorators.default ?? syntaxDecorators, { legacy: true }],\r\n      fn2Class,\r\n      [dlight, options],\r\n    ],\r\n  };\r\n}\r\n\r\nexport { type DLightOption };\r\n","import type babel from '@babel/core';\r\nimport { type types as t, type NodePath } from '@babel/core';\r\nimport { type PropertyContainer, type HTMLTags, type SnippetPropSubDepMap } from './types';\r\nimport { minimatch } from 'minimatch';\r\nimport { parseView, ViewUnit } from '@inula/view-parser';\r\nimport { parseView as parseJSX } from 'jsx-view-parser';\r\nimport { parseReactivity } from '@inula/reactivity-parser';\r\nimport { generateSnippet, generateView } from '@inula/view-generator';\r\nimport {\r\n  alterAttributeMap,\r\n  availableDecoNames,\r\n  defaultHTMLTags,\r\n  devMode,\r\n  dlightDefaultPackageName,\r\n  importMap,\r\n  importsToDelete,\r\n  reactivityFuncNames,\r\n} from './const';\r\n\r\nexport class PluginProvider {\r\n  private readonly dlightPackageName = dlightDefaultPackageName;\r\n\r\n  // ---- Plugin Level\r\n  private readonly babelApi: typeof babel;\r\n  private readonly t: typeof t;\r\n  private readonly traverse: typeof babel.traverse;\r\n  private readonly enableDevTools: boolean;\r\n  private readonly includes: string[];\r\n  private readonly excludes: string[];\r\n  private readonly htmlTags: string[];\r\n  private readonly attributeMap: Record<string, string[]>;\r\n  // when parsing JSX, use JSX parser instead of the default parser\r\n  private isJsx = false;\r\n\r\n  constructor(\r\n    babelApi: typeof babel,\r\n    types: typeof t,\r\n    includes: string[],\r\n    excludes: string[],\r\n    enableDevTools: boolean,\r\n    htmlTags: HTMLTags,\r\n    attributeMap: Record<string, string[]>\r\n  ) {\r\n    this.babelApi = babelApi;\r\n    this.t = types;\r\n    this.traverse = babelApi.traverse;\r\n    this.includes = includes;\r\n    this.excludes = excludes;\r\n    this.enableDevTools = devMode && enableDevTools;\r\n    this.htmlTags =\r\n      typeof htmlTags === 'function'\r\n        ? htmlTags(defaultHTMLTags)\r\n        : htmlTags.includes('*')\r\n          ? [...new Set([...defaultHTMLTags, ...htmlTags])].filter(tag => tag !== '*')\r\n          : htmlTags;\r\n    this.attributeMap = attributeMap;\r\n  }\r\n\r\n  // ---- DLight class Level\r\n  private classDeclarationNode?: t.ClassDeclaration;\r\n  private classBodyNode?: t.ClassBody;\r\n  private propertiesContainer: PropertyContainer = {};\r\n  private dependencyMap: Record<string, string[]> = {};\r\n  private enter = true;\r\n  private dLightModel = false;\r\n  private enterClassNode = false;\r\n  private className?: string;\r\n\r\n  // ---- File Level\r\n  private programNode?: t.Program;\r\n  private allImports: t.ImportDeclaration[] = [];\r\n  private didAlterImports = false;\r\n\r\n  /* ---- DLight Class Level Hooks ---- */\r\n  /**\r\n   * @brief Clear all DLight Node Level variables after a class is transformed\r\n   */\r\n  clearNode() {\r\n    this.classDeclarationNode = undefined;\r\n    this.classBodyNode = undefined;\r\n    this.propertiesContainer = {};\r\n    this.dependencyMap = {};\r\n    this.enter = true;\r\n    this.enterClassNode = false;\r\n    this.dLightModel = false;\r\n    this.className = undefined;\r\n  }\r\n\r\n  private get availableProperties(): string[] {\r\n    return Object.entries(this.propertiesContainer)\r\n      .filter(\r\n        ([key, { isWatcher, isStatic, isChildren }]) => key !== '_$compName' && !isWatcher && !isStatic && !isChildren\r\n      )\r\n      .map(([key]) => key);\r\n  }\r\n\r\n  /**\r\n   * @brief Initialize DLight Node Level variables when entering a class\r\n   * @param path\r\n   */\r\n  initNode(path: NodePath<t.ClassDeclaration>): void {\r\n    const node: t.ClassDeclaration = path.node;\r\n    this.classDeclarationNode = node;\r\n    this.classBodyNode = node.body;\r\n    this.propertiesContainer = {};\r\n\r\n    if (!node.id?.name) {\r\n      node.id = this.t.identifier(`Anonymous_${PluginProvider.uid()}`);\r\n    }\r\n    this.className = node.id?.name;\r\n\r\n    // ---- Custom decorators\r\n    this.handleClassCustomDecorators();\r\n\r\n    // ---- If devtools is enabled, add _$compName property to the class\r\n    if (this.enableDevTools) {\r\n      this.classBodyNode.body.unshift(\r\n        this.t.classProperty(this.t.identifier('_$compName'), this.t.stringLiteral(this.className))\r\n      );\r\n    }\r\n\r\n    // ---- Add dlight import and alter import name,\r\n    //      Only do this when enter the first dlight class\r\n    if (!this.didAlterImports) {\r\n      // ---- Get DLight imports\r\n      const dlightImports = this.allImports.filter(n => n.source.value === dlightDefaultPackageName);\r\n      // ---- Alter import name, e.g. \"@dlight/dlight-client\"\r\n      if (this.dlightPackageName !== dlightDefaultPackageName) {\r\n        dlightImports.forEach(i => {\r\n          i.source.value = this.dlightPackageName;\r\n        });\r\n      }\r\n\r\n      // ---- remove all tag-import\r\n      dlightImports.forEach(importNode => {\r\n        importNode.specifiers = importNode.specifiers.filter(\r\n          specifier =>\r\n            !(\r\n              this.t.isImportSpecifier(specifier) &&\r\n              this.t.isIdentifier(specifier.imported) &&\r\n              importsToDelete.includes(specifier.imported.name)\r\n            )\r\n        );\r\n      });\r\n\r\n      // ---- Add nodes import to the head of file\r\n      this.programNode!.body.unshift(\r\n        this.t.importDeclaration(\r\n          Object.entries(importMap).map(([key, value]) =>\r\n            this.t.importSpecifier(this.t.identifier(value), this.t.identifier(key))\r\n          ),\r\n          this.t.stringLiteral(this.dlightPackageName)\r\n        )\r\n      );\r\n      this.didAlterImports = true;\r\n    }\r\n  }\r\n\r\n  /* ---- Babel Visitors ---- */\r\n  programEnterVisitor(path: NodePath<t.Program>, filename: string | undefined): void {\r\n    this.enter = this.fileAllowed(filename);\r\n    if (!this.enter) return;\r\n    // switch to JSX parser according to the file extension\r\n    if ((filename && filename.endsWith('.jsx')) || (filename && filename.endsWith('.tsx'))) {\r\n      this.isJsx = true;\r\n    }\r\n\r\n    this.allImports = path.node.body.filter(n => this.t.isImportDeclaration(n)) as t.ImportDeclaration[];\r\n    // const dlightImports = this.allImports.filter(\r\n    //   n => n.source.value === dlightDefaultPackageName\r\n    // )\r\n    // if (dlightImports.length === 0) {\r\n    //   this.enter = false\r\n    //   return\r\n    // }\r\n    this.programNode = path.node;\r\n  }\r\n\r\n  programExitVisitor(): void {\r\n    if (!this.enter) return;\r\n    this.didAlterImports = false;\r\n    this.allImports = [];\r\n    this.programNode = undefined;\r\n  }\r\n\r\n  classEnter(path: NodePath<t.ClassDeclaration>): void {\r\n    if (!this.enter) return;\r\n    this.enterClassNode = this.isDLightClass(path);\r\n    if (!this.enterClassNode) return;\r\n    this.initNode(path);\r\n    this.resolveMounting(path);\r\n  }\r\n\r\n  classExit(): void {\r\n    if (!this.enter) return;\r\n    if (!this.enterClassNode) return;\r\n    this.transformDLightClass();\r\n    this.clearNode();\r\n    this.enterClassNode = false;\r\n  }\r\n\r\n  classMethodVisitor(path: NodePath<t.ClassMethod>): void {\r\n    if (!this.enterClassNode) return;\r\n    if (!this.t.isIdentifier(path.node.key)) return;\r\n    const key = path.node.key.name;\r\n    if (key === 'Body') return;\r\n\r\n    const isSnippet = this.findDecoratorByName(path.node.decorators, 'Snippet');\r\n    if (isSnippet) return;\r\n    const node = path.node;\r\n\r\n    // ---- Handle watcher\r\n    // ---- Get watcher decorator or watcher function decorator\r\n    // ---- Watcher auto collect deps:\r\n    //       @Watch\r\n    //       watcher() { myFunc() }\r\n    // ---- Watcher function manual set deps:\r\n    //       @Watch([\"count\", \"flag\"])\r\n    //       watcherFunc() { myFunc() }\r\n    const watchDeco = this.findDecoratorByName(node.decorators, 'Watch');\r\n    if (this.t.isIdentifier(node.key, { name: 'constructor' })) return;\r\n    this.autoBindMethods(node);\r\n    if (!watchDeco) return;\r\n\r\n    // ---- Get dependencies from watcher decorator or watcher function decorator\r\n    let deps: string[] = [];\r\n    let depsNode;\r\n    if (this.t.isIdentifier(watchDeco)) {\r\n      [deps, depsNode] = this.getDependencies(node);\r\n    } else {\r\n      const listenDepStrings = watchDeco.arguments\r\n        .filter(arg => this.t.isStringLiteral(arg))\r\n        .map(arg => (arg as t.StringLiteral).value);\r\n      const pseudoMethod = this.t.classMethod(\r\n        'method',\r\n        node.key,\r\n        [],\r\n        this.t.blockStatement([\r\n          this.t.expressionStatement(\r\n            this.t.arrayExpression(\r\n              listenDepStrings.map(str => this.t.memberExpression(this.t.thisExpression(), this.t.identifier(str)))\r\n            )\r\n          ),\r\n        ])\r\n      );\r\n\r\n      [deps, depsNode] = this.getDependencies(pseudoMethod);\r\n    }\r\n    // ---- Register watcher to propertiesContainer\r\n    this.propertiesContainer[key] = {\r\n      node,\r\n      deps,\r\n      depsNode,\r\n      isWatcher: true,\r\n    };\r\n    node.decorators = this.removeDecorators(node.decorators, ['Watch']);\r\n  }\r\n\r\n  classPropertyVisitor(path: NodePath<t.ClassProperty>): void {\r\n    if (!this.enterClassNode) return;\r\n    const node = path.node;\r\n    if (!this.t.isIdentifier(node.key)) return;\r\n    const key = node.key.name;\r\n    if (key === 'Body') return;\r\n    const decorators = node.decorators;\r\n    const isSnippet = this.findDecoratorByName(decorators, 'Snippet');\r\n    if (isSnippet) return;\r\n    // ---- Parse model\r\n    const isModel = this.parseModel(path);\r\n\r\n    const isProp = !!this.findDecoratorByName(decorators, 'Prop');\r\n    const isEnv = !!this.findDecoratorByName(decorators, 'Env');\r\n\r\n    const isChildren = !!this.findDecoratorByName(node.decorators, 'Children');\r\n\r\n    const [deps, depsNode] = !isChildren ? this.getDependencies(node) : [[]];\r\n\r\n    this.propertiesContainer[key] = {\r\n      node,\r\n      deps,\r\n      depsNode,\r\n      isStatic: !!this.findDecoratorByName(decorators, 'Static'),\r\n      isContent: !!this.findDecoratorByName(decorators, 'Content'),\r\n      isChildren,\r\n      isPropOrEnv: isProp ? 'Prop' : isEnv ? 'Env' : undefined,\r\n      isModel,\r\n    };\r\n\r\n    node.decorators = this.removeDecorators(decorators, availableDecoNames);\r\n  }\r\n\r\n  /* ---- Decorator Resolvers ---- */\r\n  /**\r\n   * @brief Decorator resolver: Watcher\r\n   * Add:\r\n   * $wW${key}\r\n   * in watcher:\r\n   * watchxx() {\r\n   *  if (this._$cache(${key}, ${deps})) return\r\n   *  ...\r\n   * }\r\n   * @param node\r\n   */\r\n  resolveWatcherDecorator(node: t.ClassMethod, depsNode: t.ArrayExpression): void {\r\n    if (!this.t.isIdentifier(node.key)) return;\r\n    const key = node.key.name;\r\n    const propertyIdx = this.classBodyNode!.body.indexOf(node);\r\n    const watcherNode = this.t.classProperty(this.t.identifier(`$w$${key}`));\r\n    this.classBodyNode!.body.splice(propertyIdx, 0, watcherNode);\r\n    node.body.body.unshift(\r\n      this.t.ifStatement(\r\n        this.t.callExpression(this.t.memberExpression(this.t.thisExpression(), this.t.identifier('_$cache')), [\r\n          this.t.stringLiteral(key),\r\n          depsNode,\r\n        ]),\r\n        this.t.blockStatement([this.t.returnStatement()])\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @brief Decorator resolver: Children\r\n   * Add:\r\n   * get ${key}() {\r\n   *  return this._$children\r\n   * }\r\n   * @param node\r\n   */\r\n  resolveChildrenDecorator(node: t.ClassProperty) {\r\n    if (!this.classBodyNode) return;\r\n    if (!this.t.isIdentifier(node.key)) return;\r\n    const key = node.key.name;\r\n    const propertyIdx = this.classBodyNode.body.indexOf(node);\r\n\r\n    const childrenFuncCallNode = this.t.memberExpression(this.t.thisExpression(), this.t.identifier('_$children'));\r\n\r\n    const getterNode = this.t.classMethod(\r\n      'get',\r\n      this.t.identifier(key),\r\n      [],\r\n      this.t.blockStatement([this.t.returnStatement(childrenFuncCallNode)])\r\n    );\r\n    this.classBodyNode.body.splice(propertyIdx, 1, getterNode);\r\n  }\r\n\r\n  /**\r\n   * @brief Decorator resolver: Content\r\n   * Add:\r\n   * _$contentKey = \"key\"\r\n   * @param node\r\n   */\r\n  resolveContentDecorator(node: t.ClassProperty) {\r\n    if (!this.classBodyNode) return;\r\n    if (!this.t.isIdentifier(node.key)) return;\r\n\r\n    // ---- Already has _$contentKey\r\n    if (this.classBodyNode.body.some(n => this.t.isClassProperty(n) && (n.key as t.Identifier).name === '_$contentKey'))\r\n      return;\r\n    const key = node.key.name;\r\n    const propertyIdx = this.classBodyNode.body.indexOf(node);\r\n\r\n    const derivedStatusKey = this.t.classProperty(this.t.identifier('_$contentKey'), this.t.stringLiteral(key));\r\n    this.classBodyNode.body.splice(propertyIdx, 0, derivedStatusKey);\r\n  }\r\n\r\n  /**\r\n   * @brief Decorator resolver: Prop/Env\r\n   * Add:\r\n   * $p/e$${key}\r\n   * @param node\r\n   */\r\n  resolvePropDecorator(node: t.ClassProperty, decoratorName: 'Prop' | 'Env') {\r\n    if (!this.classBodyNode) return;\r\n    if (!this.t.isIdentifier(node.key)) return;\r\n    const key = node.key.name;\r\n    const propertyIdx = this.classBodyNode.body.indexOf(node);\r\n    const tag = decoratorName.toLowerCase() === 'prop' ? 'p' : 'e';\r\n    const derivedStatusKey = this.t.classProperty(this.t.identifier(`$${tag}$${key}`));\r\n    this.classBodyNode.body.splice(propertyIdx, 0, derivedStatusKey);\r\n  }\r\n\r\n  /**\r\n   * @brief Decorator resolver: State\r\n   * Add:\r\n   *  $$${key} = ${depIdx}\r\n   *  $sub$${key} = [${reversedDeps}]\r\n   * @param node\r\n   */\r\n  resolveStateDecorator(node: t.ClassProperty, idx: number, reverseDeps: Set<string> | undefined) {\r\n    if (!this.classBodyNode) return;\r\n    if (!this.t.isIdentifier(node.key)) return;\r\n    const key = node.key.name;\r\n    const propertyIdx = this.classBodyNode.body.indexOf(node);\r\n\r\n    const idxNode = !this.dLightModel\r\n      ? [this.t.classProperty(this.t.identifier(`$$${key}`), this.t.numericLiteral(1 << idx))]\r\n      : [];\r\n\r\n    const depsNode = reverseDeps\r\n      ? [\r\n          this.t.classProperty(\r\n            this.t.identifier(`$s$${key}`),\r\n            this.t.arrayExpression([...reverseDeps].map(d => this.t.stringLiteral(d)))\r\n          ),\r\n        ]\r\n      : [];\r\n\r\n    this.classBodyNode.body.splice(propertyIdx + 1, 0, ...idxNode, ...depsNode);\r\n  }\r\n\r\n  /* ---- Helper Functions ---- */\r\n  handleClassCustomDecorators() {\r\n    if (!this.classBodyNode) return;\r\n    const decorators = this.classDeclarationNode?.decorators;\r\n    if (!decorators) return;\r\n    // ---- Forward Prop\r\n    const forwardPropDeco = this.findDecoratorByName(decorators, 'ForwardProps');\r\n    /**\r\n     * _$forwardProp\r\n     * _$forwardPropMap = new Set()\r\n     * _$forwardPropsId = []\r\n     */\r\n    if (forwardPropDeco) {\r\n      this.classBodyNode.body.unshift(\r\n        this.t.classProperty(this.t.identifier('_$forwardProps')),\r\n        this.t.classProperty(\r\n          this.t.identifier('_$forwardPropsSet'),\r\n          this.t.newExpression(this.t.identifier('Set'), [])\r\n        ),\r\n        this.t.classProperty(this.t.identifier('_$forwardPropsId'), this.t.arrayExpression([]))\r\n      );\r\n      this.classDeclarationNode!.decorators = this.removeDecorators(decorators, ['ForwardProps']);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @brief Transform the whole DLight class when exiting the class\r\n   *  1. Alter all the state properties\r\n   *  2. Transform MainView and Snippets with DLight syntax\r\n   */\r\n  transformDLightClass(): void {\r\n    const usedProperties = this.handleView();\r\n    this.addAutoUpdate(this.dLightModel ? this.availableProperties : usedProperties);\r\n    const propertyArr = Object.entries(this.propertiesContainer).reverse();\r\n    const depReversedMap = this.dependencyMapReversed();\r\n\r\n    for (const [\r\n      key,\r\n      { node, deps, isStatic, isChildren, isPropOrEnv, isWatcher, isContent, isModel, depsNode },\r\n    ] of propertyArr) {\r\n      if (isChildren) {\r\n        this.resolveChildrenDecorator(node as t.ClassProperty);\r\n        continue;\r\n      }\r\n      if (deps.length > 0) {\r\n        usedProperties.push(...deps);\r\n        if (isWatcher) {\r\n          this.resolveWatcherDecorator(node as t.ClassMethod, depsNode!);\r\n        } else if (!isModel) {\r\n          this.handleDerivedProperty(node as t.ClassProperty, depsNode!);\r\n        }\r\n      }\r\n      if (isPropOrEnv) {\r\n        this.resolvePropDecorator(node as t.ClassProperty, isPropOrEnv);\r\n      }\r\n      if (isContent) {\r\n        this.resolvePropDecorator(node as t.ClassProperty, 'Prop');\r\n        this.resolveContentDecorator(node as t.ClassProperty);\r\n      }\r\n      if (isStatic) continue;\r\n      if (usedProperties.includes(key)) {\r\n        this.resolveStateDecorator(node as t.ClassProperty, this.availableProperties.indexOf(key), depReversedMap[key]);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @brief Add updateProp and updateDerived if there's a assignment\r\n   * @param usedProperties\r\n   * @returns\r\n   */\r\n  private addAutoUpdate(usedProperties: string[]) {\r\n    if (!this.classBodyNode) return;\r\n    const nonViewNodes = this.classBodyNode.body.filter(\r\n      n =>\r\n        !(\r\n          ((this.t.isClassProperty(n) || this.t.isClassMethod(n)) &&\r\n            ['constructor', '_$compName'].includes((n.key as t.Identifier).name)) ||\r\n          this.t.isClassMethod(n, { static: true }) ||\r\n          this.t.isClassProperty(n, { static: true })\r\n        )\r\n    );\r\n    nonViewNodes.forEach(n => {\r\n      const value = this.t.isClassProperty(n) ? n.value : this.t.isClassMethod(n) ? n.body : null;\r\n      if (!value) return;\r\n      this.addUpdateDerived(value, usedProperties);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @Brief Add updateView and updateDerived to the node\r\n   * @param node\r\n   * @param usedProperties\r\n   */\r\n  private addUpdateDerived(node: t.Expression | t.BlockStatement, usedProperties: string[]) {\r\n    const newUpdateProp = (node: t.Expression, key: string) =>\r\n      this.t.callExpression(this.t.memberExpression(this.t.thisExpression(), this.t.identifier('_$ud')), [\r\n        node,\r\n        this.t.stringLiteral(key),\r\n      ]);\r\n    this.traverse(this.valueWrapper(node), {\r\n      MemberExpression: path => {\r\n        if (!this.t.isThisExpression(path.node.object) || !this.t.isIdentifier(path.node.property)) return;\r\n        const key = path.node.property.name;\r\n        if (!usedProperties.includes(key)) return;\r\n        const assignPath = this.isAssignmentExpressionLeft(path);\r\n        if (!assignPath) return;\r\n        assignPath.replaceWith(newUpdateProp(assignPath.node as t.Expression, key));\r\n        assignPath.skip();\r\n      },\r\n      CallExpression: path => {\r\n        if (!this.t.isMemberExpression(path.node.callee)) return;\r\n        const funcNameNode = path.node.callee.property;\r\n        if (!this.t.isIdentifier(funcNameNode)) return;\r\n        if (!reactivityFuncNames.includes(funcNameNode.name)) return;\r\n        let callee = path.get('callee').get('object') as NodePath;\r\n\r\n        while (this.t.isMemberExpression(callee.node)) {\r\n          callee = callee.get('object') as NodePath;\r\n        }\r\n        if (!this.t.isThisExpression(callee?.node)) return;\r\n        const key = ((callee.parentPath!.node as t.MemberExpression).property as t.Identifier).name;\r\n        path.replaceWith(newUpdateProp(path.node, key));\r\n        path.skip();\r\n      },\r\n    });\r\n  }\r\n\r\n  /* ---- DLight Class View Handlers ---- */\r\n  /**\r\n   * @brief Transform Body and Snippets with DLight syntax\r\n   * @returns used properties\r\n   */\r\n  handleView(): string[] {\r\n    if (!this.classBodyNode) return [];\r\n    const usedPropertySet = new Set<string>();\r\n    let mainView: undefined | t.ClassMethod;\r\n    const snippetNodes: t.ClassMethod[] = [];\r\n    for (let viewNode of this.classBodyNode.body) {\r\n      if (!this.t.isClassProperty(viewNode) && !this.t.isClassMethod(viewNode)) continue;\r\n      if (!this.t.isIdentifier(viewNode.key)) continue;\r\n      const isSnippet = this.findDecoratorByName(viewNode.decorators, 'Snippet');\r\n      const isMainView = viewNode.key.name === 'Body';\r\n      if (!isSnippet && !isMainView) continue;\r\n\r\n      if (this.t.isClassProperty(viewNode)) {\r\n        // ---- Handle TSAsExpression, e.g. MyView = (() => {}) as Type1 as Type2\r\n        let exp = viewNode.value;\r\n        while (this.t.isTSAsExpression(exp)) exp = exp.expression;\r\n        if (!this.t.isArrowFunctionExpression(exp)) continue;\r\n        viewNode.value = exp;\r\n        // ---- Transform arrow function property into method\r\n        const newViewNode = this.arrowFunctionPropertyToMethod(viewNode);\r\n        if (!newViewNode) continue;\r\n        viewNode = newViewNode;\r\n      }\r\n\r\n      if (isSnippet) {\r\n        viewNode.decorators = null;\r\n        snippetNodes.push(viewNode);\r\n      } else {\r\n        mainView = viewNode;\r\n      }\r\n    }\r\n\r\n    const snippetNames = snippetNodes.map(v => (v.key as t.Identifier).name);\r\n    const snippetPropSubDepMap: SnippetPropSubDepMap = Object.fromEntries(\r\n      snippetNodes\r\n        .map(v => {\r\n          const prop = v.params[0];\r\n          if (!prop || !this.t.isObjectPattern(prop)) return ['-', null as any];\r\n          const props = Object.fromEntries(\r\n            prop.properties\r\n              .map(p => {\r\n                if (!this.t.isObjectProperty(p)) return ['-', null];\r\n                const key = (p.key as t.Identifier).name;\r\n                // ---- Get identifiers that depend on this prop\r\n                const subDeps = this.getIdentifiers(\r\n                  // ---- Some unimportant value wrapper\r\n                  this.t.assignmentExpression(\r\n                    '=',\r\n                    this.t.objectPattern([this.t.objectProperty(this.t.numericLiteral(0), p.value)]),\r\n                    this.t.numericLiteral(0)\r\n                  )\r\n                ).filter(v => v !== key);\r\n                return [key, subDeps];\r\n              })\r\n              .filter(([_, props]) => props)\r\n          );\r\n          return [(v.key as t.Identifier).name, props];\r\n        })\r\n        .filter(([_, props]) => props)\r\n    );\r\n    let templateIdx = -1;\r\n    if (mainView) {\r\n      let usedProperties;\r\n      [usedProperties, templateIdx] = this.alterMainView(mainView, snippetNames, snippetPropSubDepMap);\r\n      usedProperties.forEach(usedPropertySet.add.bind(usedPropertySet));\r\n    }\r\n\r\n    snippetNodes.forEach(viewNode => {\r\n      let usedProperties;\r\n      [usedProperties, templateIdx] = this.alterSnippet(viewNode, snippetNames, snippetPropSubDepMap, templateIdx);\r\n      usedProperties.forEach(usedPropertySet.add.bind(usedPropertySet));\r\n    });\r\n\r\n    const usedProperties: string[] = [];\r\n    this.availableProperties.forEach(p => {\r\n      if (usedPropertySet.has(p)) usedProperties.push(p);\r\n    });\r\n    // const usedProperties = usedPropertyDeps.map(dep => dep.slice(1, -4))\r\n    return usedProperties;\r\n  }\r\n\r\n  /**\r\n   * @brief Transform Views with DLight syntax\r\n   * @param viewNode\r\n   * @param snippetNames\r\n   * @param isSnippet\r\n   * @returns Used properties\r\n   */\r\n  alterMainView(\r\n    viewNode: t.ClassMethod,\r\n    snippetNames: string[],\r\n    snippetPropSubDepMap: SnippetPropSubDepMap\r\n  ): [Set<string>, number] {\r\n    let viewUnits: ViewUnit[] = [];\r\n    // if the body method return a JSX element, parse it\r\n    if (this.isJsx) {\r\n      // Assume there should not early return\r\n      const returnNode = viewNode.body.body.find(v => this.t.isReturnStatement(v)) as t.ReturnStatement;\r\n\r\n      // check if the return statement is a JSX element\r\n      if (this.t.isJSXElement(returnNode.argument) || this.t.isJSXFragment(returnNode.argument)) {\r\n        viewUnits = parseJSX(returnNode.argument, {\r\n          babelApi: this.babelApi,\r\n          htmlTags: this.htmlTags,\r\n          parseTemplate: false,\r\n        });\r\n      }\r\n    } else {\r\n      viewUnits = parseView(viewNode.body, {\r\n        babelApi: this.babelApi,\r\n        snippetNames: snippetNames,\r\n        htmlTags: this.htmlTags,\r\n      });\r\n    }\r\n\r\n    const [viewParticles, usedPropertySet] = parseReactivity(viewUnits, {\r\n      babelApi: this.babelApi,\r\n      availableProperties: this.availableProperties,\r\n      dependencyMap: this.dependencyMap,\r\n      reactivityFuncNames,\r\n    });\r\n\r\n    const [body, classProperties, templateIdx] = generateView(viewParticles, {\r\n      babelApi: this.babelApi,\r\n      className: this.className!,\r\n      importMap,\r\n      snippetPropMap: Object.fromEntries(\r\n        Object.entries(snippetPropSubDepMap).map(([key, props]) => [key, Object.keys(props)])\r\n      ),\r\n      templateIdx: -1,\r\n      attributeMap: this.attributeMap,\r\n      alterAttributeMap,\r\n    });\r\n    viewNode.body = body;\r\n    this.classBodyNode?.body.push(...classProperties);\r\n\r\n    return [usedPropertySet, templateIdx];\r\n  }\r\n\r\n  /**\r\n   * @brief Transform Snippets with DLight syntax\r\n   * @param viewNode\r\n   * @param snippetNames\r\n   * @param snippetPropSubDepMap\r\n   * @param templateIdx\r\n   * @returns\r\n   */\r\n  alterSnippet(\r\n    viewNode: t.ClassMethod,\r\n    snippetNames: string[],\r\n    snippetPropSubDepMap: SnippetPropSubDepMap,\r\n    templateIdx: number\r\n  ): [Set<string>, number] {\r\n    // ---- Add prop => Sub() => Sub(_$, $snippetNode)\r\n    if (viewNode.params.length === 0) {\r\n      viewNode.params.push(this.t.identifier('_$'), this.t.identifier('$snippetNode'));\r\n    } else if (viewNode.params.length === 1) {\r\n      viewNode.params.push(this.t.identifier('$snippetNode'));\r\n    } else {\r\n      viewNode.params[1] = this.t.identifier('$snippetNode');\r\n      viewNode.params.length = 2;\r\n    }\r\n    const viewUnits = parseView(viewNode.body, {\r\n      babelApi: this.babelApi,\r\n      snippetNames: snippetNames,\r\n      htmlTags: this.htmlTags,\r\n    });\r\n\r\n    const snippetProp = snippetPropSubDepMap[(viewNode.key as t.Identifier).name] ?? [];\r\n    const identifierDepMap: Record<string, string[]> = {};\r\n    Object.entries(snippetProp).forEach(([key, subDeps]) => {\r\n      subDeps.forEach(dep => {\r\n        identifierDepMap[dep] = [key];\r\n      });\r\n    });\r\n\r\n    const [viewParticlesProperty, usedPropertySet] = parseReactivity(viewUnits, {\r\n      babelApi: this.babelApi,\r\n      availableProperties: this.availableProperties,\r\n      availableIdentifiers: Object.keys(snippetProp),\r\n      dependencyMap: this.dependencyMap,\r\n      dependencyParseType: 'property',\r\n      reactivityFuncNames,\r\n    });\r\n\r\n    const [viewParticlesIdentifier] = parseReactivity(viewUnits, {\r\n      babelApi: this.babelApi,\r\n      availableProperties: Object.keys(snippetProp),\r\n      dependencyMap: this.dependencyMap,\r\n      dependencyParseType: 'identifier',\r\n      identifierDepMap,\r\n      reactivityFuncNames,\r\n    });\r\n\r\n    const snippetPropMap = Object.fromEntries(\r\n      Object.entries(snippetPropSubDepMap).map(([key, props]) => [key, Object.keys(props)])\r\n    );\r\n    const [body, classProperties, newTemplateIdx] = generateSnippet(\r\n      viewParticlesProperty,\r\n      viewParticlesIdentifier,\r\n      viewNode.params[0] as t.ObjectPattern,\r\n      {\r\n        babelApi: this.babelApi,\r\n        className: this.className!,\r\n        importMap,\r\n        snippetPropMap,\r\n        templateIdx,\r\n        attributeMap: this.attributeMap,\r\n        alterAttributeMap,\r\n      }\r\n    );\r\n    viewNode.body = body;\r\n    this.classBodyNode?.body.push(...classProperties);\r\n\r\n    return [usedPropertySet, newTemplateIdx];\r\n  }\r\n\r\n  /**\r\n   * @brief Test if the file is allowed to be transformed\r\n   * @param fileName\r\n   * @returns is file allowed\r\n   */\r\n  private fileAllowed(fileName: string | undefined): boolean {\r\n    if (this.includes.includes('*')) return true;\r\n    if (!fileName) return false;\r\n    if (this.excludes.some(pattern => minimatch(fileName, pattern))) return false;\r\n    if (!this.includes.some(pattern => minimatch(fileName, pattern))) return false;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @brief Test if the class is a dlight view\r\n   * @param path\r\n   * @returns\r\n   */\r\n  private isDLightView(path: NodePath<t.ClassDeclaration>): boolean {\r\n    const node = path.node;\r\n    const decorators = node.decorators ?? [];\r\n    const isViewDecorator = decorators.find((deco: t.Decorator) =>\r\n      this.t.isIdentifier(deco.expression, { name: 'View' })\r\n    );\r\n    if (isViewDecorator) {\r\n      node.superClass = this.t.identifier('View');\r\n      node.decorators = node.decorators?.filter(\r\n        (deco: t.Decorator) => !this.t.isIdentifier(deco.expression, { name: 'View' })\r\n      );\r\n    }\r\n    return this.t.isIdentifier(node.superClass, { name: 'View' });\r\n  }\r\n\r\n  /**\r\n   * @brief Test if the class is a dlight model\r\n   * @param path\r\n   * @returns\r\n   */\r\n  private isDLightModel(path: NodePath<t.ClassDeclaration>): boolean {\r\n    const node = path.node;\r\n    const decorators = node.decorators ?? [];\r\n    const isModelDecorator = decorators.find((deco: t.Decorator) =>\r\n      this.t.isIdentifier(deco.expression, { name: 'Model' })\r\n    );\r\n    if (isModelDecorator) {\r\n      node.superClass = this.t.identifier('Model');\r\n      node.decorators = node.decorators?.filter(\r\n        (deco: t.Decorator) => !this.t.isIdentifier(deco.expression, { name: 'Model' })\r\n      );\r\n    }\r\n\r\n    // ---- Add property _$model\r\n    node.body.body.unshift(this.t.classProperty(this.t.identifier('_$model')));\r\n\r\n    // ---- Delete all views\r\n    node.body.body = node.body.body.filter(\r\n      n =>\r\n        !(\r\n          (this.t.isClassProperty(n) || this.t.isClassMethod(n, { kind: 'method' })) &&\r\n          (this.findDecoratorByName(n.decorators, 'Snippet') || (this.t.isIdentifier(n.key) && n.key.name === 'Body'))\r\n        )\r\n    );\r\n    this.dLightModel = true;\r\n\r\n    return this.t.isIdentifier(node.superClass, { name: 'Model' });\r\n  }\r\n\r\n  /**\r\n   * @brief Test if the class is a dlight class\r\n   * @param path\r\n   * @returns\r\n   */\r\n  isDLightClass(path: NodePath<t.ClassDeclaration>): boolean {\r\n    return this.isDLightView(path) || this.isDLightModel(path);\r\n  }\r\n\r\n  /**\r\n   * @brief Parse any use(Model) inside a property\r\n   * @param path\r\n   * @returns\r\n   */\r\n  private parseModel(path: NodePath<t.ClassProperty>) {\r\n    const hasUseImport = this.allImports.some(\r\n      imp =>\r\n        imp.source.value === this.dlightPackageName &&\r\n        imp.specifiers.some(s => {\r\n          if (this.t.isImportSpecifier(s) && this.t.isIdentifier(s.imported, { name: 'use' })) {\r\n            return true;\r\n          }\r\n        })\r\n    );\r\n    if (!hasUseImport) return;\r\n    const node = path.node;\r\n    const key = node.key;\r\n    if (!this.t.isIdentifier(key)) return;\r\n    const value = node.value;\r\n    if (!this.t.isCallExpression(value)) return;\r\n    if (!this.t.isIdentifier(value.callee, { name: 'use' })) return;\r\n    const args = value.arguments;\r\n    const propsArg = args[1];\r\n    const contentArg = args[2];\r\n    let propsNode: t.Expression = this.t.nullLiteral();\r\n    if (propsArg) {\r\n      const mergedPropsNode: [t.Expression, t.ArrayExpression | t.NullLiteral][] = [];\r\n      const spreadPropsNode: [t.Expression, t.Expression, t.ArrayExpression | t.NullLiteral][] = [];\r\n      // ---- Get props deps\r\n      if (this.t.isObjectExpression(propsArg)) {\r\n        propsArg.properties.forEach(prop => {\r\n          if (this.t.isSpreadElement(prop)) {\r\n            const [, depsNode] = this.getDependenciesFromNode(prop.argument as t.Expression);\r\n            mergedPropsNode.push([prop.argument as t.Expression, depsNode ?? this.t.nullLiteral()]);\r\n          } else if (this.t.isObjectProperty(prop)) {\r\n            const [, depsNode] = this.getDependenciesFromNode(prop.value as t.Expression);\r\n            spreadPropsNode.push([\r\n              !prop.computed && this.t.isIdentifier(prop.key)\r\n                ? this.t.stringLiteral(prop.key.name)\r\n                : (prop.key as t.Expression),\r\n              prop.value as t.Expression,\r\n              depsNode ?? this.t.nullLiteral(),\r\n            ]);\r\n          } else {\r\n            spreadPropsNode.push([\r\n              !prop.computed && this.t.isIdentifier(prop.key)\r\n                ? this.t.stringLiteral(prop.key.name)\r\n                : (prop.key as t.Expression),\r\n              this.t.arrowFunctionExpression([], prop.body),\r\n              this.t.nullLiteral(),\r\n            ]);\r\n          }\r\n        });\r\n      } else {\r\n        const [, depsNode] = this.getDependenciesFromNode(propsArg as t.Expression);\r\n        mergedPropsNode.push([propsArg as t.Expression, depsNode ?? this.t.nullLiteral()]);\r\n      }\r\n      /**\r\n       * @View { ok: this.count, ...this.props }\r\n       * {\r\n       *  m: [[this.props, []]]\r\n       *  s: [[\"ok\", this.count, [this.count]]]\r\n       * }\r\n       */\r\n      propsNode = this.t.objectExpression([\r\n        this.t.objectProperty(\r\n          this.t.identifier('m'),\r\n          this.t.arrayExpression(mergedPropsNode.map(n => this.t.arrayExpression(n)))\r\n        ),\r\n        this.t.objectProperty(\r\n          this.t.identifier('s'),\r\n          this.t.arrayExpression(spreadPropsNode.map(n => this.t.arrayExpression(n)))\r\n        ),\r\n      ]);\r\n    }\r\n\r\n    let contentNode: t.Expression = this.t.nullLiteral();\r\n    if (contentArg) {\r\n      const [, depsNode] = this.getDependenciesFromNode(contentArg as t.Expression);\r\n      contentNode = this.t.arrayExpression([contentArg as t.Expression, depsNode ?? this.t.nullLiteral()]);\r\n    }\r\n    args[1] = this.t.arrowFunctionExpression([], propsNode);\r\n    args[2] = this.t.arrowFunctionExpression([], contentNode);\r\n    args[3] = this.t.stringLiteral(key.name);\r\n    value.callee = this.t.memberExpression(this.t.thisExpression(), this.t.identifier('_$injectModel'));\r\n    // ---- Wrap a function for lazy evaluation\r\n    node.value = this.t.arrowFunctionExpression([], value);\r\n    // ---- Add $md$${key}\r\n    const propertyIdx = this.classBodyNode!.body.indexOf(node);\r\n    const modelDecorator = this.t.classProperty(this.t.identifier(`$md$${key.name}`));\r\n    this.classBodyNode!.body.splice(propertyIdx, 0, modelDecorator);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @brief Remove decorators by name\r\n   *  Only search for Identifier and CallExpression, e.g, @Ok, @Ok()\r\n   * @param decorators\r\n   * @param names\r\n   * @returns new decorators\r\n   */\r\n  private removeDecorators(decorators: t.Decorator[] | undefined | null, names: string[]): t.Decorator[] {\r\n    if (!decorators) return [];\r\n    return decorators.filter(\r\n      d =>\r\n        !(\r\n          (this.t.isIdentifier(d.expression) && names.includes(d.expression.name)) ||\r\n          (this.t.isCallExpression(d.expression) &&\r\n            this.t.isIdentifier(d.expression.callee) &&\r\n            names.includes(d.expression.callee.name))\r\n        )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @brief Find decorator by name,\r\n   *  Only search for Identifier and CallExpression, e.g, @Ok, @Ok()\r\n   * @param decorators\r\n   * @param name\r\n   * @returns Identifier or CallExpression or nothing\r\n   */\r\n  private findDecoratorByName(\r\n    decorators: t.Decorator[] | undefined | null,\r\n    name: string\r\n  ): t.Identifier | t.CallExpression | undefined {\r\n    if (!decorators) return;\r\n    return decorators.find(\r\n      deco =>\r\n        this.t.isIdentifier(deco.expression, { name }) ||\r\n        (this.t.isCallExpression(deco.expression) && this.t.isIdentifier(deco.expression.callee, { name }))\r\n    )?.expression as t.Identifier | t.CallExpression | undefined;\r\n  }\r\n\r\n  /**\r\n   * @brief Generate a dependency node from a dependency identifier,\r\n   *  loop until the parent node is not a binary expression or a member expression\r\n   * @param path\r\n   * @returns\r\n   */\r\n  private geneDependencyNode(path: NodePath): t.Node {\r\n    let parentPath = path;\r\n    while (parentPath?.parentPath) {\r\n      const pParentPath = parentPath.parentPath;\r\n      if (\r\n        !(\r\n          this.t.isMemberExpression(pParentPath.node, { computed: false }) ||\r\n          this.t.isOptionalMemberExpression(pParentPath.node)\r\n        )\r\n      ) {\r\n        break;\r\n      }\r\n      parentPath = pParentPath;\r\n    }\r\n    const depNode = this.t.cloneNode(parentPath.node);\r\n    // ---- Turn memberExpression to optionalMemberExpression\r\n    this.traverse(this.valueWrapper(depNode as t.Expression), {\r\n      MemberExpression: innerPath => {\r\n        if (this.t.isThisExpression(innerPath.node.object)) return;\r\n        innerPath.node.optional = true;\r\n        innerPath.node.type = 'OptionalMemberExpression' as any;\r\n      },\r\n    });\r\n    return depNode;\r\n  }\r\n\r\n  /**\r\n   * constructor() {\r\n   *  super()\r\n   * }\r\n   */\r\n  private addConstructor(): t.ClassMethod {\r\n    let constructor = this.classBodyNode!.body.find(n =>\r\n      this.t.isClassMethod(n, { kind: 'constructor' })\r\n    ) as t.ClassMethod;\r\n    if (constructor) return constructor;\r\n\r\n    constructor = this.t.classMethod(\r\n      'constructor',\r\n      this.t.identifier('constructor'),\r\n      [],\r\n      this.t.blockStatement([this.t.expressionStatement(this.t.callExpression(this.t.super(), []))])\r\n    );\r\n\r\n    this.classBodyNode!.body.unshift(constructor);\r\n    return constructor;\r\n  }\r\n\r\n  private autoBindMethods(node: t.ClassMethod) {\r\n    const constructorNode = this.addConstructor();\r\n    constructorNode.body.body.push(\r\n      this.t.expressionStatement(\r\n        this.t.assignmentExpression(\r\n          '=',\r\n          this.t.memberExpression(this.t.thisExpression(), node.key),\r\n          this.t.callExpression(\r\n            this.t.memberExpression(\r\n              this.t.memberExpression(this.t.thisExpression(), node.key),\r\n              this.t.identifier('bind')\r\n            ),\r\n            [this.t.thisExpression()]\r\n          )\r\n        )\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * ${key}\r\n   * get $f$${key}() {\r\n   *  if (this._$cache(${key}, ${deps})) return this.${key}\r\n   *  return ${value}\r\n   * }\r\n   */\r\n  private handleDerivedProperty(node: t.ClassProperty, depsNode: t.ArrayExpression) {\r\n    if (!this.t.isIdentifier(node.key)) return;\r\n    const key = node.key.name;\r\n    const value = node.value;\r\n    const propertyIdx = this.classBodyNode!.body.indexOf(node);\r\n    const getterNode = this.t.classMethod(\r\n      'get',\r\n      this.t.identifier(`$f$${key}`),\r\n      [],\r\n      this.t.blockStatement([\r\n        this.t.ifStatement(\r\n          this.t.callExpression(this.t.memberExpression(this.t.thisExpression(), this.t.identifier('_$cache')), [\r\n            this.t.stringLiteral(key),\r\n            depsNode,\r\n          ]),\r\n          this.t.blockStatement([\r\n            this.t.returnStatement(this.t.memberExpression(this.t.thisExpression(), this.t.identifier(key))),\r\n          ])\r\n        ),\r\n        this.t.returnStatement(value),\r\n      ])\r\n    );\r\n    this.classBodyNode!.body.splice(propertyIdx + 1, 0, getterNode);\r\n    node.value = null;\r\n  }\r\n\r\n  private getDependenciesFromNode(\r\n    node: t.Expression | t.ClassDeclaration,\r\n    isClassLevel = false\r\n  ): [string[], t.ArrayExpression | undefined] {\r\n    // ---- Deps: console.log(this.count)\r\n    const deps = new Set<string>();\r\n    // ---- Assign deps: this.count = 1 / this.count++\r\n    const assignDeps = new Set<string>();\r\n    const depNodes: Record<string, t.Expression[]> = {};\r\n\r\n    this.traverse(this.valueWrapper(node), {\r\n      MemberExpression: innerPath => {\r\n        if (!this.t.isIdentifier(innerPath.node.property) || !this.t.isThisExpression(innerPath.node.object)) return;\r\n\r\n        const propertyKey = innerPath.node.property.name;\r\n        if (this.isAssignmentExpressionLeft(innerPath) || this.isAssignmentFunction(innerPath)) {\r\n          assignDeps.add(propertyKey);\r\n        } else if (\r\n          this.availableProperties.includes(propertyKey) &&\r\n          !this.isMemberInEscapeFunction(innerPath, this.classDeclarationNode!) &&\r\n          !this.isMemberInManualFunction(innerPath, this.classDeclarationNode!)\r\n        ) {\r\n          deps.add(propertyKey);\r\n          if (isClassLevel) this.dependencyMap[propertyKey]?.forEach(deps.add.bind(deps));\r\n          if (!depNodes[propertyKey]) depNodes[propertyKey] = [];\r\n          depNodes[propertyKey].push(this.geneDependencyNode(innerPath));\r\n        }\r\n      },\r\n    });\r\n\r\n    // ---- Eliminate deps that are assigned in the same method\r\n    //      e.g. { console.log(this.count); this.count = 1 }\r\n    //      this will cause infinite loop\r\n    //      so we eliminate \"count\" from deps\r\n    assignDeps.forEach(dep => {\r\n      deps.delete(dep);\r\n      delete depNodes[dep];\r\n    });\r\n\r\n    let dependencyNodes = Object.values(depNodes).flat();\r\n    // ---- deduplicate the dependency nodes\r\n    dependencyNodes = dependencyNodes.filter((n, i) => {\r\n      const idx = dependencyNodes.findIndex(m => this.t.isNodesEquivalent(m, n));\r\n      return idx === i;\r\n    });\r\n\r\n    // ---- Add deps to dependencyMap\r\n    const depArr = [...deps];\r\n    if (isClassLevel && deps.size > 0) {\r\n      const propertyKey = (((node as t.ClassDeclaration).body.body[0] as t.ClassMethod).key as t.Identifier).name;\r\n      this.dependencyMap[propertyKey] = depArr;\r\n    }\r\n\r\n    return [depArr, this.t.arrayExpression(dependencyNodes)];\r\n  }\r\n  /**\r\n   * @brief Get all valid dependencies of a babel path\r\n   * @param path\r\n   * @returns dependencies\r\n   */\r\n  private getDependencies(node: t.ClassMethod | t.ClassProperty): [string[], t.ArrayExpression | undefined] {\r\n    if (!this.t.isIdentifier(node.key)) return [[], undefined];\r\n    const wrappedNode = this.t.classDeclaration(null, null, this.t.classBody([node]));\r\n    return this.getDependenciesFromNode(wrappedNode, true);\r\n  }\r\n\r\n  private dependencyMapReversed() {\r\n    const reversedMap: Record<string, Set<string>> = {};\r\n    Object.entries(this.dependencyMap).forEach(([key, deps]) => {\r\n      deps.forEach(dep => {\r\n        if (!reversedMap[dep]) reversedMap[dep] = new Set();\r\n        reversedMap[dep].add(key);\r\n      });\r\n    });\r\n\r\n    return reversedMap;\r\n  }\r\n\r\n  private resolveMounting(path: NodePath<t.ClassDeclaration>) {\r\n    const node = path.node;\r\n    if (!this.t.isIdentifier(node.id)) return;\r\n    const decorators = node.decorators ?? [];\r\n    const findEntry = (name: string) => {\r\n      const found = decorators.find(deco => this.t.isIdentifier(deco.expression, { name }));\r\n      if (found)\r\n        decorators.splice(\r\n          decorators.findIndex(deco => deco === found),\r\n          1\r\n        );\r\n      return found;\r\n    };\r\n\r\n    // ---- Find \"@Main\" for mounting \"main\", \"@App\" for mounting \"app\"\r\n    const entryValue = findEntry('Main') ? 'main' : findEntry('App') ? 'app' : null;\r\n    let mountNode: t.Expression;\r\n    if (entryValue) {\r\n      mountNode = this.t.stringLiteral(entryValue);\r\n    } else {\r\n      // ---- Find \"@Mount(\"any-id\")\"\r\n      const mounting = decorators.find(\r\n        deco =>\r\n          this.t.isCallExpression(deco.expression) &&\r\n          this.t.isIdentifier(deco.expression.callee, { name: 'Mount' }) &&\r\n          deco.expression.arguments.length === 1\r\n      ) as t.Decorator;\r\n      if (!mounting) return;\r\n      decorators.splice(\r\n        decorators.findIndex(deco => deco === mounting),\r\n        1\r\n      );\r\n      mountNode = (mounting.expression as t.CallExpression).arguments[0] as t.Expression;\r\n    }\r\n\r\n    // ---- ${importMap.render}(\"main\", ${node.id})\r\n    const parentNode = path.parentPath.node;\r\n    if (!this.t.isBlockStatement(parentNode) && !this.t.isProgram(parentNode)) return;\r\n    const idx = parentNode.body.indexOf(node);\r\n    parentNode.body.splice(\r\n      idx + 1,\r\n      0,\r\n      this.t.expressionStatement(\r\n        this.t.callExpression(this.t.identifier(importMap.render), [mountNode, node.id as t.Identifier])\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @brief Transform arrow function property to method\r\n   * @param propertyNode\r\n   * @returns new method node\r\n   */\r\n  arrowFunctionPropertyToMethod(propertyNode: t.ClassProperty): t.ClassMethod | undefined {\r\n    if (!this.t.isArrowFunctionExpression(propertyNode.value)) return;\r\n    const value = propertyNode.value;\r\n    if (!this.t.isBlockStatement(value.body)) return;\r\n    // ---- Remove property\r\n    const propertyIdx = this.classBodyNode!.body.indexOf(propertyNode);\r\n    // ---- Add method\r\n    const methodNode = this.t.classMethod('method', propertyNode.key, value.params, value.body);\r\n    this.classBodyNode!.body.splice(propertyIdx, 1, methodNode);\r\n\r\n    return methodNode;\r\n  }\r\n\r\n  /**\r\n   * @brief Check if a member expression is a property of a member expression\r\n   * @param parentNode\r\n   * @param currentNode\r\n   * @returns is a property of a member expression\r\n   */\r\n  isMemberExpressionProperty(parentNode: t.Node, currentNode: t.Node): boolean {\r\n    return this.t.isMemberExpression(parentNode) && !parentNode.computed && parentNode.property === currentNode;\r\n  }\r\n\r\n  /**\r\n   * @brief Check if a member expression is a key of an object\r\n   * @param parentNode\r\n   * @param currentNode\r\n   * @returns is a key of an object\r\n   */\r\n  isObjectKey(parentNode: t.Node, currentNode: t.Node): boolean {\r\n    return this.t.isObjectProperty(parentNode) && parentNode.key === currentNode;\r\n  }\r\n\r\n  /**\r\n   * @brief Add arrow function to property value\r\n   * @param node\r\n   */\r\n  valueWithArrowFunc(node: t.ClassProperty): void {\r\n    if (!node.value) {\r\n      node.value = this.t.identifier('undefined');\r\n    }\r\n    node.value = this.t.arrowFunctionExpression([], node.value);\r\n  }\r\n\r\n  /**\r\n   * @brief Get all top level return statements in a block statement,\r\n   *  ignore nested function returns\r\n   * @param node\r\n   * @returns\r\n   */\r\n  getAllTopLevelReturnBlock(node: t.BlockStatement): t.BlockStatement[] {\r\n    const returns: t.BlockStatement[] = [];\r\n\r\n    let inNestedFunction = false;\r\n    this.traverse(this.valueWrapper(node), {\r\n      Function: path => {\r\n        if (inNestedFunction) return;\r\n        inNestedFunction = true;\r\n        path.skip();\r\n      },\r\n      ReturnStatement: path => {\r\n        if (inNestedFunction) return;\r\n        const parentNode = path.parentPath.node;\r\n        if (!this.t.isBlockStatement(parentNode)) {\r\n          const newNode = this.t.blockStatement([path.node]);\r\n          path.replaceWith(newNode);\r\n          returns.push(newNode);\r\n        } else {\r\n          returns.push(parentNode);\r\n        }\r\n        path.skip();\r\n      },\r\n      exit: path => {\r\n        if (this.t.isFunction(path.node)) inNestedFunction = false;\r\n      },\r\n    });\r\n\r\n    return returns;\r\n  }\r\n\r\n  /**\r\n   * @brief Wrap the value in a file\r\n   * @param node\r\n   * @returns wrapped value\r\n   */\r\n  private valueWrapper(node: t.Expression | t.Statement): t.File {\r\n    return this.t.file(this.t.program([this.t.isStatement(node) ? node : this.t.expressionStatement(node)]));\r\n  }\r\n\r\n  /**\r\n   * @brief check if the identifier is from a function param till the stopNode\r\n   *  e.g:\r\n   *  function myFunc1(ok) { // stopNode = functionBody\r\n   *     const myFunc2 = ok => ok // from function param\r\n   *     console.log(ok) // not from function param\r\n   *  }\r\n   * @param path\r\n   * @param idName\r\n   */\r\n  private isAttrFromFunction(path: NodePath, idName: string) {\r\n    let reversePath = path.parentPath;\r\n\r\n    const checkParam: (param: t.Node) => boolean = (param: t.Node) => {\r\n      // ---- 3 general types:\r\n      //      * represent allow nesting\r\n      // ---0 Identifier: (a)\r\n      // ---1 RestElement: (...a)   *\r\n      // ---1 Pattern: 3 sub Pattern\r\n      // -----0   AssignmentPattern: (a=1)   *\r\n      // -----1   ArrayPattern: ([a, b])   *\r\n      // -----2   ObjectPattern: ({a, b})\r\n      if (this.t.isIdentifier(param)) return param.name === idName;\r\n      if (this.t.isAssignmentPattern(param)) return checkParam(param.left);\r\n      if (this.t.isArrayPattern(param)) {\r\n        return param.elements\r\n          .filter(Boolean)\r\n          .map(el => checkParam(el!))\r\n          .includes(true);\r\n      }\r\n      if (this.t.isObjectPattern(param)) {\r\n        return (\r\n          param.properties.filter(\r\n            prop => this.t.isObjectProperty(prop) && this.t.isIdentifier(prop.key)\r\n          ) as t.ObjectProperty[]\r\n        )\r\n          .map(prop => (prop.key as t.Identifier).name)\r\n          .includes(idName);\r\n      }\r\n      if (this.t.isRestElement(param)) return checkParam(param.argument);\r\n\r\n      return false;\r\n    };\r\n\r\n    while (reversePath) {\r\n      const node = reversePath.node;\r\n      if (this.t.isArrowFunctionExpression(node) || this.t.isFunctionDeclaration(node)) {\r\n        for (const param of node.params) {\r\n          if (checkParam(param)) return true;\r\n        }\r\n      }\r\n      reversePath = reversePath.parentPath;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @brief Check if an identifier is a simple identifier, i.e., not a member expression, or a function param\r\n   * @param path\r\n   *  1. not a member expression\r\n   *  2. not a function param\r\n   *  3. not in a declaration\r\n   *  4. not as object property's not computed key\r\n   */\r\n  private isStandAloneIdentifier(path: NodePath<t.Identifier>) {\r\n    const node = path.node;\r\n    const parentNode = path.parentPath?.node;\r\n    const isMemberExpression = this.t.isMemberExpression(parentNode) && parentNode.property === node;\r\n    if (isMemberExpression) return false;\r\n    const isFunctionParam = this.isAttrFromFunction(path, node.name);\r\n    if (isFunctionParam) return false;\r\n    while (path.parentPath) {\r\n      if (this.t.isVariableDeclarator(path.parentPath.node)) return false;\r\n      if (\r\n        this.t.isObjectProperty(path.parentPath.node) &&\r\n        path.parentPath.node.key === path.node &&\r\n        !path.parentPath.node.computed\r\n      )\r\n        return false;\r\n      path = path.parentPath as any;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @brief Get all identifiers as strings in a node\r\n   * @param node\r\n   * @returns identifiers\r\n   */\r\n  private getIdentifiers(node: t.Node): string[] {\r\n    if (this.t.isIdentifier(node)) return [node.name];\r\n    const identifierKeys = new Set<string>();\r\n    this.traverse(this.valueWrapper(node as any), {\r\n      Identifier: innerPath => {\r\n        if (!this.isStandAloneIdentifier(innerPath)) return;\r\n        identifierKeys.add(innerPath.node.name);\r\n      },\r\n    });\r\n    return [...identifierKeys];\r\n  }\r\n\r\n  static escapeNamings = ['escape', '$'];\r\n\r\n  /**\r\n   * @brief Check if it's the left side of an assignment expression, e.g. this.count = 1\r\n   * @param innerPath\r\n   * @returns assignment expression\r\n   */\r\n  isAssignmentExpressionLeft(innerPath: NodePath): NodePath | null {\r\n    let parentPath = innerPath.parentPath;\r\n    while (parentPath && !this.t.isStatement(parentPath.node)) {\r\n      if (this.t.isAssignmentExpression(parentPath.node)) {\r\n        if (parentPath.node.left === innerPath.node) return parentPath;\r\n        const leftPath = parentPath.get('left') as NodePath;\r\n        if (innerPath.isDescendant(leftPath)) return parentPath;\r\n      } else if (this.t.isUpdateExpression(parentPath.node)) {\r\n        return parentPath;\r\n      }\r\n      parentPath = parentPath.parentPath;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @brief Check if it's a reactivity function, e.g. arr.push\r\n   * @param innerPath\r\n   * @returns\r\n   */\r\n  isAssignmentFunction(innerPath: NodePath): boolean {\r\n    let parentPath = innerPath.parentPath;\r\n\r\n    while (parentPath && this.t.isMemberExpression(parentPath.node)) {\r\n      parentPath = parentPath.parentPath;\r\n    }\r\n    if (!parentPath) return false;\r\n    return (\r\n      this.t.isCallExpression(parentPath.node) &&\r\n      this.t.isMemberExpression(parentPath.node.callee) &&\r\n      this.t.isIdentifier(parentPath.node.callee.property) &&\r\n      reactivityFuncNames.includes(parentPath.node.callee.property.name)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @brief Check if it's in an \"escape\" function,\r\n   *        e.g. escape(() => { console.log(this.count) })\r\n   *              deps will be empty instead of [\"count\"]\r\n   * @param innerPath\r\n   * @param classDeclarationNode\r\n   * @returns is in escape function\r\n   */\r\n  isMemberInEscapeFunction(innerPath: NodePath, stopNode: t.Node): boolean {\r\n    let isInFunction = false;\r\n    let reversePath = innerPath.parentPath;\r\n    while (reversePath && reversePath.node !== stopNode) {\r\n      const node = reversePath.node;\r\n      if (\r\n        this.t.isCallExpression(node) &&\r\n        this.t.isIdentifier(node.callee) &&\r\n        PluginProvider.escapeNamings.includes(node.callee.name)\r\n      ) {\r\n        isInFunction = true;\r\n        break;\r\n      }\r\n      reversePath = reversePath.parentPath;\r\n    }\r\n    return isInFunction;\r\n  }\r\n\r\n  /**\r\n   * @brief Check if it's in a \"manual\" function,\r\n   *        e.g. manual(() => { console.log(this.count) }, [\"flag\"])\r\n   *             deps will be [\"flag\"] instead of [\"count\"]\r\n   * @param innerPath\r\n   * @param classDeclarationNode\r\n   * @returns is in manual function\r\n   */\r\n  isMemberInManualFunction(innerPath: NodePath, stopNode: t.Node): boolean {\r\n    let isInFunction = false;\r\n    let reversePath = innerPath.parentPath;\r\n    while (reversePath && reversePath.node !== stopNode) {\r\n      const node = reversePath.node;\r\n      const parentNode = reversePath.parentPath?.node;\r\n      const isFunction = this.t.isFunctionExpression(node) || this.t.isArrowFunctionExpression(node);\r\n      const isManual =\r\n        this.t.isCallExpression(parentNode) &&\r\n        this.t.isIdentifier(parentNode.callee) &&\r\n        parentNode.callee.name === 'manual';\r\n      if (isFunction && isManual) {\r\n        isInFunction = true;\r\n        break;\r\n      }\r\n      reversePath = reversePath.parentPath;\r\n    }\r\n\r\n    return isInFunction;\r\n  }\r\n\r\n  /**\r\n   * @brief Generate a random string\r\n   * @param length\r\n   * @returns random string\r\n   */\r\n  private static uid(length = 4): string {\r\n    return Math.random()\r\n      .toString(32)\r\n      .slice(2, length + 2);\r\n  }\r\n}\r\n\r\n/**\r\n * @brief Change the PluginProvider class for class inheritance\r\n */\r\nexport let PluginProviderClass = PluginProvider;\r\nexport function changePluginProviderClass(cls: typeof PluginProvider) {\r\n  PluginProviderClass = cls;\r\n}\r\n","export const devMode = process.env.NODE_ENV === 'development';\r\n\r\nexport const alterAttributeMap = {\r\n  class: 'className',\r\n  for: 'htmlFor',\r\n};\r\n\r\nexport const reactivityFuncNames = [\r\n  // ---- Array\r\n  'push',\r\n  'pop',\r\n  'shift',\r\n  'unshift',\r\n  'splice',\r\n  'sort',\r\n  'reverse',\r\n  // ---- Set\r\n  'add',\r\n  'delete',\r\n  'clear',\r\n  // ---- Map\r\n  'set',\r\n  'delete',\r\n  'clear',\r\n];\r\n\r\nexport const defaultHTMLTags = [\r\n  'a',\r\n  'abbr',\r\n  'address',\r\n  'area',\r\n  'article',\r\n  'aside',\r\n  'audio',\r\n  'b',\r\n  'base',\r\n  'bdi',\r\n  'bdo',\r\n  'blockquote',\r\n  'body',\r\n  'br',\r\n  'button',\r\n  'canvas',\r\n  'caption',\r\n  'cite',\r\n  'code',\r\n  'col',\r\n  'colgroup',\r\n  'data',\r\n  'datalist',\r\n  'dd',\r\n  'del',\r\n  'details',\r\n  'dfn',\r\n  'dialog',\r\n  'div',\r\n  'dl',\r\n  'dt',\r\n  'em',\r\n  'embed',\r\n  'fieldset',\r\n  'figcaption',\r\n  'figure',\r\n  'footer',\r\n  'form',\r\n  'h1',\r\n  'h2',\r\n  'h3',\r\n  'h4',\r\n  'h5',\r\n  'h6',\r\n  'head',\r\n  'header',\r\n  'hgroup',\r\n  'hr',\r\n  'html',\r\n  'i',\r\n  'iframe',\r\n  'img',\r\n  'input',\r\n  'ins',\r\n  'kbd',\r\n  'label',\r\n  'legend',\r\n  'li',\r\n  'link',\r\n  'main',\r\n  'map',\r\n  'mark',\r\n  'menu',\r\n  'meta',\r\n  'meter',\r\n  'nav',\r\n  'noscript',\r\n  'object',\r\n  'ol',\r\n  'optgroup',\r\n  'option',\r\n  'output',\r\n  'p',\r\n  'picture',\r\n  'pre',\r\n  'progress',\r\n  'q',\r\n  'rp',\r\n  'rt',\r\n  'ruby',\r\n  's',\r\n  'samp',\r\n  'script',\r\n  'section',\r\n  'select',\r\n  'slot',\r\n  'small',\r\n  'source',\r\n  'span',\r\n  'strong',\r\n  'style',\r\n  'sub',\r\n  'summary',\r\n  'sup',\r\n  'table',\r\n  'tbody',\r\n  'td',\r\n  'template',\r\n  'textarea',\r\n  'tfoot',\r\n  'th',\r\n  'thead',\r\n  'time',\r\n  'title',\r\n  'tr',\r\n  'track',\r\n  'u',\r\n  'ul',\r\n  'var',\r\n  'video',\r\n  'wbr',\r\n  'acronym',\r\n  'applet',\r\n  'basefont',\r\n  'bgsound',\r\n  'big',\r\n  'blink',\r\n  'center',\r\n  'dir',\r\n  'font',\r\n  'frame',\r\n  'frameset',\r\n  'isindex',\r\n  'keygen',\r\n  'listing',\r\n  'marquee',\r\n  'menuitem',\r\n  'multicol',\r\n  'nextid',\r\n  'nobr',\r\n  'noembed',\r\n  'noframes',\r\n  'param',\r\n  'plaintext',\r\n  'rb',\r\n  'rtc',\r\n  'spacer',\r\n  'strike',\r\n  'tt',\r\n  'xmp',\r\n  'animate',\r\n  'animateMotion',\r\n  'animateTransform',\r\n  'circle',\r\n  'clipPath',\r\n  'defs',\r\n  'desc',\r\n  'ellipse',\r\n  'feBlend',\r\n  'feColorMatrix',\r\n  'feComponentTransfer',\r\n  'feComposite',\r\n  'feConvolveMatrix',\r\n  'feDiffuseLighting',\r\n  'feDisplacementMap',\r\n  'feDistantLight',\r\n  'feDropShadow',\r\n  'feFlood',\r\n  'feFuncA',\r\n  'feFuncB',\r\n  'feFuncG',\r\n  'feFuncR',\r\n  'feGaussianBlur',\r\n  'feImage',\r\n  'feMerge',\r\n  'feMergeNode',\r\n  'feMorphology',\r\n  'feOffset',\r\n  'fePointLight',\r\n  'feSpecularLighting',\r\n  'feSpotLight',\r\n  'feTile',\r\n  'feTurbulence',\r\n  'filter',\r\n  'foreignObject',\r\n  'g',\r\n  'image',\r\n  'line',\r\n  'linearGradient',\r\n  'marker',\r\n  'mask',\r\n  'metadata',\r\n  'mpath',\r\n  'path',\r\n  'pattern',\r\n  'polygon',\r\n  'polyline',\r\n  'radialGradient',\r\n  'rect',\r\n  'set',\r\n  'stop',\r\n  'svg',\r\n  'switch',\r\n  'symbol',\r\n  'text',\r\n  'textPath',\r\n  'tspan',\r\n  'use',\r\n  'view',\r\n];\r\n\r\nexport const availableDecoNames = ['Static', 'Prop', 'Env', 'Content', 'Children'];\r\nexport const dlightDefaultPackageName = '@inula/next';\r\n\r\nexport const importMap = Object.fromEntries(\r\n  [\r\n    'createElement',\r\n    'setStyle',\r\n    'setDataset',\r\n    'setEvent',\r\n    'delegateEvent',\r\n    'setHTMLProp',\r\n    'setHTMLAttr',\r\n    'setHTMLProps',\r\n    'setHTMLAttrs',\r\n    'createTextNode',\r\n    'updateText',\r\n    'insertNode',\r\n    'ForNode',\r\n    'CondNode',\r\n    'ExpNode',\r\n    'EnvNode',\r\n    'TryNode',\r\n    'SnippetNode',\r\n    'PropView',\r\n    'render',\r\n  ].map(name => [name, `$$${name}`])\r\n);\r\n\r\nexport const importsToDelete = [\r\n  'Static',\r\n  'Children',\r\n  'Content',\r\n  'Prop',\r\n  'Env',\r\n  'Watch',\r\n  'ForwardProps',\r\n  'Main',\r\n  'App',\r\n  'Mount',\r\n  '_',\r\n  'env',\r\n  'Snippet',\r\n  ...defaultHTMLTags.filter(tag => tag !== 'use'),\r\n];\r\n\r\n/**\r\n * @brief HTML internal attribute map, can be accessed as js property\r\n */\r\nexport const defaultAttributeMap = {\r\n  // ---- Other property as attribute\r\n  textContent: ['*'],\r\n  innerHTML: ['*'],\r\n  // ---- Source: https://developer.mozilla.org/zh-CN/docs/Web/HTML/Attributes\r\n  accept: ['form', 'input'],\r\n  // ---- Original: accept-charset\r\n  acceptCharset: ['form'],\r\n  accesskey: ['*'],\r\n  action: ['form'],\r\n  align: ['caption', 'col', 'colgroup', 'hr', 'iframe', 'img', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'tr'],\r\n  allow: ['iframe'],\r\n  alt: ['area', 'img', 'input'],\r\n  async: ['script'],\r\n  autocapitalize: ['*'],\r\n  autocomplete: ['form', 'input', 'select', 'textarea'],\r\n  autofocus: ['button', 'input', 'select', 'textarea'],\r\n  autoplay: ['audio', 'video'],\r\n  background: ['body', 'table', 'td', 'th'],\r\n  // ---- Original: base\r\n  bgColor: ['body', 'col', 'colgroup', 'marquee', 'table', 'tbody', 'tfoot', 'td', 'th', 'tr'],\r\n  border: ['img', 'object', 'table'],\r\n  buffered: ['audio', 'video'],\r\n  capture: ['input'],\r\n  charset: ['meta'],\r\n  checked: ['input'],\r\n  cite: ['blockquote', 'del', 'ins', 'q'],\r\n  className: ['*'],\r\n  color: ['font', 'hr'],\r\n  cols: ['textarea'],\r\n  // ---- Original: colspan\r\n  colSpan: ['td', 'th'],\r\n  content: ['meta'],\r\n  // ---- Original: contenteditable\r\n  contentEditable: ['*'],\r\n  contextmenu: ['*'],\r\n  controls: ['audio', 'video'],\r\n  coords: ['area'],\r\n  crossOrigin: ['audio', 'img', 'link', 'script', 'video'],\r\n  csp: ['iframe'],\r\n  data: ['object'],\r\n  // ---- Original: datetime\r\n  dateTime: ['del', 'ins', 'time'],\r\n  decoding: ['img'],\r\n  default: ['track'],\r\n  defer: ['script'],\r\n  dir: ['*'],\r\n  dirname: ['input', 'textarea'],\r\n  disabled: ['button', 'fieldset', 'input', 'optgroup', 'option', 'select', 'textarea'],\r\n  download: ['a', 'area'],\r\n  draggable: ['*'],\r\n  enctype: ['form'],\r\n  // ---- Original: enterkeyhint\r\n  enterKeyHint: ['textarea', 'contenteditable'],\r\n  htmlFor: ['label', 'output'],\r\n  form: ['button', 'fieldset', 'input', 'label', 'meter', 'object', 'output', 'progress', 'select', 'textarea'],\r\n  // ---- Original: formaction\r\n  formAction: ['input', 'button'],\r\n  // ---- Original: formenctype\r\n  formEnctype: ['button', 'input'],\r\n  // ---- Original: formmethod\r\n  formMethod: ['button', 'input'],\r\n  // ---- Original: formnovalidate\r\n  formNoValidate: ['button', 'input'],\r\n  // ---- Original: formtarget\r\n  formTarget: ['button', 'input'],\r\n  headers: ['td', 'th'],\r\n  height: ['canvas', 'embed', 'iframe', 'img', 'input', 'object', 'video'],\r\n  hidden: ['*'],\r\n  high: ['meter'],\r\n  href: ['a', 'area', 'base', 'link'],\r\n  hreflang: ['a', 'link'],\r\n  // ---- Original: http-equiv\r\n  httpEquiv: ['meta'],\r\n  id: ['*'],\r\n  integrity: ['link', 'script'],\r\n  // ---- Original: intrinsicsize\r\n  intrinsicSize: ['img'],\r\n  // ---- Original: inputmode\r\n  inputMode: ['textarea', 'contenteditable'],\r\n  ismap: ['img'],\r\n  // ---- Original: itemprop\r\n  itemProp: ['*'],\r\n  kind: ['track'],\r\n  label: ['optgroup', 'option', 'track'],\r\n  lang: ['*'],\r\n  language: ['script'],\r\n  loading: ['img', 'iframe'],\r\n  list: ['input'],\r\n  loop: ['audio', 'marquee', 'video'],\r\n  low: ['meter'],\r\n  manifest: ['html'],\r\n  max: ['input', 'meter', 'progress'],\r\n  // ---- Original: maxlength\r\n  maxLength: ['input', 'textarea'],\r\n  // ---- Original: minlength\r\n  minLength: ['input', 'textarea'],\r\n  media: ['a', 'area', 'link', 'source', 'style'],\r\n  method: ['form'],\r\n  min: ['input', 'meter'],\r\n  multiple: ['input', 'select'],\r\n  muted: ['audio', 'video'],\r\n  name: [\r\n    'button',\r\n    'form',\r\n    'fieldset',\r\n    'iframe',\r\n    'input',\r\n    'object',\r\n    'output',\r\n    'select',\r\n    'textarea',\r\n    'map',\r\n    'meta',\r\n    'param',\r\n  ],\r\n  // ---- Original: novalidate\r\n  noValidate: ['form'],\r\n  open: ['details', 'dialog'],\r\n  optimum: ['meter'],\r\n  pattern: ['input'],\r\n  ping: ['a', 'area'],\r\n  placeholder: ['input', 'textarea'],\r\n  // ---- Original: playsinline\r\n  playsInline: ['video'],\r\n  poster: ['video'],\r\n  preload: ['audio', 'video'],\r\n  readonly: ['input', 'textarea'],\r\n  // ---- Original: referrerpolicy\r\n  referrerPolicy: ['a', 'area', 'iframe', 'img', 'link', 'script'],\r\n  rel: ['a', 'area', 'link'],\r\n  required: ['input', 'select', 'textarea'],\r\n  reversed: ['ol'],\r\n  role: ['*'],\r\n  rows: ['textarea'],\r\n  // ---- Original: rowspan\r\n  rowSpan: ['td', 'th'],\r\n  sandbox: ['iframe'],\r\n  scope: ['th'],\r\n  scoped: ['style'],\r\n  selected: ['option'],\r\n  shape: ['a', 'area'],\r\n  size: ['input', 'select'],\r\n  sizes: ['link', 'img', 'source'],\r\n  slot: ['*'],\r\n  span: ['col', 'colgroup'],\r\n  spellcheck: ['*'],\r\n  src: ['audio', 'embed', 'iframe', 'img', 'input', 'script', 'source', 'track', 'video'],\r\n  srcdoc: ['iframe'],\r\n  srclang: ['track'],\r\n  srcset: ['img', 'source'],\r\n  start: ['ol'],\r\n  step: ['input'],\r\n  style: ['*'],\r\n  summary: ['table'],\r\n  // ---- Original: tabindex\r\n  tabIndex: ['*'],\r\n  target: ['a', 'area', 'base', 'form'],\r\n  title: ['*'],\r\n  translate: ['*'],\r\n  type: ['button', 'input', 'embed', 'object', 'ol', 'script', 'source', 'style', 'menu', 'link'],\r\n  usemap: ['img', 'input', 'object'],\r\n  value: ['button', 'data', 'input', 'li', 'meter', 'option', 'progress', 'param', 'text' /** extra for TextNode */],\r\n  width: ['canvas', 'embed', 'iframe', 'img', 'input', 'object', 'video'],\r\n  wrap: ['textarea'],\r\n  // --- ARIA attributes\r\n  //     Source: https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes\r\n  ariaAutocomplete: ['*'],\r\n  ariaChecked: ['*'],\r\n  ariaDisabled: ['*'],\r\n  ariaErrorMessage: ['*'],\r\n  ariaExpanded: ['*'],\r\n  ariaHasPopup: ['*'],\r\n  ariaHidden: ['*'],\r\n  ariaInvalid: ['*'],\r\n  ariaLabel: ['*'],\r\n  ariaLevel: ['*'],\r\n  ariaModal: ['*'],\r\n  ariaMultiline: ['*'],\r\n  ariaMultiSelectable: ['*'],\r\n  ariaOrientation: ['*'],\r\n  ariaPlaceholder: ['*'],\r\n  ariaPressed: ['*'],\r\n  ariaReadonly: ['*'],\r\n  ariaRequired: ['*'],\r\n  ariaSelected: ['*'],\r\n  ariaSort: ['*'],\r\n  ariaValuemax: ['*'],\r\n  ariaValuemin: ['*'],\r\n  ariaValueNow: ['*'],\r\n  ariaValueText: ['*'],\r\n  ariaBusy: ['*'],\r\n  ariaLive: ['*'],\r\n  ariaRelevant: ['*'],\r\n  ariaAtomic: ['*'],\r\n  ariaDropEffect: ['*'],\r\n  ariaGrabbed: ['*'],\r\n  ariaActiveDescendant: ['*'],\r\n  ariaColCount: ['*'],\r\n  ariaColIndex: ['*'],\r\n  ariaColSpan: ['*'],\r\n  ariaControls: ['*'],\r\n  ariaDescribedBy: ['*'],\r\n  ariaDescription: ['*'],\r\n  ariaDetails: ['*'],\r\n  ariaFlowTo: ['*'],\r\n  ariaLabelledBy: ['*'],\r\n  ariaOwns: ['*'],\r\n  ariaPosInset: ['*'],\r\n  ariaRowCount: ['*'],\r\n  ariaRowIndex: ['*'],\r\n  ariaRowSpan: ['*'],\r\n  ariaSetSize: ['*'],\r\n};\r\n","import type babel from '@babel/core';\r\nimport { type PluginObj } from '@babel/core';\r\nimport { PluginProviderClass } from './pluginProvider';\r\nimport { type DLightOption } from './types';\r\nimport { defaultAttributeMap } from './const';\r\n\r\nexport default function (api: typeof babel, options: DLightOption): PluginObj {\r\n  const { types } = api;\r\n  const {\r\n    files = '**/*.{js,ts,jsx,tsx}',\r\n    excludeFiles = '**/{dist,node_modules,lib}/*',\r\n    enableDevTools = false,\r\n    htmlTags = defaultHtmlTags => defaultHtmlTags,\r\n    attributeMap = defaultAttributeMap,\r\n  } = options;\r\n\r\n  const pluginProvider = new PluginProviderClass(\r\n    api,\r\n    types,\r\n    Array.isArray(files) ? files : [files],\r\n    Array.isArray(excludeFiles) ? excludeFiles : [excludeFiles],\r\n    enableDevTools,\r\n    htmlTags,\r\n    attributeMap\r\n  );\r\n\r\n  return {\r\n    visitor: {\r\n      Program: {\r\n        enter(path, { filename }) {\r\n          return pluginProvider.programEnterVisitor(path, filename);\r\n        },\r\n        exit: pluginProvider.programExitVisitor.bind(pluginProvider),\r\n      },\r\n      ClassDeclaration: {\r\n        enter: pluginProvider.classEnter.bind(pluginProvider),\r\n        exit: pluginProvider.classExit.bind(pluginProvider),\r\n      },\r\n      ClassMethod: pluginProvider.classMethodVisitor.bind(pluginProvider),\r\n      ClassProperty: pluginProvider.classPropertyVisitor.bind(pluginProvider),\r\n    },\r\n  };\r\n}\r\n","type DLightErrMap = Record<number, string>;\r\ntype ErrorMethod<T extends DLightErrMap, G extends string> = {\r\n  [K in keyof T as `${G}${K & number}`]: (...args: string[]) => any;\r\n};\r\n\r\n/**\r\n * @brief Create error handler by given error space and error maps\r\n *  e.g.\r\n *  const errHandler = createErrorHandler(\"DLight\", {\r\n *    1: \"Cannot find node type: $0, throw\"\r\n *  }, {\r\n *    1: \"This is an error: $0\"\r\n *  }, {\r\n *    1: \"It's a warning\"\r\n *  })\r\n * errHandler.throw1(\"div\") // -> throw new Error(\":D - DLight[throw1]: Cannot find node type: div, throw\")\r\n * errHandler.error1(\"div\") // -> console.error(\":D - DLight[error1]: This is an error: div\")\r\n * errHandler.warn1() // -> console.warn(\":D - DLight[warn1]: It's a warning\")\r\n * @param errorSpace\r\n * @param throwMap\r\n * @param errorMap\r\n * @param warningMap\r\n * @returns Error handler\r\n */\r\nexport function createErrorHandler<A extends DLightErrMap, B extends DLightErrMap, C extends DLightErrMap>(\r\n  errorSpace: string,\r\n  throwMap: A = {} as any,\r\n  errorMap: B = {} as any,\r\n  warningMap: C = {} as any\r\n) {\r\n  function handleError(map: DLightErrMap, type: string, func: (msg: string) => any) {\r\n    return Object.fromEntries(\r\n      Object.entries(map).map(([code, msg]) => [\r\n        `${type}${code}`,\r\n        (...args: string[]) => {\r\n          args.forEach((arg, i) => {\r\n            msg = msg.replace(`$${i}`, arg);\r\n          });\r\n          return func(`:D - ${errorSpace}[${type}${code}]: ${msg}`);\r\n        },\r\n      ])\r\n    );\r\n  }\r\n  const methods: ErrorMethod<A, 'throw'> & ErrorMethod<B, 'error'> & ErrorMethod<C, 'warn'> = {\r\n    ...handleError(throwMap, 'throw', msg => {\r\n      throw new Error(msg);\r\n    }),\r\n    ...handleError(errorMap, 'error', console.error),\r\n    ...handleError(warningMap, 'warn', console.warn),\r\n  } as any;\r\n\r\n  function notDescribed(type: string) {\r\n    return () => `:D ${errorSpace}: ${type} not described`;\r\n  }\r\n\r\n  return {\r\n    ...methods,\r\n    throwUnknown: notDescribed('throw'),\r\n    errorUnknown: notDescribed('error'),\r\n    warnUnknown: notDescribed('warn'),\r\n  };\r\n}\r\n","import { createErrorHandler } from '@inula/error-handler';\r\n\r\nexport const DLError = createErrorHandler(\r\n  'ViewParser',\r\n  {\r\n    1: \"Invalid syntax in DLight's View, only accepts dot chain call expression\",\r\n    2: 'First argument of $0() must be an expression',\r\n    3: \"Invalid syntax in DLight's View, only accepts expression as props\",\r\n    4: 'Invalid Snippet calling, only accepts static snippet calling like `this.Snippet()`',\r\n  },\r\n  {\r\n    1: 'DLight only accepts ForOfStatement as for loop, skipping this statement',\r\n    2: 'EnvUnit must have at least one child, skipping this statement',\r\n    3: 'Only Env/Comp/HTMLUnit can have a statement block as its children, skipping this statement',\r\n    4: 'If you want to use a key in a for loop, make the first statement as a label statement like `key: item`, skipping this key for now',\r\n    5: 'ForUnit must have at least one child, skipping this statement',\r\n    For: 'ForUnit must have at least one child, skipping this statement',\r\n  },\r\n  {\r\n    1: 'EnvUnit must have at least one prop, skipping this statement and flattening its children',\r\n  }\r\n);\r\n","import { type types as t, type traverse as tr } from '@babel/core';\r\nimport { type ViewProp, type IfBranch, type ViewUnit, type ViewParserConfig, SwitchBranch } from './types';\r\nimport { DLError } from './error';\r\n\r\nexport class ViewParser {\r\n  private readonly compWrapper: string = 'comp';\r\n  private readonly htmlTagWrapper: string = 'tag';\r\n  private readonly environmentTagName: string = 'env';\r\n  private readonly expressionTagName: string = '_';\r\n\r\n  private readonly config: ViewParserConfig;\r\n\r\n  private readonly t: typeof t;\r\n  private readonly traverse: typeof tr;\r\n  private readonly snippetNames: string[];\r\n  private readonly htmlTags: string[];\r\n\r\n  readonly viewUnits: ViewUnit[] = [];\r\n\r\n  /**\r\n   * @brief Constructor\r\n   * @param statement\r\n   * @param config\r\n   * @param options\r\n   */\r\n  constructor(config: ViewParserConfig) {\r\n    this.config = config;\r\n    this.t = config.babelApi.types;\r\n    this.traverse = config.babelApi.traverse;\r\n    this.snippetNames = config.snippetNames;\r\n    this.htmlTags = config.htmlTags;\r\n  }\r\n\r\n  parse(statement: t.BlockStatement) {\r\n    const statements = [...statement.directives, ...statement.body];\r\n    statements.forEach(this.parseStatement.bind(this));\r\n    // ---- If the view is an empty env, throw an error\r\n    if (this.viewUnits.length === 1 && this.viewUnits[0].type === 'env' && this.viewUnits[0].children.length === 0) {\r\n      DLError.error2();\r\n      return [];\r\n    }\r\n\r\n    return this.viewUnits;\r\n  }\r\n\r\n  /**\r\n   * @brief Parse the statements\r\n   * @returns\r\n   */\r\n  private parseStatement(statement: t.Statement | t.Directive): void {\r\n    if (this.isInvalidExpression(statement)) return;\r\n    if (this.t.isExpressionStatement(statement)) {\r\n      this.parseExpression(statement.expression);\r\n      return;\r\n    }\r\n    if (this.t.isTryStatement(statement)) {\r\n      this.parseTry(statement);\r\n      return;\r\n    }\r\n    if (this.t.isForOfStatement(statement)) {\r\n      this.parseFor(statement);\r\n      return;\r\n    }\r\n    if (this.t.isIfStatement(statement)) {\r\n      this.parseIf(statement);\r\n      return;\r\n    }\r\n    if (this.t.isSwitchStatement(statement)) {\r\n      this.parseSwitch(statement);\r\n      return;\r\n    }\r\n    if (this.t.isDirective(statement)) {\r\n      this.parseText(statement.value);\r\n      return;\r\n    }\r\n    if (this.t.isBlockStatement(statement)) {\r\n      // ---- If the statement is a block statement, treat it as last unit's children\r\n      const lastViewUnit = this.viewUnits[this.viewUnits.length - 1];\r\n      const type = lastViewUnit?.type;\r\n      const childViewUnits = this.parseView(statement);\r\n      if (type === 'html') {\r\n        delete lastViewUnit.props.textContent;\r\n        lastViewUnit.children.push(...childViewUnits);\r\n      } else if (type === 'comp' || type === 'snippet') {\r\n        lastViewUnit.children.push(...childViewUnits);\r\n      } else if (type === 'env') {\r\n        if (childViewUnits.length > 0) {\r\n          lastViewUnit.children.push(...childViewUnits);\r\n        } else {\r\n          this.viewUnits.pop();\r\n          DLError.error2();\r\n        }\r\n      } else {\r\n        DLError.error3();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @brief Parse the expression node\r\n   *  CallExpression -> Tag\r\n   *  StringLiteral/TemplateLiteral -> Text\r\n   *  TaggedTemplateExpression -> Tag + Text / Exp\r\n   * @param expression\r\n   */\r\n  private parseExpression(expression: t.Expression): void {\r\n    if (this.t.isCallExpression(expression)) {\r\n      this.parseTag(expression);\r\n      return;\r\n    }\r\n    if (this.t.isStringLiteral(expression) || this.t.isTemplateLiteral(expression)) {\r\n      this.parseText(expression);\r\n      return;\r\n    }\r\n    if (this.t.isTaggedTemplateExpression(expression)) {\r\n      this.parseTaggedTemplate(expression);\r\n      return;\r\n    }\r\n\r\n    // ---- Default ExpressionTag\r\n    //      e.g. this.count -> _(this.count)\r\n    this.viewUnits.push({\r\n      type: 'exp',\r\n      content: this.parseProp(expression),\r\n      props: {},\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @brief Parse if statement conditions\r\n   * @param node\r\n   * @returns IfBranch[]\r\n   */\r\n  private parseIfBranches(node: t.IfStatement): IfBranch[] {\r\n    const conditions: IfBranch[] = [];\r\n    const condition = node.test;\r\n    const ifBody = this.t.isBlockStatement(node.consequent)\r\n      ? node.consequent\r\n      : this.t.blockStatement([node.consequent]);\r\n    conditions.push({\r\n      condition,\r\n      children: this.parseView(ifBody),\r\n    });\r\n\r\n    // ---- If the alternate is an if statement, parse it recursively\r\n    if (this.t.isIfStatement(node.alternate)) {\r\n      conditions.push(...this.parseIfBranches(node.alternate));\r\n    } else if (node.alternate) {\r\n      const altBody = this.t.isBlockStatement(node.alternate)\r\n        ? node.alternate\r\n        : this.t.blockStatement([node.alternate]);\r\n      conditions.push({\r\n        condition: this.t.booleanLiteral(true),\r\n        children: this.parseView(altBody),\r\n      });\r\n    }\r\n\r\n    return conditions;\r\n  }\r\n\r\n  /**\r\n   * @brief Parse if statement with else if and else\r\n   * @param node\r\n   */\r\n  private parseIf(node: t.IfStatement): void {\r\n    this.viewUnits.push({\r\n      type: 'if',\r\n      branches: this.parseIfBranches(node),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @brief Parse switch statement\r\n   * @param node\r\n   */\r\n  private parseSwitch(node: t.SwitchStatement) {\r\n    const branches: SwitchBranch[] = [];\r\n    const switchBody = node.cases;\r\n    switchBody.forEach(s => {\r\n      const caseBodyPre = s.consequent;\r\n      const caseBody =\r\n        caseBodyPre.length === 1 && this.t.isBlockStatement(caseBodyPre[0])\r\n          ? caseBodyPre[0]\r\n          : this.t.blockStatement(caseBodyPre);\r\n      const isBreak = this.t.isBreakStatement(caseBody.body[caseBody.body.length - 1]);\r\n      if (isBreak) {\r\n        caseBody.body.pop();\r\n      }\r\n\r\n      const children = this.parseView(caseBody);\r\n      const branch: SwitchBranch = {\r\n        case: s.test ?? this.t.booleanLiteral(true),\r\n        children,\r\n        break: isBreak,\r\n      };\r\n      branches.push(branch);\r\n    });\r\n    this.viewUnits.push({\r\n      type: 'switch',\r\n      discriminant: node.discriminant,\r\n      branches,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @brief Parse try statement\r\n   * @param node\r\n   */\r\n  private parseTry(node: t.TryStatement) {\r\n    const tryBody = this.t.blockStatement(node.block.body);\r\n    const catchBodyNode = node.handler?.body ?? this.t.blockStatement([]);\r\n\r\n    this.viewUnits.push({\r\n      type: 'try',\r\n      children: this.parseView(tryBody),\r\n      exception: node.handler?.param ?? null,\r\n      catchChildren: this.parseView(catchBodyNode),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @brief Parse for of loop\r\n   * Only accept for of loop with variable declaration\r\n   *  e.g. for (const item of array) {}\r\n   * Key:\r\n   *  1. If the first statement is an array expression and is not a null or undefined,\r\n   *     treat the first element as the key.\r\n   *     e.g. for (const { idx, item } of array) { [idx]; div(item) }\r\n   *          key will be \"idx\"\r\n   *  2. If the first statement is an array expression and is null or undefined, treat it as a non-keyed loop.\r\n   *      e.g. for (const { item } of array) { [null]; div(item) }\r\n   *          no specific key\r\n   *  3. If the first statement is not an array expression, treat the item itself as the key.\r\n   *      e.g. for (const item of array) { div(item) }\r\n   *          key will be \"item\"\r\n   * @param node\r\n   */\r\n  private parseFor(node: t.ForOfStatement): void {\r\n    const left = node.left;\r\n    if (!this.t.isVariableDeclaration(left)) {\r\n      DLError.throw1();\r\n    }\r\n    const item = (left as t.VariableDeclaration).declarations[0].id;\r\n    const array = node.right;\r\n    let key: t.Expression = this.t.nullLiteral();\r\n    const forBody = node.body;\r\n    let forBodyStatements: Array<t.Statement | t.Directive>;\r\n    if (this.t.isExpressionStatement(forBody)) {\r\n      // ---- If the for body is an expression statement, treat it as the only statement\r\n      forBodyStatements = [forBody];\r\n    } else if (this.t.isBlockStatement(forBody)) {\r\n      const childNodes = forBody.body;\r\n      if (childNodes.length === 0) return DLError.error5();\r\n      const firstStatement = childNodes[0];\r\n      if (this.t.isLabeledStatement(firstStatement) && this.t.isIdentifier(firstStatement.label)) {\r\n        if (firstStatement.label.name !== 'key' || !this.t.isExpressionStatement(firstStatement.body)) {\r\n          DLError.error4();\r\n        } else {\r\n          // ---- Treat the first array element labeled by key as the key\r\n          const keyNode = firstStatement.body.expression;\r\n          // ---- If the key is undefined or null, treat it as no key\r\n          if (\r\n            this.t.isExpression(keyNode) &&\r\n            !(this.t.isNullLiteral(keyNode) || (this.t.isIdentifier(keyNode) && keyNode.name === 'undefined'))\r\n          ) {\r\n            key = keyNode;\r\n          }\r\n        }\r\n        forBodyStatements = childNodes.slice(1);\r\n      } else {\r\n        forBodyStatements = childNodes;\r\n      }\r\n    } else return;\r\n\r\n    const directives = forBodyStatements.filter(s => this.t.isDirective(s)) as t.Directive[];\r\n    const statements = forBodyStatements.filter(s => !this.t.isDirective(s)) as t.Statement[];\r\n    const forBodyBlockStatement = this.t.blockStatement(statements, directives);\r\n    // ---- Parse the for body statements\r\n    this.viewUnits.push({\r\n      type: 'for',\r\n      item,\r\n      array,\r\n      key,\r\n      children: this.parseView(forBodyBlockStatement),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @brief Parse text node\r\n   *  1. `text text`\r\n   *  2. \"text2 text2\"\r\n   * @param node\r\n   */\r\n  private parseText(node: t.StringLiteral | t.TemplateLiteral | t.DirectiveLiteral): void {\r\n    if (this.t.isDirectiveLiteral(node)) node = this.t.stringLiteral(node.value);\r\n\r\n    this.viewUnits.push({\r\n      type: 'text',\r\n      content: node,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @brief Parse tagged template expression\r\n   * Two tagged template expression cases\r\n   *  1. type without call expressions\r\n   *      e.g. i18n`any text`\r\n   *        => exp: _(i18n`any text`)\r\n   *  2. type with string literal / template literal\r\n   *      e.g. \"any text\" `any other text`/ `any text` `any other text`\r\n   *       => text: \"any text\" + text: `any other text`\r\n   * @param node\r\n   * @param path\r\n   */\r\n  private parseTaggedTemplate(node: t.TaggedTemplateExpression): void {\r\n    if (this.t.isStringLiteral(node.tag) || this.t.isTemplateLiteral(node.tag)) {\r\n      // ---- Case 2\r\n      this.viewUnits.push({\r\n        type: 'text',\r\n        content: node.tag,\r\n      });\r\n      this.viewUnits.push({\r\n        type: 'text',\r\n        content: node.quasi,\r\n      });\r\n      return;\r\n    }\r\n    // ---- Case 1\r\n    this.viewUnits.push({\r\n      type: 'exp',\r\n      content: this.parseProp(node),\r\n      props: {},\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @brief Return a block statement if the node is a prop view\r\n   * @param node\r\n   * @returns\r\n   */\r\n  private isPropView(node: t.Node): null | t.BlockStatement {\r\n    if (\r\n      !(\r\n        this.t.isArrowFunctionExpression(node) &&\r\n        (this.t.isIdentifier(node.params[0], { name: 'View' }) ||\r\n          this.t.isIdentifier(node.params[0], { name: '_View' }))\r\n      )\r\n    )\r\n      return null;\r\n\r\n    const body = node.body;\r\n    if (this.t.isBlockStatement(body)) return body;\r\n    return this.t.blockStatement([this.t.expressionStatement(body)]);\r\n  }\r\n\r\n  /**\r\n   * @brief Parse props in the type node\r\n   * @param propNode\r\n   * @returns ViewProp\r\n   */\r\n  private parseProp(propNode: t.Node | undefined): ViewProp {\r\n    if (propNode && !this.t.isExpression(propNode)) DLError.throw3();\r\n    propNode = propNode as t.Expression;\r\n    // ---- If there is no propNode, set the default prop as true\r\n    if (!propNode) {\r\n      return {\r\n        value: this.t.booleanLiteral(true),\r\n        viewPropMap: {},\r\n      };\r\n    }\r\n\r\n    // ---- Collect View => {} nodes as DLProp\r\n    const dlViewPropResult: Record<string, ViewUnit[]> = {};\r\n    this.traverse(this.valueWrapper(propNode), {\r\n      ArrowFunctionExpression: innerPath => {\r\n        const node = this.isPropView(innerPath.node);\r\n        if (!node) return;\r\n        const id = this.uid();\r\n        // ---- Parse the body of View => {} as a new View\r\n        dlViewPropResult[id] = this.parseView(node);\r\n        // ---- Replace the View => {} with a id string literal\r\n        const newNode = this.t.stringLiteral(id);\r\n        if (innerPath.node === propNode) {\r\n          propNode = newNode;\r\n        }\r\n        innerPath.replaceWith(newNode);\r\n        innerPath.skip();\r\n      },\r\n    });\r\n\r\n    return {\r\n      value: propNode,\r\n      viewPropMap: dlViewPropResult,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * @brief Parse the type node\r\n   * @param node\r\n   */\r\n  private parseTag(node: t.CallExpression): void {\r\n    const props: Record<string, ViewProp> = {};\r\n\r\n    // ---- Keep iterating until the node has no call expression\r\n    let n = node;\r\n    while (this.t.isMemberExpression(n?.callee) && n?.callee?.object && !this.isPureMemberExpression(n.callee)) {\r\n      const property = n.callee.property;\r\n      if (!this.t.isIdentifier(property) || !this.t.isCallExpression(n.callee.object)) {\r\n        DLError.throw1();\r\n        continue;\r\n      }\r\n\r\n      const key = property.name;\r\n      const prop = this.parseProp(n.arguments[0]);\r\n      props[key] = prop;\r\n      n = n.callee.object;\r\n    }\r\n\r\n    let contentProp: ViewProp | undefined;\r\n    if (n.arguments.length > 0) {\r\n      // ---- The last argument is the content prop of the type,\r\n      //      so only parse prop when it exists instead of\r\n      //      treating empty prop as \"true\" like other props\r\n      contentProp = this.parseProp(n.arguments[0]);\r\n    }\r\n\r\n    if (this.t.isIdentifier(n.callee)) {\r\n      // ---- Special cases for expression type\r\n      const tagName = n.callee.name;\r\n      if (tagName === this.expressionTagName && contentProp) {\r\n        // ---- Must have content prop or else just ignore it\r\n        this.viewUnits.push({\r\n          type: 'exp',\r\n          content: contentProp,\r\n          props,\r\n        });\r\n        return;\r\n      }\r\n      if (tagName === this.environmentTagName) {\r\n        if (Object.keys(props).length === 0) {\r\n          DLError.warn1();\r\n          return;\r\n        }\r\n        this.viewUnits.push({\r\n          type: 'env',\r\n          props,\r\n          children: [],\r\n        });\r\n        return;\r\n      }\r\n      if (this.htmlTags.includes(tagName)) {\r\n        let children: ViewUnit[] = [];\r\n        if (contentProp) {\r\n          let isViewProp = false;\r\n          if (contentProp.viewPropMap && Object.keys(contentProp.viewPropMap).length === 1) {\r\n            const key = Object.keys(contentProp.viewPropMap)[0];\r\n            if (this.t.isStringLiteral(contentProp.value, { value: key })) {\r\n              isViewProp = true;\r\n              const viewUnit = contentProp.viewPropMap[key];\r\n              children = viewUnit;\r\n            }\r\n          }\r\n          if (!isViewProp) props.textContent = contentProp;\r\n        }\r\n        this.viewUnits.push({\r\n          type: 'html',\r\n          tag: this.t.stringLiteral(tagName),\r\n          props,\r\n          children,\r\n        });\r\n        return;\r\n      }\r\n      // ---- Custom tag\r\n      if (contentProp) props._$content = contentProp;\r\n      this.viewUnits.push({\r\n        type: 'comp',\r\n        tag: n.callee,\r\n        props,\r\n        children: [],\r\n      });\r\n      return;\r\n    }\r\n    if (\r\n      this.t.isMemberExpression(n.callee) &&\r\n      this.t.isThisExpression(n.callee.object) &&\r\n      this.t.isIdentifier(n.callee.property) &&\r\n      this.snippetNames.includes(n.callee.property.name)\r\n    ) {\r\n      // ---- Snippet\r\n      if (contentProp) props.content = contentProp;\r\n      if (\r\n        !(\r\n          this.t.isMemberExpression(n.callee) &&\r\n          this.t.isThisExpression(n.callee.object) &&\r\n          this.t.isIdentifier(n.callee.property)\r\n        )\r\n      )\r\n        return DLError.throw4();\r\n      this.viewUnits.push({\r\n        type: 'snippet',\r\n        tag: n.callee.property.name,\r\n        props,\r\n        children: [],\r\n      });\r\n      return;\r\n    }\r\n    if (this.t.isExpression(n.callee)) {\r\n      // ---- 1. Custom tag\r\n      //      2. htmlTag(xxx)\r\n      //      3. tag(xxx)\r\n      const [tagType, tag] = this.alterTagType(n.callee);\r\n      if (contentProp) {\r\n        props[tagType === 'html' ? 'textContent' : '_$content'] = contentProp;\r\n      }\r\n      this.viewUnits.push({\r\n        type: tagType,\r\n        tag,\r\n        props,\r\n        children: [],\r\n      });\r\n    }\r\n  }\r\n\r\n  /* ---- Helper Functions ---- */\r\n  /**\r\n   * @brief Test if the node is a pure member expression without call expression\r\n   * @param node\r\n   */\r\n  private isPureMemberExpression(node: t.Expression): boolean {\r\n    let isPure = true;\r\n    this.traverse(this.valueWrapper(node), {\r\n      CallExpression: () => {\r\n        isPure = false;\r\n      },\r\n    });\r\n    return isPure;\r\n  }\r\n\r\n  /**\r\n   * @brief Alter the tag type by checking the tag name\r\n   * @param viewUnit\r\n   * @returns [\"html\" | \"comp\", t.Expression]\r\n   */\r\n  private alterTagType(tag: t.Expression): ['html' | 'comp', t.Expression] {\r\n    if (this.t.isCallExpression(tag) && this.t.isIdentifier(tag.callee)) {\r\n      const tagName = tag.callee.name;\r\n      const tagType = tagName === this.htmlTagWrapper ? 'html' : tagName === this.compWrapper ? 'comp' : undefined;\r\n      if (tagType) {\r\n        const tagTarget = tag.arguments[0];\r\n        if (!this.t.isExpression(tagTarget)) DLError.throw2(tagName);\r\n        return [tagType, tagTarget as t.Expression];\r\n      }\r\n    }\r\n    return ['comp', tag];\r\n  }\r\n\r\n  /**\r\n   * @brief Test if the expression is invalid\r\n   *  1. For: only accept ForOfStatement\r\n   * @param node\r\n   * @returns is this expression invalid\r\n   */\r\n  private isInvalidExpression(node: t.Statement | t.Directive): boolean {\r\n    const isInvalidForStatement = this.t.isForStatement(node) && !this.t.isForOfStatement(node);\r\n    if (isInvalidForStatement) {\r\n      DLError.error1();\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @brief Wrap the value in a file\r\n   * @param node\r\n   * @returns wrapped value\r\n   */\r\n  private valueWrapper(node: t.Expression): t.File {\r\n    return this.t.file(this.t.program([this.t.expressionStatement(node)]));\r\n  }\r\n\r\n  /**\r\n   * @brief Parse the view by duplicating current parser's classRootPath, statements and htmlTags\r\n   * @param statements\r\n   * @returns ViewUnit[]\r\n   */\r\n  private parseView(statement: t.BlockStatement): ViewUnit[] {\r\n    return new ViewParser(this.config).parse(statement);\r\n  }\r\n\r\n  /**\r\n   * @brief Generate a unique id\r\n   * @returns a unique id\r\n   */\r\n  private uid(): string {\r\n    return Math.random().toString(36).slice(2);\r\n  }\r\n}\r\n","import { ViewParser } from './parser';\nimport { type ViewUnit, type ViewParserConfig } from './types';\nimport { type types as t } from '@babel/core';\n\n/**\n * @brief Generate view units from a babel ast\n * @param statement\n * @param config\n * @param options\n * @returns ViewUnit[]\n */\nexport function parseView(statement: t.BlockStatement, config: ViewParserConfig): ViewUnit[] {\n  return new ViewParser(config).parse(statement);\n}\n\nexport type * from './types';\n","import type { NodePath, types as t, traverse as tr } from '@babel/core';\r\nimport type {\r\n  UnitProp,\r\n  ViewUnit,\r\n  ViewParserConfig,\r\n  AllowedJSXNode,\r\n  HTMLUnit,\r\n  TextUnit,\r\n  MutableUnit,\r\n  TemplateProp,\r\n  Context,\r\n} from './types';\r\n\r\nexport class ViewParser {\r\n  // ---- Namespace and tag name\r\n  private readonly htmlNamespace: string = 'html';\r\n  private readonly htmlTagNamespace: string = 'tag';\r\n  private readonly compTagNamespace: string = 'comp';\r\n  private readonly envTagName: string = 'env';\r\n  private readonly forTagName: string = 'for';\r\n  private readonly ifTagName: string = 'if';\r\n  private readonly elseIfTagName: string = 'else-if';\r\n  private readonly elseTagName: string = 'else';\r\n  private readonly customHTMLProps: string[] = ['ref'];\r\n\r\n  private readonly config: ViewParserConfig;\r\n  private readonly htmlTags: string[];\r\n  private readonly willParseTemplate: boolean;\r\n\r\n  private readonly t: typeof t;\r\n  private readonly traverse: typeof tr;\r\n\r\n  private readonly viewUnits: ViewUnit[] = [];\r\n  private context: Context;\r\n\r\n  /**\r\n   * @brief Constructor\r\n   * @param config\r\n   * @param context\r\n   */\r\n  constructor(config: ViewParserConfig, context: Context = { ifElseStack: [] }) {\r\n    this.config = config;\r\n    this.t = config.babelApi.types;\r\n    this.traverse = config.babelApi.traverse;\r\n    this.htmlTags = config.htmlTags;\r\n    this.willParseTemplate = config.parseTemplate ?? true;\r\n    this.context = context;\r\n  }\r\n\r\n  /**\r\n   * @brief Parse the node into view units\r\n   * @param node\r\n   * @returns ViewUnit[]\r\n   */\r\n  parse(node: AllowedJSXNode): ViewUnit[] {\r\n    if (this.t.isJSXText(node)) this.parseText(node);\r\n    else if (this.t.isJSXExpressionContainer(node)) this.parseExpression(node.expression);\r\n    else if (this.t.isJSXElement(node)) this.parseElement(node);\r\n    else if (this.t.isJSXFragment(node)) {\r\n      node.children.forEach(child => {\r\n        this.parse(child);\r\n      });\r\n    }\r\n\r\n    return this.viewUnits;\r\n  }\r\n\r\n  /**\r\n   * @brief Parse JSXText\r\n   * @param node\r\n   */\r\n  private parseText(node: t.JSXText): void {\r\n    const text = node.value.trim();\r\n    if (!text) return;\r\n    this.viewUnits.push({\r\n      type: 'text',\r\n      content: this.t.stringLiteral(node.value),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @brief Parse JSXExpressionContainer\r\n   * @param node\r\n   */\r\n  private parseExpression(node: t.Expression | t.JSXEmptyExpression): void {\r\n    if (this.t.isJSXEmptyExpression(node)) return;\r\n    if (this.t.isLiteral(node) && !this.t.isTemplateLiteral(node)) {\r\n      // ---- Treat literal as text except template literal\r\n      //      Cuz template literal may have viewProp inside like:\r\n      //      <>{i18n`hello ${<MyView/>}`}</>\r\n      this.viewUnits.push({\r\n        type: 'text',\r\n        content: node,\r\n      });\r\n      return;\r\n    }\r\n    this.viewUnits.push({\r\n      type: 'exp',\r\n      content: this.parseProp(node),\r\n      props: {},\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @brief Parse JSXElement\r\n   * @param node\r\n   */\r\n  private parseElement(node: t.JSXElement): void {\r\n    let type: 'html' | 'comp';\r\n    let tag: t.Expression;\r\n\r\n    // ---- Parse tag and type\r\n    const openingName = node.openingElement.name;\r\n    if (this.t.isJSXIdentifier(openingName)) {\r\n      // ---- Opening name is a JSXIdentifier, e.g., <div>\r\n      const name = openingName.name;\r\n      // ---- Specially parse if and env\r\n      if ([this.ifTagName, this.elseIfTagName, this.elseTagName].includes(name)) return this.parseIf(node);\r\n      if (name === this.envTagName) return this.parseEnv(node);\r\n      if (name === this.forTagName) return this.pareFor(node);\r\n      else if (this.htmlTags.includes(name)) {\r\n        type = 'html';\r\n        tag = this.t.stringLiteral(name);\r\n      } else {\r\n        // ---- If the name is not in htmlTags, treat it as a comp\r\n        type = 'comp';\r\n        tag = this.t.identifier(name);\r\n      }\r\n    } else if (this.t.isJSXMemberExpression(openingName)) {\r\n      // ---- Opening name is a JSXMemberExpression, e.g., <Comp.Div>\r\n      //      Treat it as a comp and set the tag as the opening name\r\n      type = 'comp';\r\n      // ---- Turn JSXMemberExpression into MemberExpression recursively\r\n      const toMemberExpression = (node: t.JSXMemberExpression): t.MemberExpression => {\r\n        if (this.t.isJSXMemberExpression(node.object)) {\r\n          return this.t.memberExpression(toMemberExpression(node.object), this.t.identifier(node.property.name));\r\n        }\r\n        return this.t.memberExpression(this.t.identifier(node.object.name), this.t.identifier(node.property.name));\r\n      };\r\n      tag = toMemberExpression(openingName);\r\n    } else {\r\n      // ---- isJSXNamespacedName\r\n      const namespace = openingName.namespace.name;\r\n      switch (namespace) {\r\n        case this.compTagNamespace:\r\n          // ---- If the namespace is the same as the compTagNamespace, treat it as a comp\r\n          //      and set the tag as an identifier\r\n          //      e.g., <comp:div/> => [\"comp\", div]\r\n          //      this means you've declared a component named \"div\" and force it to be a comp instead an html\r\n          type = 'comp';\r\n          tag = this.t.identifier(openingName.name.name);\r\n          break;\r\n        case this.htmlNamespace:\r\n          // ---- If the namespace is the same as the htmlTagNamespace, treat it as an html\r\n          //      and set the tag as a string literal\r\n          //      e.g., <html:MyWebComponent/> => [\"html\", \"MyWebComponent\"]\r\n          //      the tag will be treated as a string, i.e., <MyWebComponent/>\r\n          type = 'html';\r\n          tag = this.t.stringLiteral(openingName.name.name);\r\n          break;\r\n        case this.htmlTagNamespace:\r\n          // ---- If the namespace is the same as the htmlTagNamespace, treat it as an html\r\n          //      and set the tag as an identifier\r\n          //      e.g., <tag:variable/> => [\"html\", variable]\r\n          //      this unit will be htmlUnit and the html string tag is stored in \"variable\"\r\n          type = 'html';\r\n          tag = this.t.identifier(openingName.name.name);\r\n          break;\r\n        default:\r\n          // ---- Otherwise, treat it as an html tag and make the tag as the namespace:name\r\n          type = 'html';\r\n          tag = this.t.stringLiteral(`${namespace}:${openingName.name.name}`);\r\n          break;\r\n      }\r\n    }\r\n\r\n    // ---- Parse the props\r\n    const props = node.openingElement.attributes;\r\n    const propMap: Record<string, UnitProp> = Object.fromEntries(props.map(prop => this.parseJSXProp(prop)));\r\n\r\n    // ---- Parse the children\r\n    const childUnits = node.children.map(child => this.parseView(child)).flat();\r\n\r\n    let unit: ViewUnit = { type, tag, props: propMap, children: childUnits };\r\n\r\n    if (unit.type === 'html' && childUnits.length === 1 && childUnits[0].type === 'text') {\r\n      // ---- If the html unit only has one text child, merge the text into the html unit\r\n      const text = childUnits[0] as TextUnit;\r\n      unit = {\r\n        ...unit,\r\n        children: [],\r\n        props: {\r\n          ...unit.props,\r\n          textContent: {\r\n            value: text.content,\r\n            viewPropMap: {},\r\n          },\r\n        },\r\n      };\r\n    }\r\n\r\n    if (unit.type === 'html') unit = this.transformTemplate(unit);\r\n\r\n    this.viewUnits.push(unit);\r\n  }\r\n\r\n  /**\r\n   * @brief Parse EnvUnit\r\n   * @param node\r\n   */\r\n  private parseEnv(node: t.JSXElement): void {\r\n    const props = node.openingElement.attributes;\r\n    const propMap: Record<string, UnitProp> = Object.fromEntries(props.map(prop => this.parseJSXProp(prop)));\r\n    const children = node.children.map(child => this.parseView(child)).flat();\r\n    this.viewUnits.push({\r\n      type: 'env',\r\n      props: propMap,\r\n      children,\r\n    });\r\n  }\r\n\r\n  private parseIf(node: t.JSXElement): void {\r\n    const name = (node.openingElement.name as t.JSXIdentifier).name;\r\n    // ---- else\r\n    if (name === this.elseTagName) {\r\n      const lastUnit = this.context.ifElseStack[this.context.ifElseStack.length - 1];\r\n      if (!lastUnit || lastUnit.type !== 'if') throw new Error(`Missing if for ${name}`);\r\n      lastUnit.branches.push({\r\n        condition: this.t.booleanLiteral(true),\r\n        children: node.children.map(child => this.parseView(child)).flat(),\r\n      });\r\n      this.context.ifElseStack.pop();\r\n      return;\r\n    }\r\n\r\n    const condition = node.openingElement.attributes.filter(\r\n      attr => this.t.isJSXAttribute(attr) && attr.name.name === 'cond'\r\n    )[0];\r\n    if (!condition) throw new Error(`Missing condition for ${name}`);\r\n    if (!this.t.isJSXAttribute(condition)) throw new Error(`JSXSpreadAttribute is not supported for ${name} condition`);\r\n    if (!this.t.isJSXExpressionContainer(condition.value) || !this.t.isExpression(condition.value.expression))\r\n      throw new Error(`Invalid condition for ${name}`);\r\n\r\n    // ---- if\r\n    if (name === this.ifTagName) {\r\n      const unit = {\r\n        type: 'if' as const,\r\n        branches: [\r\n          {\r\n            condition: condition.value.expression,\r\n            children: node.children.map(child => this.parseView(child)).flat(),\r\n          },\r\n        ],\r\n      };\r\n      this.viewUnits.push(unit);\r\n      this.context.ifElseStack.push(unit);\r\n      return;\r\n    }\r\n\r\n    // ---- else-if\r\n    const lastUnit = this.context.ifElseStack[this.context.ifElseStack.length - 1];\r\n    if (!lastUnit || lastUnit.type !== 'if') throw new Error(`Missing if for ${name}`);\r\n\r\n    lastUnit.branches.push({\r\n      condition: condition.value.expression,\r\n      children: node.children.map(child => this.parseView(child)).flat(),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @brief Parse JSXAttribute or JSXSpreadAttribute into UnitProp,\r\n   *  considering both namespace and expression\r\n   * @param prop\r\n   * @returns [propName, propValue]\r\n   */\r\n  private parseJSXProp(prop: t.JSXAttribute | t.JSXSpreadAttribute): [string, UnitProp] {\r\n    if (this.t.isJSXAttribute(prop)) {\r\n      let propName: string, specifier: string | undefined;\r\n      if (this.t.isJSXNamespacedName(prop.name)) {\r\n        // ---- If the prop name is a JSXNamespacedName, e.g., bind:value\r\n        //      give it a special tag\r\n        propName = prop.name.name.name;\r\n        specifier = prop.name.namespace.name;\r\n      } else {\r\n        propName = prop.name.name;\r\n      }\r\n      let value = this.t.isJSXExpressionContainer(prop.value) ? prop.value.expression : prop.value;\r\n      if (this.t.isJSXEmptyExpression(value)) value = undefined;\r\n      return [propName, this.parseProp(value, specifier)];\r\n    }\r\n    // ---- Use *spread* as the propName to avoid conflict with other props\r\n    return ['*spread*', this.parseProp(prop.argument)];\r\n  }\r\n\r\n  /**\r\n   * @brief Parse the prop node into UnitProp\r\n   * @param propNode\r\n   * @param specifier\r\n   * @returns UnitProp\r\n   */\r\n  private parseProp(propNode: t.Expression | undefined | null, specifier?: string): UnitProp {\r\n    // ---- If there is no propNode, set the default prop as true\r\n    if (!propNode) {\r\n      return {\r\n        value: this.t.booleanLiteral(true),\r\n        viewPropMap: {},\r\n      };\r\n    }\r\n\r\n    // ---- Collect sub jsx nodes as Prop\r\n    const viewPropMap: Record<string, ViewUnit[]> = {};\r\n    const parseViewProp = (innerPath: NodePath<t.JSXElement | t.JSXFragment>): void => {\r\n      const id = this.uid();\r\n      const node = innerPath.node;\r\n      viewPropMap[id] = this.parseView(node);\r\n      const newNode = this.t.stringLiteral(id);\r\n      if (node === propNode) {\r\n        // ---- If the node is the propNode, replace it with the new node\r\n        propNode = newNode;\r\n      }\r\n      // ---- Replace the node and skip the inner path\r\n      innerPath.replaceWith(newNode);\r\n      innerPath.skip();\r\n    };\r\n\r\n    // ---- Apply the parseViewProp to JSXElement and JSXFragment\r\n    this.traverse(this.wrapWithFile(propNode), {\r\n      JSXElement: parseViewProp,\r\n      JSXFragment: parseViewProp,\r\n    });\r\n\r\n    return {\r\n      value: propNode,\r\n      viewPropMap,\r\n      specifier,\r\n    };\r\n  }\r\n\r\n  transformTemplate(unit: ViewUnit): ViewUnit {\r\n    if (!this.willParseTemplate) return unit;\r\n    if (!this.isHTMLTemplate(unit)) return unit;\r\n    unit = unit as HTMLUnit;\r\n    return {\r\n      type: 'template',\r\n      template: this.generateTemplate(unit),\r\n      mutableUnits: this.generateMutableUnits(unit),\r\n      props: this.parseTemplateProps(unit),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * @brief Generate the entire HTMLUnit\r\n   * @param unit\r\n   * @returns HTMLUnit\r\n   */\r\n  private generateTemplate(unit: HTMLUnit): HTMLUnit {\r\n    const staticProps = Object.fromEntries(\r\n      this.filterTemplateProps(\r\n        // ---- Get all the static props\r\n        Object.entries(unit.props ?? []).filter(\r\n          ([, prop]) =>\r\n            this.isStaticProp(prop) &&\r\n            // ---- Filter out props with false values\r\n            !(this.t.isBooleanLiteral(prop.value) && !prop.value.value)\r\n        )\r\n      )\r\n    );\r\n\r\n    let children: (HTMLUnit | TextUnit)[] = [];\r\n    if (unit.children) {\r\n      children = unit.children\r\n        .map(unit => {\r\n          if (unit.type === 'text') return unit;\r\n          if (unit.type === 'html' && this.t.isStringLiteral(unit.tag)) {\r\n            return this.generateTemplate(unit);\r\n          }\r\n        })\r\n        .filter(Boolean) as (HTMLUnit | TextUnit)[];\r\n    }\r\n    return {\r\n      type: 'html',\r\n      tag: unit.tag,\r\n      props: staticProps,\r\n      children,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * @brief Collect all the mutable nodes in a static HTMLUnit\r\n   *  We use this function to collect mutable nodes' path and props,\r\n   *  so that in the generator, we know which position to insert the mutable nodes\r\n   * @param htmlUnit\r\n   * @returns mutable particles\r\n   */\r\n  private generateMutableUnits(htmlUnit: HTMLUnit): MutableUnit[] {\r\n    const mutableUnits: MutableUnit[] = [];\r\n\r\n    const generateMutableUnit = (unit: HTMLUnit, path: number[] = []) => {\r\n      const maxHtmlIdx = unit.children?.filter(\r\n        child => (child.type === 'html' && this.t.isStringLiteral(child.tag)) || child.type === 'text'\r\n      ).length;\r\n      let htmlIdx = -1;\r\n      // ---- Generate mutable unit for current HTMLUnit\r\n      unit.children?.forEach(child => {\r\n        if (!(child.type === 'html' && this.t.isStringLiteral(child.tag)) && !(child.type === 'text')) {\r\n          const idx = htmlIdx + 1 >= maxHtmlIdx ? -1 : htmlIdx + 1;\r\n          mutableUnits.push({\r\n            path: [...path, idx],\r\n            ...this.transformTemplate(child),\r\n          });\r\n        } else {\r\n          htmlIdx++;\r\n        }\r\n      });\r\n      // ---- Recursively generate mutable units for static HTMLUnit children\r\n      unit.children\r\n        ?.filter(child => child.type === 'html' && this.t.isStringLiteral(child.tag))\r\n        .forEach((child, idx) => {\r\n          generateMutableUnit(child as HTMLUnit, [...path, idx]);\r\n        });\r\n    };\r\n    generateMutableUnit(htmlUnit);\r\n\r\n    return mutableUnits;\r\n  }\r\n\r\n  /**\r\n   * @brief Collect all the props in a static HTMLUnit or its nested HTMLUnit children\r\n   *  Just like the mutable nodes, props are also equipped with path,\r\n   *  so that we know which HTML ChildNode to insert the props\r\n   * @param htmlUnit\r\n   * @returns props\r\n   */\r\n  private parseTemplateProps(htmlUnit: HTMLUnit): TemplateProp[] {\r\n    const templateProps: TemplateProp[] = [];\r\n    const generateVariableProp = (unit: HTMLUnit, path: number[]) => {\r\n      // ---- Generate all non-static(string/number/boolean) props for current HTMLUnit\r\n      //      to be inserted further in the generator\r\n      unit.props &&\r\n        Object.entries(unit.props)\r\n          .filter(([, prop]) => !this.isStaticProp(prop))\r\n          .forEach(([key, prop]) => {\r\n            templateProps.push({\r\n              tag: unit.tag,\r\n              name: (unit.tag as t.StringLiteral).value,\r\n              key,\r\n              path,\r\n              value: prop.value,\r\n            });\r\n          });\r\n      // ---- Recursively generate props for static HTMLUnit children\r\n      unit.children\r\n        ?.filter(child => child.type === 'html' && this.t.isStringLiteral(child.tag))\r\n        .forEach((child, idx) => {\r\n          generateVariableProp(child as HTMLUnit, [...path, idx]);\r\n        });\r\n    };\r\n    generateVariableProp(htmlUnit, []);\r\n\r\n    return templateProps;\r\n  }\r\n\r\n  /**\r\n   * @brief Check if a ViewUnit is a static HTMLUnit that can be parsed into a template\r\n   *  Must satisfy:\r\n   *  1. type is html\r\n   *  2. tag is a string literal, i.e., non-dynamic tag\r\n   *  3. has at least one child that is a static HTMLUnit,\r\n   *     or else just call a createElement function, no need for template clone\r\n   * @param viewUnit\r\n   * @returns is a static HTMLUnit\r\n   */\r\n  private isHTMLTemplate(viewUnit: ViewUnit): boolean {\r\n    return (\r\n      viewUnit.type === 'html' &&\r\n      this.t.isStringLiteral(viewUnit.tag) &&\r\n      !!viewUnit.children?.some(child => child.type === 'html' && this.t.isStringLiteral(child.tag))\r\n    );\r\n  }\r\n\r\n  private isStaticProp(prop: UnitProp): boolean {\r\n    return (\r\n      this.t.isStringLiteral(prop.value) ||\r\n      this.t.isNumericLiteral(prop.value) ||\r\n      this.t.isBooleanLiteral(prop.value) ||\r\n      this.t.isNullLiteral(prop.value)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @brief Filter out some props that are not needed in the template,\r\n   *  these are all special props to be parsed differently in the generator\r\n   * @param props\r\n   * @returns filtered props\r\n   */\r\n  private filterTemplateProps<T>(props: Array<[string, T]>): Array<[string, T]> {\r\n    return (\r\n      props\r\n        // ---- Filter out event listeners\r\n        .filter(([key]) => !key.startsWith('on'))\r\n        // ---- Filter out specific props\r\n        .filter(([key]) => !this.customHTMLProps.includes(key))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @brief Parse the view by duplicating current parser's classRootPath, statements and htmlTags\r\n   * @param statements\r\n   * @returns ViewUnit[]\r\n   */\r\n  private parseView(node: AllowedJSXNode): ViewUnit[] {\r\n    return new ViewParser({ ...this.config, parseTemplate: false }, this.context).parse(node);\r\n  }\r\n\r\n  /**\r\n   * @brief Wrap the value in a file\r\n   * @param node\r\n   * @returns wrapped value\r\n   */\r\n  private wrapWithFile(node: t.Expression): t.File {\r\n    return this.t.file(this.t.program([this.t.expressionStatement(node)]));\r\n  }\r\n\r\n  /**\r\n   * @brief Generate a unique id\r\n   * @returns a unique id\r\n   */\r\n  private uid(): string {\r\n    return Math.random().toString(36).slice(2);\r\n  }\r\n\r\n  private findProp(node: t.JSXElement, name: string) {\r\n    const props = node.openingElement.attributes;\r\n\r\n    return props.find((prop): prop is t.JSXAttribute => this.t.isJSXAttribute(prop) && prop.name.name === name);\r\n  }\r\n\r\n  private pareFor(node: t.JSXElement) {\r\n    // get prop named 'each'\r\n    // get the first prop\r\n    const arrayAttr = this.findProp(node, 'each');\r\n    const keyAttr = this.findProp(node, 'key');\r\n\r\n    if (!arrayAttr) {\r\n      throw new Error('should clarify each prop for if');\r\n    }\r\n    let arr\r\n    if (!arrayAttr.value.type !== 'JSXExpressionContainer') {\r\n      throw new Error('each prop should be an expression');\r\n    }\r\n    arr = arrayAttr.value.expression;\r\n    if(!keyAttr) {\r\n      console.warn('should clarify key prop for for, to improve performance');\r\n    }\r\n    const item = (left as t.VariableDeclaration).declarations[0].id;\r\n    const forBody = node.body;\r\n    let forBodyStatements: Array<t.Statement | t.Directive>;\r\n    if (this.t.isExpressionStatement(forBody)) {\r\n      // ---- If the for body is an expression statement, treat it as the only statement\r\n      forBodyStatements = [forBody];\r\n    } else if (this.t.isBlockStatement(forBody)) {\r\n      const childNodes = forBody.body;\r\n      if (childNodes.length === 0) return DLError.error5();\r\n      const firstStatement = childNodes[0];\r\n      if (this.t.isLabeledStatement(firstStatement) && this.t.isIdentifier(firstStatement.label)) {\r\n        if (firstStatement.label.name !== 'key' || !this.t.isExpressionStatement(firstStatement.body)) {\r\n          DLError.error4();\r\n        } else {\r\n          // ---- Treat the first array element labeled by key as the key\r\n          const keyNode = firstStatement.body.expression;\r\n          // ---- If the key is undefined or null, treat it as no key\r\n          if (\r\n            this.t.isExpression(keyNode) &&\r\n            !(this.t.isNullLiteral(keyNode) || (this.t.isIdentifier(keyNode) && keyNode.name === 'undefined'))\r\n          ) {\r\n            key = keyNode;\r\n          }\r\n        }\r\n        forBodyStatements = childNodes.slice(1);\r\n      } else {\r\n        forBodyStatements = childNodes;\r\n      }\r\n    } else return;\r\n\r\n    const directives = forBodyStatements.filter(s => this.t.isDirective(s)) as t.Directive[];\r\n    const statements = forBodyStatements.filter(s => !this.t.isDirective(s)) as t.Statement[];\r\n    const children = node.children.map(child => this.parseView(child)).flat();\r\n    // ---- Parse the for body statements\r\n    this.viewUnits.push({\r\n      type: 'for',\r\n      item,\r\n      array: array.value,\r\n      key,\r\n      children,\r\n    });\r\n  }\r\n}\r\n","import { ViewParser } from './parser';\r\nimport type { ViewUnit, ViewParserConfig, AllowedJSXNode } from './types';\r\n\r\n/**\r\n * @brief Generate view units from a babel ast\r\n * @param statement\r\n * @param config\r\n * @returns ViewUnit[]\r\n */\r\nexport function parseView(node: AllowedJSXNode, config: ViewParserConfig): ViewUnit[] {\r\n  return new ViewParser(config).parse(node);\r\n}\r\n\r\nexport * from './types';\r\n","import { createErrorHandler } from '@inula/error-handler';\r\n\r\nexport const DLError = createErrorHandler('ReactivityParser', {\r\n  1: 'Invalid ViewUnit type',\r\n});\r\n","import {\r\n  type TemplateProp,\r\n  type ReactivityParserConfig,\r\n  type MutableParticle,\r\n  type ViewParticle,\r\n  type TemplateParticle,\r\n  type TextParticle,\r\n  type HTMLParticle,\r\n  type DependencyProp,\r\n  type ExpParticle,\r\n  type CompParticle,\r\n  type ForParticle,\r\n  type IfParticle,\r\n  type EnvParticle,\r\n  type SnippetParticle,\r\n  SwitchParticle,\r\n  TryParticle,\r\n} from './types';\r\nimport { type NodePath, type types as t, type traverse } from '@babel/core';\r\nimport {\r\n  type TextUnit,\r\n  type HTMLUnit,\r\n  type ViewUnit,\r\n  type CompUnit,\r\n  type ViewProp,\r\n  type ForUnit,\r\n  type IfUnit,\r\n  type EnvUnit,\r\n  type ExpUnit,\r\n  type SnippetUnit,\r\n  SwitchUnit,\r\n  TryUnit,\r\n} from '@inula/view-parser';\r\nimport { DLError } from './error';\r\n\r\nexport class ReactivityParser {\r\n  private readonly config: ReactivityParserConfig;\r\n\r\n  private readonly t: typeof t;\r\n  private readonly traverse: typeof traverse;\r\n  private readonly availableProperties: string[];\r\n  private readonly availableIdentifiers?: string[];\r\n  private readonly dependencyMap: Record<string, string[]>;\r\n  private readonly identifierDepMap: Record<string, string[]>;\r\n  private readonly dependencyParseType;\r\n  private readonly reactivityFuncNames;\r\n\r\n  private readonly escapeNamings = ['escape', '$'];\r\n  private static readonly customHTMLProps = [\r\n    'didUpdate',\r\n    'willMount',\r\n    'didMount',\r\n    'willUnmount',\r\n    'didUnmount',\r\n    'element',\r\n    'innerHTML',\r\n    'props',\r\n    'attrs',\r\n    'dataset',\r\n    'forwardProps',\r\n  ];\r\n\r\n  readonly usedProperties = new Set<string>();\r\n\r\n  /**\r\n   * @brief Constructor\r\n   * @param viewUnit\r\n   * @param config\r\n   * @param options\r\n   */\r\n  constructor(config: ReactivityParserConfig) {\r\n    this.config = config;\r\n    this.t = config.babelApi.types;\r\n    this.traverse = config.babelApi.traverse;\r\n    this.availableProperties = config.availableProperties;\r\n    this.availableIdentifiers = config.availableIdentifiers;\r\n    this.dependencyMap = config.dependencyMap;\r\n    this.identifierDepMap = config.identifierDepMap ?? {};\r\n    this.dependencyParseType = config.dependencyParseType ?? 'property';\r\n    this.reactivityFuncNames = config.reactivityFuncNames ?? [];\r\n  }\r\n\r\n  /**\r\n   * @brief Parse the ViewUnit into a ViewParticle\r\n   * @returns\r\n   */\r\n  parse(viewUnit: ViewUnit): ViewParticle {\r\n    return this.parseViewUnit(viewUnit);\r\n  }\r\n\r\n  /**\r\n   * @brief Parse a ViewUnit into a ViewParticle\r\n   * @param viewUnit\r\n   * @returns ViewParticle\r\n   */\r\n  private parseViewUnit(viewUnit: ViewUnit): ViewParticle {\r\n    if (this.isHTMLTemplate(viewUnit)) return this.parseTemplate(viewUnit as HTMLUnit);\r\n    if (viewUnit.type === 'text') return this.parseText(viewUnit);\r\n    if (viewUnit.type === 'html') return this.parseHTML(viewUnit);\r\n    if (viewUnit.type === 'comp') return this.parseComp(viewUnit);\r\n    if (viewUnit.type === 'for') return this.parseFor(viewUnit);\r\n    if (viewUnit.type === 'try') return this.parseTry(viewUnit);\r\n    if (viewUnit.type === 'if') return this.parseIf(viewUnit);\r\n    if (viewUnit.type === 'env') return this.parseEnv(viewUnit);\r\n    if (viewUnit.type === 'exp') return this.parseExp(viewUnit);\r\n    if (viewUnit.type === 'switch') return this.parseSwitch(viewUnit);\r\n    if (viewUnit.type === 'snippet') return this.parseSnippet(viewUnit);\r\n    return DLError.throw1();\r\n  }\r\n\r\n  // ---- Parsers ----\r\n  // ---- @Template ----\r\n  /**\r\n   * @brief Collect static HTMLUnit into a template particle and generate a template string\r\n   *  MutableParticle means whatever unit that is not a static HTMLUnit or a TextUnit\r\n   *  Props means all the non-static props of the nested HTMLUnit or TextUnit, e.g. div().className(this.name)\r\n   * @param htmlUnit\r\n   * @returns TemplateParticle\r\n   */\r\n  private parseTemplate(htmlUnit: HTMLUnit): TemplateParticle {\r\n    return {\r\n      type: 'template',\r\n      template: this.generateTemplate(htmlUnit),\r\n      props: this.parseTemplateProps(htmlUnit),\r\n      mutableParticles: this.generateMutableParticles(htmlUnit),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * @brief Generate a template\r\n   *  There'll be a situation where the tag is dynamic, e.g. tag(this.htmlTag),\r\n   *  which we can't generate a template string for it, so we'll wrap it in an ExpParticle in parseHTML() section\r\n   * @param htmlUnit\r\n   * @returns template string\r\n   */\r\n  private generateTemplate(unit: HTMLUnit): HTMLParticle {\r\n    const staticProps = this.filterTemplateProps(\r\n      // ---- Get all the static props\r\n      Object.entries(unit.props).filter(\r\n        ([, prop]) =>\r\n          this.isStaticProp(prop) &&\r\n          // ---- Filter out props with false values\r\n          !(this.t.isBooleanLiteral(prop.value) && !prop.value.value)\r\n      )\r\n    ).map(([key, prop]) => [\r\n      key,\r\n      {\r\n        ...prop,\r\n        dependencyIndexArr: [],\r\n        dependenciesNode: this.t.arrayExpression([]),\r\n        dynamic: false,\r\n      },\r\n    ]);\r\n\r\n    let children: ViewParticle[] = [];\r\n    if (!unit.props.textContent) {\r\n      children = unit.children\r\n        .map(unit => {\r\n          if (unit.type === 'html' && this.t.isStringLiteral(unit.tag)) {\r\n            return this.generateTemplate(unit);\r\n          }\r\n          if (unit.type === 'text' && this.t.isStringLiteral(unit.content)) {\r\n            return this.parseText(unit);\r\n          }\r\n        })\r\n        .filter(Boolean) as HTMLParticle[];\r\n    }\r\n    return {\r\n      type: 'html',\r\n      tag: unit.tag,\r\n      props: Object.fromEntries(staticProps),\r\n      children,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * @brief Collect all the mutable nodes in a static HTMLUnit\r\n   *  We use this function to collect mutable nodes' path and props,\r\n   *  so that in the generator, we know which position to insert the mutable nodes\r\n   * @param htmlUnit\r\n   * @returns mutable particles\r\n   */\r\n  private generateMutableParticles(htmlUnit: HTMLUnit): MutableParticle[] {\r\n    const mutableParticles: MutableParticle[] = [];\r\n    const generateMutableUnit = (unit: HTMLUnit, path: number[] = []) => {\r\n      // ---- Generate mutable particles for current HTMLUnit\r\n      unit.children?.forEach((child, idx) => {\r\n        if (\r\n          !(child.type === 'html' && this.t.isStringLiteral(child.tag)) &&\r\n          !(child.type === 'text' && this.t.isStringLiteral(child.content))\r\n        ) {\r\n          mutableParticles.push({\r\n            path: [...path, idx],\r\n            ...this.parseViewParticle(child),\r\n          });\r\n        }\r\n      });\r\n      // ---- Recursively generate mutable particles for static HTMLUnit children\r\n      unit.children\r\n        ?.filter(child => child.type === 'html' && this.t.isStringLiteral(child.tag))\r\n        .forEach((child, idx) => {\r\n          generateMutableUnit(child as HTMLUnit, [...path, idx]);\r\n        });\r\n    };\r\n    generateMutableUnit(htmlUnit);\r\n\r\n    return mutableParticles;\r\n  }\r\n\r\n  /**\r\n   * @brief Collect all the props in a static HTMLUnit or its nested HTMLUnit or TextUnit children\r\n   *  Just like the mutable nodes, props are also equipped with path,\r\n   *  so that we know which HTML ChildNode to insert the props\r\n   * @param htmlUnit\r\n   * @returns props\r\n   */\r\n  private parseTemplateProps(htmlUnit: HTMLUnit): TemplateProp[] {\r\n    const templateProps: TemplateProp[] = [];\r\n    const generateVariableProp = (unit: HTMLUnit, path: number[]) => {\r\n      // ---- Generate all non-static(string/number/boolean) props for current HTMLUnit\r\n      //      to be inserted further in the generator\r\n      Object.entries(unit.props)\r\n        .filter(([, prop]) => !this.isStaticProp(prop))\r\n        .forEach(([key, prop]) => {\r\n          templateProps.push({\r\n            tag: (unit.tag as t.StringLiteral).value,\r\n            key,\r\n            path,\r\n            value: prop.value,\r\n            ...this.getDependencies(prop.value),\r\n          });\r\n        });\r\n      // ---- Recursively generate props for static HTMLUnit children\r\n      unit.children\r\n        .filter(\r\n          child =>\r\n            (child.type === 'html' && this.t.isStringLiteral(child.tag)) ||\r\n            (child.type === 'text' && this.t.isStringLiteral(child.content))\r\n        )\r\n        .forEach((child, idx) => {\r\n          if (child.type === 'html') {\r\n            generateVariableProp(child, [...path, idx]);\r\n          } else if (child.type === 'text') {\r\n            // ---- if the child is a TextUnit, we just insert the text content\r\n            templateProps.push({\r\n              tag: 'text',\r\n              key: 'value',\r\n              path: [...path, idx],\r\n              value: child.content,\r\n              dependencyIndexArr: [],\r\n              dependenciesNode: this.t.arrayExpression([]),\r\n              dynamic: false,\r\n            });\r\n          }\r\n        });\r\n    };\r\n    generateVariableProp(htmlUnit, []);\r\n\r\n    return templateProps;\r\n  }\r\n\r\n  // ---- @Text ----\r\n  /**\r\n   * @brief Parse a TextUnit into a TextParticle.\r\n   *  This is only for a top level TextUnit, because if nested in HTMLUnit, it'll be parsed in the template string\r\n   * @param textUnit\r\n   * @returns TextParticle\r\n   */\r\n  private parseText(textUnit: TextUnit): TextParticle {\r\n    return {\r\n      type: 'text',\r\n      content: {\r\n        value: textUnit.content,\r\n        ...this.getDependencies(textUnit.content),\r\n      },\r\n    };\r\n  }\r\n\r\n  // ---- @HTML ----\r\n  /**\r\n   * @brief Parse an HTMLUnit with a dynamic tag into an ExpParticle or an HTMLParticle\r\n   *  We detect dependencies in the tag, if there's no dependency,\r\n   *  we parse it as an HTMLParticle and dynamically append it to the parent node;\r\n   *  if there's dependency, we parse it as an ExpParticle and wrap it in an ExpParticle\r\n   *  so that we can make the tag reactive\r\n   * @param htmlUnit\r\n   * @returns ExpParticle | HTMLParticle\r\n   */\r\n  private parseHTML(htmlUnit: HTMLUnit): ExpParticle | HTMLParticle {\r\n    const { dependencyIndexArr, dependenciesNode, dynamic } = this.getDependencies(htmlUnit.tag);\r\n\r\n    const innerHTMLParticle: HTMLParticle = {\r\n      type: 'html',\r\n      tag: htmlUnit.tag,\r\n      props: {},\r\n      children: [],\r\n    };\r\n\r\n    innerHTMLParticle.props = Object.fromEntries(\r\n      Object.entries(htmlUnit.props).map(([key, prop]) => [key, this.generateDependencyProp(prop)])\r\n    );\r\n\r\n    innerHTMLParticle.children = htmlUnit.children.map(this.parseViewParticle.bind(this));\r\n\r\n    // ---- Not a dynamic tag\r\n    if (!dynamic) return innerHTMLParticle;\r\n\r\n    // ---- Dynamic tag, wrap it in an ExpParticle to make the tag reactive\r\n    const id = this.uid();\r\n    return {\r\n      type: 'exp',\r\n      content: {\r\n        value: this.t.stringLiteral(id),\r\n        viewPropMap: {\r\n          [id]: [innerHTMLParticle],\r\n        },\r\n        dependencyIndexArr,\r\n        dependenciesNode,\r\n        dynamic,\r\n      },\r\n      props: {},\r\n    };\r\n  }\r\n\r\n  // ---- @Comp ----\r\n  /**\r\n   * @brief Parse a CompUnit into a CompParticle or an ExpParticle\r\n   *  Similar to parseHTML(), we detect dependencies in the tag, if there's no dependency,\r\n   *  we parse it as a regular CompParticle, otherwise we wrap it with an ExpParticle.\r\n   * @param compUnit\r\n   * @returns CompParticle | ExpParticle\r\n   */\r\n  private parseComp(compUnit: CompUnit): CompParticle | ExpParticle {\r\n    const { dependencyIndexArr, dependenciesNode, dynamic } = this.getDependencies(compUnit.tag);\r\n\r\n    const compParticle: CompParticle = {\r\n      type: 'comp',\r\n      tag: compUnit.tag,\r\n      props: {},\r\n      children: [],\r\n    };\r\n\r\n    compParticle.props = Object.fromEntries(\r\n      Object.entries(compUnit.props).map(([key, prop]) => [key, this.generateDependencyProp(prop)])\r\n    );\r\n    compParticle.children = compUnit.children.map(this.parseViewParticle.bind(this));\r\n\r\n    if (!dynamic) return compParticle;\r\n\r\n    const id = this.uid();\r\n    return {\r\n      type: 'exp',\r\n      content: {\r\n        value: this.t.stringLiteral(id),\r\n        viewPropMap: {\r\n          [id]: [compParticle],\r\n        },\r\n        dependencyIndexArr,\r\n        dependenciesNode,\r\n        dynamic,\r\n      },\r\n      props: {},\r\n    };\r\n  }\r\n\r\n  // ---- @For ----\r\n  /**\r\n   * @brief Parse a ForUnit into a ForParticle with dependencies\r\n   *  Key and item doesn't need to be reactive, so here we don't collect dependencies for it\r\n   * @param forUnit\r\n   * @returns ForParticle\r\n   */\r\n  private parseFor(forUnit: ForUnit): ForParticle {\r\n    const { dependencyIndexArr, dependenciesNode, dynamic } = this.getDependencies(forUnit.array);\r\n    const prevIdentifierDepMap = this.config.identifierDepMap;\r\n    // ---- Find all the identifiers in the key and remove them from the identifierDepMap\r\n    //      because once the key is changed, that identifier related dependencies will be changed too,\r\n    //      so no need to update them\r\n    const keyDep = this.t.isIdentifier(forUnit.key) && forUnit.key.name;\r\n    // ---- Generate an identifierDepMap to track identifiers in item and make them reactive\r\n    //      based on the dependencies from the array\r\n    this.config.identifierDepMap = Object.fromEntries(\r\n      this.getIdentifiers(this.t.assignmentExpression('=', forUnit.item, this.t.objectExpression([])))\r\n        .filter(id => !keyDep || id !== keyDep)\r\n        .map(id => [id, dependencyIndexArr.map(n => this.availableProperties[n])])\r\n    );\r\n\r\n    const forParticle: ForParticle = {\r\n      type: 'for',\r\n      item: forUnit.item,\r\n      array: {\r\n        value: forUnit.array,\r\n        dynamic,\r\n        dependencyIndexArr,\r\n        dependenciesNode,\r\n      },\r\n      children: forUnit.children.map(this.parseViewParticle.bind(this)),\r\n      key: forUnit.key,\r\n    };\r\n    this.config.identifierDepMap = prevIdentifierDepMap;\r\n    return forParticle;\r\n  }\r\n\r\n  // ---- @If ----\r\n  /**\r\n   * @brief Parse an IfUnit into an IfParticle with dependencies\r\n   * @param ifUnit\r\n   * @returns IfParticle\r\n   */\r\n  private parseIf(ifUnit: IfUnit): IfParticle {\r\n    return {\r\n      type: 'if',\r\n      branches: ifUnit.branches.map(branch => ({\r\n        condition: {\r\n          value: branch.condition,\r\n          ...this.getDependencies(branch.condition),\r\n        },\r\n        children: branch.children.map(this.parseViewParticle.bind(this)),\r\n      })),\r\n    };\r\n  }\r\n\r\n  // ---- @Switch ----\r\n  /**\r\n   * @brief Parse a SwitchUnit into an SwitchParticle with dependencies\r\n   * @param switchUnit\r\n   * @returns SwitchParticle\r\n   */\r\n  private parseSwitch(switchUnit: SwitchUnit): SwitchParticle {\r\n    return {\r\n      type: 'switch',\r\n      discriminant: {\r\n        value: switchUnit.discriminant,\r\n        ...this.getDependencies(switchUnit.discriminant),\r\n      },\r\n      branches: switchUnit.branches.map(branch => ({\r\n        case: {\r\n          value: branch.case,\r\n          ...this.getDependencies(branch.case),\r\n        },\r\n        children: branch.children.map(this.parseViewParticle.bind(this)),\r\n        break: branch.break,\r\n      })),\r\n    };\r\n  }\r\n\r\n  // ---- @Try ----\r\n  /**\r\n   * @brief Parse a TryUnit into an TryParticle with dependencies\r\n   * @param tryUnit\r\n   * @returns TryParticle\r\n   */\r\n  private parseTry(tryUnit: TryUnit): TryParticle {\r\n    return {\r\n      type: 'try',\r\n      children: tryUnit.children.map(this.parseViewParticle.bind(this)),\r\n      exception: tryUnit.exception,\r\n      catchChildren: tryUnit.catchChildren.map(this.parseViewParticle.bind(this)),\r\n    };\r\n  }\r\n\r\n  // ---- @Env ----\r\n  /**\r\n   * @brief Parse an EnvUnit into an EnvParticle with dependencies\r\n   * @param envUnit\r\n   * @returns EnvParticle\r\n   */\r\n  private parseEnv(envUnit: EnvUnit): EnvParticle {\r\n    return {\r\n      type: 'env',\r\n      props: Object.fromEntries(\r\n        Object.entries(envUnit.props).map(([key, prop]) => [key, this.generateDependencyProp(prop)])\r\n      ),\r\n      children: envUnit.children.map(this.parseViewParticle.bind(this)),\r\n    };\r\n  }\r\n\r\n  // ---- @Exp ----\r\n  /**\r\n   * @brief Parse an ExpUnit into an ExpParticle with dependencies\r\n   * @param expUnit\r\n   * @returns ExpParticle\r\n   */\r\n  private parseExp(expUnit: ExpUnit): ExpParticle {\r\n    const expParticle: ExpParticle = {\r\n      type: 'exp',\r\n      content: this.generateDependencyProp(expUnit.content),\r\n      props: Object.fromEntries(\r\n        Object.entries(expUnit.props).map(([key, prop]) => [key, this.generateDependencyProp(prop)])\r\n      ),\r\n    };\r\n    return expParticle;\r\n  }\r\n\r\n  // ---- @Snippet ----\r\n  /**\r\n   * @brief Parse a SnippetUnit into a SnippetParticle with dependencies\r\n   * @param snippetUnit\r\n   * @returns SnippetParticle\r\n   */\r\n  private parseSnippet(snippetUnit: SnippetUnit): SnippetParticle {\r\n    const snippetParticle: SnippetParticle = {\r\n      type: 'snippet',\r\n      tag: snippetUnit.tag,\r\n      props: {},\r\n      children: [],\r\n    };\r\n    if (snippetUnit.props) {\r\n      snippetParticle.props = Object.fromEntries(\r\n        Object.entries(snippetUnit.props).map(([key, prop]) => [key, this.generateDependencyProp(prop)])\r\n      );\r\n    }\r\n    if (snippetUnit.children) {\r\n      snippetParticle.children = snippetUnit.children.map(this.parseViewParticle.bind(this));\r\n    }\r\n\r\n    return snippetParticle;\r\n  }\r\n\r\n  // ---- Dependencies ----\r\n  /**\r\n   * @brief Generate a dependency prop with dependencies\r\n   * @param prop\r\n   * @returns DependencyProp\r\n   */\r\n  private generateDependencyProp(prop: ViewProp): DependencyProp {\r\n    const dependencyProp: DependencyProp = {\r\n      value: prop.value,\r\n      ...this.getDependencies(prop.value),\r\n      viewPropMap: Object.fromEntries(\r\n        Object.entries(prop.viewPropMap).map(([key, units]) => [key, units.map(this.parseViewParticle.bind(this))])\r\n      ),\r\n    };\r\n    return dependencyProp;\r\n  }\r\n\r\n  /**\r\n   * @brief Get all the dependencies of a node\r\n   *  this.dependencyParseType controls how we parse the dependencies\r\n   * 1. property: parse the dependencies of a node as a property, e.g. this.name\r\n   * 2. identifier: parse the dependencies of a node as an identifier, e.g. name\r\n   * The availableProperties is the list of all the properties that can be used in the template,\r\n   * no matter it's a property or an identifier\r\n   * @param node\r\n   * @returns dependency index array\r\n   */\r\n  private getDependencies(node: t.Expression | t.Statement): {\r\n    dynamic: boolean;\r\n    dependencyIndexArr: number[];\r\n    dependenciesNode: t.ArrayExpression;\r\n  } {\r\n    if (this.t.isFunctionExpression(node) || this.t.isArrowFunctionExpression(node)) {\r\n      return {\r\n        dynamic: false,\r\n        dependencyIndexArr: [],\r\n        dependenciesNode: this.t.arrayExpression([]),\r\n      };\r\n    }\r\n    // ---- Both id and prop deps need to be calculated because\r\n    //      id is for snippet update, prop is normal update\r\n    //      in a snippet, the depsNode should be both id and prop\r\n    const [directIdentifierDeps, identifierDepNodes] = this.getIdentifierDependencies(node);\r\n    const [directPropertyDeps, propertyDepNodes] = this.getPropertyDependencies(node);\r\n    const directDependencies = this.dependencyParseType === 'identifier' ? directIdentifierDeps : directPropertyDeps;\r\n    const identifierMapDependencies = this.getIdentifierMapDependencies(node);\r\n    const deps = [...new Set([...directDependencies, ...identifierMapDependencies])];\r\n\r\n    const depNodes = [...identifierDepNodes, ...propertyDepNodes] as t.Expression[];\r\n\r\n    return {\r\n      dynamic: depNodes.length > 0 || deps.length > 0,\r\n      dependencyIndexArr: deps,\r\n      dependenciesNode: this.t.arrayExpression(depNodes),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * @brief Get all the dependencies of a node if a property is a valid dependency as\r\n   *  1. the identifier is in the availableProperties\r\n   *  2. the identifier is a stand alone identifier\r\n   *  3. the identifier is not in an escape function\r\n   *  4. the identifier is not in a manual function\r\n   *  5. the identifier is not the left side of an assignment expression, which is an assignment expression\r\n   *  6. the identifier is not the right side of an assignment expression, which is an update expression\r\n   * @param node\r\n   * @returns dependency index array\r\n   */\r\n  private getIdentifierDependencies(node: t.Expression | t.Statement): [number[], t.Node[]] {\r\n    const availableIdentifiers = this.availableIdentifiers ?? this.availableProperties;\r\n\r\n    const deps = new Set<string>();\r\n    const assignDeps = new Set<string>();\r\n    const depNodes: Record<string, t.Node[]> = {};\r\n\r\n    const wrappedNode = this.valueWrapper(node);\r\n    this.traverse(wrappedNode, {\r\n      Identifier: innerPath => {\r\n        const identifier = innerPath.node;\r\n        const idName = identifier.name;\r\n        if (!availableIdentifiers.includes(idName)) return;\r\n        if (this.isAssignmentExpressionLeft(innerPath) || this.isAssignmentFunction(innerPath)) {\r\n          assignDeps.add(idName);\r\n        } else if (\r\n          this.isStandAloneIdentifier(innerPath) &&\r\n          !this.isMemberInEscapeFunction(innerPath) &&\r\n          !this.isMemberInManualFunction(innerPath)\r\n        ) {\r\n          deps.add(idName);\r\n          this.dependencyMap[idName]?.forEach(deps.add.bind(deps));\r\n          if (!depNodes[idName]) depNodes[idName] = [];\r\n          depNodes[idName].push(this.geneDependencyNode(innerPath));\r\n        }\r\n      },\r\n    });\r\n\r\n    assignDeps.forEach(dep => {\r\n      deps.delete(dep);\r\n      delete depNodes[dep];\r\n    });\r\n    let dependencyNodes = Object.values(depNodes).flat();\r\n    // ---- deduplicate the dependency nodes\r\n    dependencyNodes = dependencyNodes.filter((n, i) => {\r\n      const idx = dependencyNodes.findIndex(m => this.t.isNodesEquivalent(m, n));\r\n      return idx === i;\r\n    });\r\n\r\n    deps.forEach(this.usedProperties.add.bind(this.usedProperties));\r\n    return [[...deps].map(dep => this.availableProperties.indexOf(dep)), dependencyNodes];\r\n  }\r\n\r\n  /**\r\n   * @brief Get all the dependencies of a node if a member expression is a valid dependency as\r\n   *  1. the property is in the availableProperties\r\n   *  2. the object is this\r\n   *  3. the member expression is not in an escape function\r\n   *  4. the member expression is not in a manual function\r\n   *  5. the member expression is not the left side of an assignment expression, which is an assignment expression\r\n   *  6. the member is not a pure function declaration\r\n   * @param node\r\n   * @returns dependency index array\r\n   */\r\n  private getPropertyDependencies(node: t.Expression | t.Statement): [number[], t.Node[]] {\r\n    const deps = new Set<string>();\r\n    const assignDeps = new Set<string>();\r\n    const depNodes: Record<string, t.Node[]> = {};\r\n\r\n    const wrappedNode = this.valueWrapper(node);\r\n    this.traverse(wrappedNode, {\r\n      MemberExpression: innerPath => {\r\n        if (!this.t.isIdentifier(innerPath.node.property) || !this.t.isThisExpression(innerPath.node.object)) return;\r\n        const propertyKey = innerPath.node.property.name;\r\n        if (this.isAssignmentExpressionLeft(innerPath) || this.isAssignmentFunction(innerPath)) {\r\n          assignDeps.add(propertyKey);\r\n        } else if (\r\n          this.availableProperties.includes(propertyKey) &&\r\n          !this.isMemberInEscapeFunction(innerPath) &&\r\n          !this.isMemberInManualFunction(innerPath)\r\n        ) {\r\n          deps.add(propertyKey);\r\n          this.dependencyMap[propertyKey]?.forEach(deps.add.bind(deps));\r\n          if (!depNodes[propertyKey]) depNodes[propertyKey] = [];\r\n          depNodes[propertyKey].push(this.geneDependencyNode(innerPath));\r\n        }\r\n      },\r\n    });\r\n\r\n    assignDeps.forEach(dep => {\r\n      deps.delete(dep);\r\n      delete depNodes[dep];\r\n    });\r\n    let dependencyNodes = Object.values(depNodes).flat();\r\n    // ---- deduplicate the dependency nodes\r\n    dependencyNodes = dependencyNodes.filter((n, i) => {\r\n      const idx = dependencyNodes.findIndex(m => this.t.isNodesEquivalent(m, n));\r\n      return idx === i;\r\n    });\r\n\r\n    deps.forEach(this.usedProperties.add.bind(this.usedProperties));\r\n    return [[...deps].map(dep => this.availableProperties.indexOf(dep)), dependencyNodes];\r\n  }\r\n\r\n  /**\r\n   * @brief Generate a dependency node from a dependency identifier,\r\n   *  loop until the parent node is not a binary expression or a member expression\r\n   * @param path\r\n   * @returns\r\n   */\r\n  private geneDependencyNode(path: NodePath): t.Node {\r\n    let parentPath = path;\r\n    while (parentPath?.parentPath) {\r\n      const pParentPath = parentPath.parentPath;\r\n      if (\r\n        !(\r\n          this.t.isMemberExpression(pParentPath.node, { computed: false }) ||\r\n          this.t.isOptionalMemberExpression(pParentPath.node)\r\n        )\r\n      ) {\r\n        break;\r\n      }\r\n      parentPath = pParentPath;\r\n    }\r\n    const depNode = this.t.cloneNode(parentPath.node);\r\n    // ---- Turn memberExpression to optionalMemberExpression\r\n    this.traverse(this.valueWrapper(depNode as t.Expression), {\r\n      MemberExpression: innerPath => {\r\n        if (this.t.isThisExpression(innerPath.node.object)) return;\r\n        innerPath.node.optional = true;\r\n        innerPath.node.type = 'OptionalMemberExpression' as any;\r\n      },\r\n    });\r\n    return depNode;\r\n  }\r\n\r\n  /**\r\n   * @brief Get dependencies from the identifierDepMap\r\n   *  e.g.\r\n   *  map: { \"a\": [\"dep1\", \"dep2\"] }\r\n   *  expression: const b = a\r\n   *  deps for b: [\"dep1\", \"dep2\"]\r\n   * @param node\r\n   * @returns dependency index array\r\n   */\r\n  private getIdentifierMapDependencies(node: t.Expression | t.Statement): number[] {\r\n    const deps = new Set<string>();\r\n\r\n    const wrappedNode = this.valueWrapper(node);\r\n    this.traverse(wrappedNode, {\r\n      Identifier: innerPath => {\r\n        const identifier = innerPath.node;\r\n        const idName = identifier.name;\r\n        if (this.isAttrFromFunction(innerPath, idName)) return;\r\n        const depsArray = this.identifierDepMap[idName];\r\n\r\n        if (!depsArray || !Array.isArray(depsArray)) return;\r\n        if (this.isMemberInEscapeFunction(innerPath) || this.isMemberInManualFunction(innerPath)) return;\r\n        depsArray.forEach(deps.add.bind(deps));\r\n      },\r\n    });\r\n\r\n    deps.forEach(this.usedProperties.add.bind(this.usedProperties));\r\n    return [...deps].map(dep => this.availableProperties.indexOf(dep));\r\n  }\r\n\r\n  // ---- Utils ----\r\n  /**\r\n   * @brief Parse a ViewUnit into a ViewParticle by new-ing a ReactivityParser\r\n   * @param viewUnit\r\n   * @returns ViewParticle\r\n   */\r\n  private parseViewParticle(viewUnit: ViewUnit): ViewParticle {\r\n    const parser = new ReactivityParser(this.config);\r\n    const parsedUnit = parser.parse(viewUnit);\r\n    // ---- Collect used properties\r\n    parser.usedProperties.forEach(this.usedProperties.add.bind(this.usedProperties));\r\n    return parsedUnit;\r\n  }\r\n\r\n  /**\r\n   * @brief Check if a ViewUnit is a static HTMLUnit that can be parsed into a template\r\n   *  Must satisfy:\r\n   *  1. type is html\r\n   *  2. tag is a string literal, i.e., non-dynamic tag\r\n   *  3. has at least one child that is a static HTMLUnit,\r\n   *     or else just call a createElement function, no need for template clone\r\n   * @param viewUnit\r\n   * @returns is a static HTMLUnit\r\n   */\r\n  private isHTMLTemplate(viewUnit: ViewUnit): boolean {\r\n    return (\r\n      viewUnit.type === 'html' &&\r\n      this.t.isStringLiteral(viewUnit.tag) &&\r\n      !!viewUnit.children?.some(child => child.type === 'html' && this.t.isStringLiteral(child.tag))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @brief Check if a prop is a static prop\r\n   *  i.e.\r\n   *  1. no viewPropMap\r\n   *  2. value is a string/number/boolean literal\r\n   * @param prop\r\n   * @returns is a static prop\r\n   */\r\n  private isStaticProp(prop: ViewProp): boolean {\r\n    const { value, viewPropMap } = prop;\r\n    return (\r\n      (!viewPropMap || Object.keys(viewPropMap).length === 0) &&\r\n      (this.t.isStringLiteral(value) || this.t.isNumericLiteral(value) || this.t.isBooleanLiteral(value))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @brief Filter out some props that are not needed in the template,\r\n   *  these are all special props to be parsed differently in the generator\r\n   * @param props\r\n   * @returns filtered props\r\n   */\r\n  private filterTemplateProps<T>(props: Array<[string, T]>): Array<[string, T]> {\r\n    return (\r\n      props\r\n        // ---- Filter out event listeners\r\n        .filter(([key]) => !key.startsWith('on'))\r\n        // ---- Filter out specific props\r\n        .filter(([key]) => !ReactivityParser.customHTMLProps.includes(key))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @brief Wrap the value in a file\r\n   * @param node\r\n   * @returns wrapped value\r\n   */\r\n  private valueWrapper(node: t.Expression | t.Statement): t.File {\r\n    return this.t.file(this.t.program([this.t.isStatement(node) ? node : this.t.expressionStatement(node)]));\r\n  }\r\n\r\n  /**\r\n   * @brief Check if an identifier is a simple stand alone identifier,\r\n   *  i.e., not a member expression, nor a function param\r\n   * @param path\r\n   *  1. not a member expression\r\n   *  2. not a function param\r\n   *  3. not in a declaration\r\n   *  4. not as object property's not computed key\r\n   * @returns is a stand alone identifier\r\n   */\r\n  private isStandAloneIdentifier(path: NodePath<t.Identifier>): boolean {\r\n    const node = path.node;\r\n    const parentNode = path.parentPath?.node;\r\n    const isMemberExpression = this.t.isMemberExpression(parentNode) && parentNode.property === node;\r\n    if (isMemberExpression) return false;\r\n    const isFunctionParam = this.isAttrFromFunction(path, node.name);\r\n    if (isFunctionParam) return false;\r\n    while (path.parentPath) {\r\n      if (this.t.isVariableDeclarator(path.parentPath.node)) return false;\r\n      if (\r\n        this.t.isObjectProperty(path.parentPath.node) &&\r\n        path.parentPath.node.key === path.node &&\r\n        !path.parentPath.node.computed\r\n      )\r\n        return false;\r\n      path = path.parentPath as NodePath<t.Identifier>;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @brief Get all identifiers as strings in a node\r\n   * @param node\r\n   * @returns identifiers\r\n   */\r\n  private getIdentifiers(node: t.Node): string[] {\r\n    if (this.t.isIdentifier(node)) return [node.name];\r\n    const identifierKeys = new Set<string>();\r\n    this.traverse(this.valueWrapper(node as t.Expression), {\r\n      Identifier: innerPath => {\r\n        if (!this.isStandAloneIdentifier(innerPath)) return;\r\n        identifierKeys.add(innerPath.node.name);\r\n      },\r\n    });\r\n    return [...identifierKeys];\r\n  }\r\n\r\n  /**\r\n   * @brief check if the identifier is from a function param till the stopNode\r\n   *  e.g:\r\n   *  function myFunc1(ok) { // stopNode = functionBody\r\n   *     const myFunc2 = ok => ok // from function param\r\n   *     console.log(ok) // not from function param\r\n   *  }\r\n   */\r\n  private isAttrFromFunction(path: NodePath, idName: string) {\r\n    let reversePath = path.parentPath;\r\n\r\n    const checkParam: (param: t.Node) => boolean = (param: t.Node) => {\r\n      // ---- 3 general types:\r\n      //      * represent allow nesting\r\n      // ---0 Identifier: (a)\r\n      // ---1 RestElement: (...a)   *\r\n      // ---1 Pattern: 3 sub Pattern\r\n      // -----0   AssignmentPattern: (a=1)   *\r\n      // -----1   ArrayPattern: ([a, b])   *\r\n      // -----2   ObjectPattern: ({a, b})\r\n      if (this.t.isIdentifier(param)) return param.name === idName;\r\n      if (this.t.isAssignmentPattern(param)) return checkParam(param.left);\r\n      if (this.t.isArrayPattern(param)) {\r\n        return param.elements\r\n          .filter(Boolean)\r\n          .map(el => checkParam(el!))\r\n          .includes(true);\r\n      }\r\n      if (this.t.isObjectPattern(param)) {\r\n        return (\r\n          param.properties.filter(\r\n            prop => this.t.isObjectProperty(prop) && this.t.isIdentifier(prop.key)\r\n          ) as t.ObjectProperty[]\r\n        )\r\n          .map(prop => (prop.key as t.Identifier).name)\r\n          .includes(idName);\r\n      }\r\n      if (this.t.isRestElement(param)) return checkParam(param.argument);\r\n\r\n      return false;\r\n    };\r\n\r\n    while (reversePath) {\r\n      const node = reversePath.node;\r\n      if (this.t.isArrowFunctionExpression(node) || this.t.isFunctionDeclaration(node)) {\r\n        for (const param of node.params) {\r\n          if (checkParam(param)) return true;\r\n        }\r\n      }\r\n      reversePath = reversePath.parentPath;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @brief Check if it's the left side of an assignment expression, e.g. this.count = 1\r\n   * @param innerPath\r\n   * @returns is left side of an assignment expression\r\n   */\r\n  private isAssignmentExpressionLeft(innerPath: NodePath): boolean {\r\n    let parentPath = innerPath.parentPath;\r\n    while (parentPath && !this.t.isStatement(parentPath.node)) {\r\n      if (this.t.isAssignmentExpression(parentPath.node)) {\r\n        if (parentPath.node.left === innerPath.node) return true;\r\n        const leftPath = parentPath.get('left') as NodePath;\r\n        if (innerPath.isDescendant(leftPath)) return true;\r\n      } else if (this.t.isUpdateExpression(parentPath.node)) {\r\n        return true;\r\n      }\r\n      parentPath = parentPath.parentPath;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @brief Check if it's a reactivity function, e.g. arr.push\r\n   * @param innerPath\r\n   * @returns\r\n   */\r\n  private isAssignmentFunction(innerPath: NodePath): boolean {\r\n    let parentPath = innerPath.parentPath;\r\n\r\n    while (parentPath && this.t.isMemberExpression(parentPath.node)) {\r\n      parentPath = parentPath.parentPath;\r\n    }\r\n    if (!parentPath) return false;\r\n    return (\r\n      this.t.isCallExpression(parentPath.node) &&\r\n      this.t.isMemberExpression(parentPath.node.callee) &&\r\n      this.t.isIdentifier(parentPath.node.callee.property) &&\r\n      this.reactivityFuncNames.includes(parentPath.node.callee.property.name)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @brief Check if it's in an \"escape\" function,\r\n   *        e.g. escape(() => { console.log(this.count) })\r\n   *              deps will be empty instead of [\"count\"]\r\n   * @param innerPath\r\n   * @param classDeclarationNode\r\n   * @returns is in escape function\r\n   */\r\n  private isMemberInEscapeFunction(innerPath: NodePath): boolean {\r\n    let isInFunction = false;\r\n    let reversePath = innerPath.parentPath;\r\n    while (reversePath) {\r\n      const node = reversePath.node;\r\n      if (\r\n        this.t.isCallExpression(node) &&\r\n        this.t.isIdentifier(node.callee) &&\r\n        this.escapeNamings.includes(node.callee.name)\r\n      ) {\r\n        isInFunction = true;\r\n        break;\r\n      }\r\n      reversePath = reversePath.parentPath;\r\n    }\r\n    return isInFunction;\r\n  }\r\n\r\n  /**\r\n   * @brief Check if it's in a \"manual\" function,\r\n   *        e.g. manual(() => { console.log(this.count) }, [\"flag\"])\r\n   *             deps will be [\"flag\"] instead of [\"count\"]\r\n   * @param innerPath\r\n   * @param classDeclarationNode\r\n   * @returns is in manual function\r\n   */\r\n  private isMemberInManualFunction(innerPath: NodePath): boolean {\r\n    let isInFunction = false;\r\n    let reversePath = innerPath.parentPath;\r\n\r\n    while (reversePath) {\r\n      const node = reversePath.node;\r\n      const parentNode = reversePath.parentPath?.node;\r\n      const isManual =\r\n        this.t.isCallExpression(parentNode) &&\r\n        this.t.isIdentifier(parentNode.callee) &&\r\n        parentNode.callee.name === 'manual';\r\n      const isFirstParam = this.t.isCallExpression(parentNode) && parentNode.arguments[0] === node;\r\n      if (isManual && isFirstParam) {\r\n        isInFunction = true;\r\n        break;\r\n      }\r\n      reversePath = reversePath.parentPath;\r\n    }\r\n\r\n    return isInFunction;\r\n  }\r\n\r\n  /**\r\n   * @brief Generate a random string\r\n   * @returns\r\n   */\r\n  private uid(): string {\r\n    return Math.random().toString(36).slice(2);\r\n  }\r\n}\r\n","import { type ViewUnit } from '@inula/view-parser';\r\nimport { ReactivityParser } from './parser';\r\nimport { type ViewParticle, type ReactivityParserConfig } from './types';\r\n\r\n/**\r\n * @brief Parse view units to get used properties and view particles with reactivity\r\n * @param viewUnits\r\n * @param config\r\n * @param options\r\n * @returns [viewParticles, usedProperties]\r\n */\r\nexport function parseReactivity(viewUnits: ViewUnit[], config: ReactivityParserConfig): [ViewParticle[], Set<string>] {\r\n  // ---- ReactivityParser only accepts one view unit at a time,\r\n  //      so we loop through the view units and get all the used properties\r\n  const usedProperties = new Set<string>();\r\n  const dlParticles = viewUnits.map(viewUnit => {\r\n    const parser = new ReactivityParser(config);\r\n    const dlParticle = parser.parse(viewUnit);\r\n    parser.usedProperties.forEach(usedProperties.add.bind(usedProperties));\r\n    return dlParticle;\r\n  });\r\n  return [dlParticles, usedProperties];\r\n}\r\n\r\nexport type * from './types';\r\n","import { type types as t, type traverse } from '@babel/core';\r\nimport { type ViewParticle } from '@inula/reactivity-parser';\r\nimport { type SnippetPropMap, type ViewGeneratorConfig } from '../types';\r\nimport ViewGenerator from '../ViewGenerator';\r\n\r\nexport const prefixMap = { template: '$t', node: '$node' };\r\n\r\nexport default class BaseGenerator {\r\n  readonly viewParticle: ViewParticle;\r\n  readonly config: ViewGeneratorConfig;\r\n\r\n  readonly t: typeof t;\r\n  readonly traverse: typeof traverse;\r\n  readonly className: string;\r\n  readonly importMap: Record<string, string>;\r\n  readonly snippetPropMap: SnippetPropMap;\r\n  readonly elementAttributeMap;\r\n  readonly alterAttributeMap;\r\n\r\n  readonly viewGenerator;\r\n\r\n  /**\r\n   * @brief Constructor\r\n   * @param viewUnit\r\n   * @param config\r\n   */\r\n  constructor(viewParticle: ViewParticle, config: ViewGeneratorConfig) {\r\n    this.viewParticle = viewParticle;\r\n    this.config = config;\r\n    this.t = config.babelApi.types;\r\n    this.traverse = config.babelApi.traverse;\r\n    this.className = config.className;\r\n    this.importMap = config.importMap;\r\n    this.snippetPropMap = config.snippetPropMap;\r\n    this.viewGenerator = new ViewGenerator(config);\r\n    this.elementAttributeMap = config.attributeMap\r\n      ? Object.entries(config.attributeMap).reduce<Record<string, string[]>>((acc, [key, elements]) => {\r\n          elements.forEach(element => {\r\n            if (!acc[element]) acc[element] = [];\r\n            acc[element].push(key);\r\n          });\r\n          return acc;\r\n        }, {})\r\n      : {};\r\n    this.alterAttributeMap = config.alterAttributeMap;\r\n  }\r\n\r\n  // ---- Init Statements\r\n  private readonly initStatements: t.Statement[] = [];\r\n  addInitStatement(...statements: (t.Statement | null)[]) {\r\n    this.initStatements.push(...(statements.filter(Boolean) as t.Statement[]));\r\n  }\r\n\r\n  // ---- Added Class Properties, typically used in for Template\r\n  private readonly classProperties: t.ClassProperty[] = [];\r\n  addStaticClassProperty(key: string, value: t.Expression) {\r\n    this.classProperties.push(\r\n      this.t.classProperty(this.t.identifier(key), value, undefined, undefined, undefined, true)\r\n    );\r\n  }\r\n\r\n  // ---- Update Statements\r\n  private readonly updateStatements: Record<number, t.Statement[]> = {};\r\n  addUpdateStatements(dependencies: number[] | undefined, statement: t.Statement | undefined | null) {\r\n    if (!dependencies || dependencies.length === 0) return;\r\n    const depNum = BaseGenerator.calcDependencyNum(dependencies);\r\n    if (!this.updateStatements[depNum]) this.updateStatements[depNum] = [];\r\n    if (statement) this.updateStatements[depNum].push(statement);\r\n  }\r\n\r\n  addUpdateStatementsWithoutDep(statement: t.Statement) {\r\n    if (!this.updateStatements[0]) this.updateStatements[0] = [];\r\n    this.updateStatements[0].push(statement);\r\n  }\r\n\r\n  /**\r\n   * @returns [initStatements, updateStatements, classProperties, nodeName]\r\n   */\r\n  generate(): [t.Statement[], Record<number, t.Statement[]>, t.ClassProperty[], string] {\r\n    const nodeName = this.run();\r\n    return [this.initStatements, this.updateStatements, this.classProperties, nodeName];\r\n  }\r\n\r\n  /**\r\n   * @brief Generate the view given the view particles, mainly used for child particles parsing\r\n   * @param viewParticles\r\n   * @param mergeStatements\r\n   * @returns [initStatements, topLevelNodes, updateStatements]\r\n   */\r\n  generateChildren(\r\n    viewParticles: ViewParticle[],\r\n    mergeStatements = true,\r\n    newIdx = false\r\n  ): [t.Statement[], string[], Record<number, t.Statement[]>, number] {\r\n    this.viewGenerator.nodeIdx = newIdx ? -1 : this.nodeIdx;\r\n    this.viewGenerator.templateIdx = this.templateIdx;\r\n    const [initStatements, updateStatements, classProperties, topLevelNodes] =\r\n      this.viewGenerator.generateChildren(viewParticles);\r\n    if (!newIdx) this.nodeIdx = this.viewGenerator.nodeIdx;\r\n    this.templateIdx = this.viewGenerator.templateIdx;\r\n    this.classProperties.push(...classProperties);\r\n    if (mergeStatements) this.mergeStatements(updateStatements);\r\n\r\n    return [initStatements, topLevelNodes, updateStatements, this.viewGenerator.nodeIdx];\r\n  }\r\n\r\n  /**\r\n   * @brief Merge the update statements\r\n   * @param statements\r\n   */\r\n  private mergeStatements(statements: Record<number, t.Statement[]>): void {\r\n    Object.entries(statements).forEach(([depNum, statements]) => {\r\n      if (!this.updateStatements[Number(depNum)]) {\r\n        this.updateStatements[Number(depNum)] = [];\r\n      }\r\n      this.updateStatements[Number(depNum)].push(...statements);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @brief Generate the view given the view particle\r\n   * @param viewParticle\r\n   * @param mergeStatements\r\n   * @returns [initStatements, nodeName, updateStatements]\r\n   */\r\n  generateChild(\r\n    viewParticle: ViewParticle,\r\n    mergeStatements = true,\r\n    newIdx = false\r\n  ): [t.Statement[], string, Record<number, t.Statement[]>, number] {\r\n    this.viewGenerator.nodeIdx = newIdx ? -1 : this.nodeIdx;\r\n    this.viewGenerator.templateIdx = this.templateIdx;\r\n    const [initStatements, updateStatements, classProperties, nodeName] =\r\n      this.viewGenerator.generateChild(viewParticle);\r\n    if (!newIdx) this.nodeIdx = this.viewGenerator.nodeIdx;\r\n    this.templateIdx = this.viewGenerator.templateIdx;\r\n    this.classProperties.push(...classProperties);\r\n    if (mergeStatements) this.mergeStatements(updateStatements);\r\n\r\n    return [initStatements, nodeName, updateStatements, this.viewGenerator.nodeIdx];\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * const $update = (changed) => { ${updateStatements} }\r\n   */\r\n  geneUpdateFunc(updateStatements: Record<number, t.Statement[]>): t.Statement {\r\n    return this.t.variableDeclaration('const', [\r\n      this.t.variableDeclarator(\r\n        this.t.identifier('$update'),\r\n        this.t.arrowFunctionExpression([this.t.identifier('$changed')], this.geneUpdateBody(updateStatements))\r\n      ),\r\n    ]);\r\n  }\r\n\r\n  get updateParams() {\r\n    return [this.t.identifier('$changed')];\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * (changed) => {\r\n   *   if (changed & 1) {\r\n   *     ...\r\n   *   }\r\n   *   ...\r\n   * }\r\n   */\r\n  geneUpdateBody(updateStatements: Record<number, t.Statement[]>): t.BlockStatement {\r\n    return this.t.blockStatement([\r\n      ...Object.entries(updateStatements)\r\n        .filter(([depNum]) => depNum !== '0')\r\n        .map(([depNum, statements]) => {\r\n          return this.t.ifStatement(\r\n            this.t.binaryExpression('&', this.t.identifier('$changed'), this.t.numericLiteral(Number(depNum))),\r\n            this.t.blockStatement(statements)\r\n          );\r\n        }),\r\n      ...(updateStatements[0] ?? []),\r\n    ]);\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * let node1, node2, ...\r\n   */\r\n  declareNodes(nodeIdx: number): t.VariableDeclaration[] {\r\n    if (nodeIdx === -1) return [];\r\n    return [\r\n      this.t.variableDeclaration(\r\n        'let',\r\n        Array.from({ length: nodeIdx + 1 }, (_, i) =>\r\n          this.t.variableDeclarator(this.t.identifier(`${prefixMap.node}${i}`))\r\n        )\r\n      ),\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * return [${topLevelNodes}]\r\n   */\r\n  generateReturnStatement(topLevelNodes: string[]): t.ReturnStatement {\r\n    return this.t.returnStatement(this.t.arrayExpression(topLevelNodes.map(name => this.t.identifier(name))));\r\n  }\r\n\r\n  /**\r\n   * @brief To be implemented by the subclass as the main node generation function\r\n   * @returns dlNodeName\r\n   */\r\n  run(): string {\r\n    return '';\r\n  }\r\n\r\n  // ---- Name ----\r\n  // ---- Used as dlNodeName for any node declaration\r\n  nodeIdx = -1;\r\n  generateNodeName(idx?: number): string {\r\n    return `${prefixMap.node}${idx ?? ++this.nodeIdx}`;\r\n  }\r\n\r\n  // ---- Used as template generation as class property\r\n  templateIdx = -1;\r\n  generateTemplateName(): string {\r\n    return `${prefixMap.template}${++this.templateIdx}`;\r\n  }\r\n\r\n  // ---- @Utils -----\r\n  /**\r\n   *\r\n   * @param updateStatements\r\n   * @returns\r\n   */\r\n\r\n  /**\r\n   * @brief Calculate the dependency number from an array of dependency index\r\n   *  e.g.\r\n   *    [0, 1, 2] => 0b111 => 7\r\n   *    [1, 3] => 0b1010 => 10\r\n   * @param dependencies\r\n   * @returns dependency number\r\n   */\r\n  static calcDependencyNum(dependencies: number[] | undefined): number {\r\n    if (!dependencies || dependencies.length === 0) return 0;\r\n    dependencies = [...new Set(dependencies)];\r\n    return dependencies.reduce((acc, dep) => acc + (1 << dep), 0);\r\n  }\r\n\r\n  /**\r\n   * @brief Wrap the value in a file\r\n   * @param node\r\n   * @returns wrapped value\r\n   */\r\n  valueWrapper(node: t.Expression | t.Statement): t.File {\r\n    return this.t.file(this.t.program([this.t.isStatement(node) ? node : this.t.expressionStatement(node)]));\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName} && ${expression}\r\n   */\r\n  optionalExpression(dlNodeName: string, expression: t.Expression): t.Statement {\r\n    return this.t.expressionStatement(this.t.logicalExpression('&&', this.t.identifier(dlNodeName), expression));\r\n  }\r\n\r\n  /**\r\n   * @brief Shorthand function for collecting statements in batch\r\n   * @returns [statements, collect]\r\n   */\r\n  static statementsCollector(): [t.Statement[], (...statements: t.Statement[] | t.Statement[][]) => void] {\r\n    const statements: t.Statement[] = [];\r\n    const collect = (...newStatements: t.Statement[] | t.Statement[][]) => {\r\n      newStatements.forEach(s => {\r\n        if (Array.isArray(s)) {\r\n          statements.push(...s);\r\n        } else {\r\n          statements.push(s);\r\n        }\r\n      });\r\n    };\r\n\r\n    return [statements, collect];\r\n  }\r\n}\r\n","import { type types as t } from '@babel/core';\r\nimport BaseGenerator from './BaseGenerator';\r\n\r\nexport default class LifecycleGenerator extends BaseGenerator {\r\n  static lifecycle = ['willMount', 'didMount', 'willUnmount', 'didUnmount'] as const;\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName} && ${value}(${dlNodeName}, changed)\r\n   */\r\n  addOnUpdate(dlNodeName: string, value: t.Expression): t.Statement {\r\n    return this.t.expressionStatement(\r\n      this.t.logicalExpression(\r\n        '&&',\r\n        this.t.identifier(dlNodeName),\r\n        this.t.callExpression(value, [this.t.identifier(dlNodeName), ...this.updateParams.slice(1)])\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * willMount:\r\n   *  - ${value}(${dlNodeName})\r\n   * didMount/willUnmount/didUnmount:\r\n   *  - View.addDidMount(${dlNodeName}, ${value})\r\n   */\r\n  addLifecycle(\r\n    dlNodeName: string,\r\n    key: (typeof LifecycleGenerator.lifecycle)[number],\r\n    value: t.Expression\r\n  ): t.Statement {\r\n    if (key === 'willMount') {\r\n      return this.addWillMount(dlNodeName, value);\r\n    }\r\n    return this.addOtherLifecycle(dlNodeName, value, key);\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${value}(${dlNodeName})\r\n   */\r\n  addWillMount(dlNodeName: string, value: t.Expression): t.ExpressionStatement {\r\n    return this.t.expressionStatement(this.t.callExpression(value, [this.t.identifier(dlNodeName)]));\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * View.addDidMount(${dlNodeName}, ${value})\r\n   */\r\n  addOtherLifecycle(\r\n    dlNodeName: string,\r\n    value: t.Expression,\r\n    type: 'didMount' | 'willUnmount' | 'didUnmount'\r\n  ): t.ExpressionStatement {\r\n    return this.t.expressionStatement(\r\n      this.t.callExpression(\r\n        this.t.memberExpression(\r\n          this.t.identifier('View'),\r\n          this.t.identifier(`add${type[0].toUpperCase()}${type.slice(1)}`)\r\n        ),\r\n        [this.t.identifier(dlNodeName), value]\r\n      )\r\n    );\r\n  }\r\n}\r\n","import { type types as t } from '@babel/core';\r\nimport { type DependencyProp, type ViewParticle } from '@inula/reactivity-parser';\r\nimport LifecycleGenerator from './LifecycleGenerator';\r\n\r\nexport default class PropViewGenerator extends LifecycleGenerator {\r\n  /**\r\n   * @brief Alter prop view in batch\r\n   * @param props\r\n   * @returns altered props\r\n   */\r\n  alterPropViews<T extends Record<string, DependencyProp> | undefined>(props: T): T {\r\n    if (!props) return props;\r\n    return Object.fromEntries(\r\n      Object.entries(props).map(([key, prop]) => {\r\n        return [key, this.alterPropView(prop)!];\r\n      })\r\n    ) as T;\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName} = new PropView(($addUpdate) => {\r\n   *  addUpdate((changed) => { ${updateStatements} })\r\n   *  ${initStatements}\r\n   *  return ${topLevelNodes}\r\n   * })\r\n   */\r\n  declarePropView(viewParticles: ViewParticle[]) {\r\n    // ---- Generate PropView\r\n    const [initStatements, topLevelNodes, updateStatements, nodeIdx] = this.generateChildren(\r\n      viewParticles,\r\n      false,\r\n      true\r\n    );\r\n    // ---- Add update function to the first node\r\n    /**\r\n     * $addUpdate((changed) => { ${updateStatements} })\r\n     */\r\n    if (Object.keys(updateStatements).length > 0) {\r\n      initStatements.unshift(\r\n        this.t.expressionStatement(\r\n          this.t.callExpression(this.t.identifier('$addUpdate'), [\r\n            this.t.arrowFunctionExpression(this.updateParams, this.geneUpdateBody(updateStatements)),\r\n          ])\r\n        )\r\n      );\r\n    }\r\n    initStatements.unshift(...this.declareNodes(nodeIdx));\r\n    initStatements.push(this.generateReturnStatement(topLevelNodes));\r\n\r\n    // ---- Assign as a dlNode\r\n    const dlNodeName = this.generateNodeName();\r\n    const propViewNode = this.t.expressionStatement(\r\n      this.t.assignmentExpression(\r\n        '=',\r\n        this.t.identifier(dlNodeName),\r\n        this.t.newExpression(this.t.identifier(this.importMap.PropView), [\r\n          this.t.arrowFunctionExpression([this.t.identifier('$addUpdate')], this.t.blockStatement(initStatements)),\r\n        ])\r\n      )\r\n    );\r\n    this.addInitStatement(propViewNode);\r\n    const propViewIdentifier = this.t.identifier(dlNodeName);\r\n\r\n    // ---- Add to update statements\r\n    /**\r\n     * ${dlNodeName}?.update(changed)\r\n     */\r\n    this.addUpdateStatementsWithoutDep(\r\n      this.optionalExpression(\r\n        dlNodeName,\r\n        this.t.callExpression(\r\n          this.t.memberExpression(propViewIdentifier, this.t.identifier('update')),\r\n          this.updateParams\r\n        )\r\n      )\r\n    );\r\n\r\n    return dlNodeName;\r\n  }\r\n\r\n  /**\r\n   * @brief Alter prop view by replacing prop view with a recursively generated prop view\r\n   * @param prop\r\n   * @returns altered prop\r\n   */\r\n  alterPropView<T extends DependencyProp | undefined>(prop: T): T {\r\n    if (!prop) return prop;\r\n    const { value, viewPropMap } = prop;\r\n    if (!viewPropMap) return { ...prop, value };\r\n    let newValue = value;\r\n    this.traverse(this.valueWrapper(value), {\r\n      StringLiteral: innerPath => {\r\n        const id = innerPath.node.value;\r\n        const viewParticles = viewPropMap[id];\r\n        if (!viewParticles) return;\r\n        const propViewIdentifier = this.t.identifier(this.declarePropView(viewParticles));\r\n\r\n        if (value === innerPath.node) newValue = propViewIdentifier;\r\n        innerPath.replaceWith(propViewIdentifier);\r\n        innerPath.skip();\r\n      },\r\n    });\r\n    return { ...prop, value: newValue };\r\n  }\r\n\r\n  /**\r\n   * @brief Get the dependency index array from the update statements' keys\r\n   *  i.e. [1, 2, 7] => [0b1, 0b10, 0b111] => [[1], [2], [0, 1, 2]] => [0, 1, 2]\r\n   * @param updateStatements\r\n   * @returns dependency index array\r\n   */\r\n  private static reverseDependencyIndexArr(updateStatements: Record<number, t.Statement[]>): number[] {\r\n    const allDepsNum = Object.keys(updateStatements)\r\n      .map(Number)\r\n      .reduce((acc, depNum) => acc | depNum, 0);\r\n    const allDeps = [];\r\n    for (let i = 0; i < String(allDepsNum).length; i++) {\r\n      if (allDepsNum & (1 << i)) allDeps.push(i);\r\n    }\r\n    return allDeps;\r\n  }\r\n}\r\n","import { type types as t } from '@babel/core';\r\nimport PropViewGenerator from './PropViewGenerator';\r\n\r\nexport default class ElementGenerator extends PropViewGenerator {\r\n  /**\r\n   * @View\r\n   * el:\r\n   * View.addDidMount(${dlNodeName}, () => (\r\n   *   typeof ${value} === \"function\" ? ${value}($nodeEl) : ${value} = $nodeEl\r\n   * ))\r\n   * not el:\r\n   * typeof ${value} === \"function\" ? ${value}($nodeEl) : ${value} = $nodeEl\r\n   * @param el true: dlNodeName._$el, false: dlNodeName\r\n   */\r\n  initElement(dlNodeName: string, value: t.Expression, el = false): t.Statement {\r\n    const elNode = el\r\n      ? this.t.memberExpression(this.t.identifier(dlNodeName), this.t.identifier('_$el'))\r\n      : this.t.identifier(dlNodeName);\r\n    let elementNode;\r\n    if (this.isOnlyMemberExpression(value)) {\r\n      elementNode = this.t.conditionalExpression(\r\n        this.t.binaryExpression('===', this.t.unaryExpression('typeof', value, true), this.t.stringLiteral('function')),\r\n        this.t.callExpression(value, [elNode]),\r\n        this.t.assignmentExpression('=', value as t.LVal, elNode)\r\n      );\r\n    } else {\r\n      elementNode = this.t.callExpression(value, [elNode]);\r\n    }\r\n\r\n    return el\r\n      ? this.t.expressionStatement(\r\n          this.t.callExpression(this.t.memberExpression(this.t.identifier('View'), this.t.identifier('addDidMount')), [\r\n            this.t.identifier(dlNodeName),\r\n            this.t.arrowFunctionExpression([], elementNode),\r\n          ])\r\n        )\r\n      : this.t.expressionStatement(elementNode);\r\n  }\r\n\r\n  // --- Utils\r\n  private isOnlyMemberExpression(value: t.Expression): boolean {\r\n    if (!this.t.isMemberExpression(value)) return false;\r\n    while (value.property) {\r\n      if (this.t.isMemberExpression(value.property)) {\r\n        value = value.property;\r\n        continue;\r\n      } else if (this.t.isIdentifier(value.property)) break;\r\n      else return false;\r\n    }\r\n    return true;\r\n  }\r\n}\r\n","import { type types as t } from '@babel/core';\r\nimport ElementGenerator from './ElementGenerator';\r\n\r\nexport default class ForwardPropsGenerator extends ElementGenerator {\r\n  /**\r\n   * @View\r\n   * this._$forwardProp(${dlNodeName})\r\n   */\r\n  forwardProps(dlNodeName: string): t.ExpressionStatement {\r\n    return this.t.expressionStatement(\r\n      this.t.callExpression(this.t.memberExpression(this.t.thisExpression(), this.t.identifier('_$addForwardProps')), [\r\n        this.t.identifier(dlNodeName),\r\n      ])\r\n    );\r\n  }\r\n}\r\n","import { type types as t } from '@babel/core';\r\nimport { type DependencyProp, type CompParticle, type ViewParticle } from '@inula/reactivity-parser';\r\nimport ForwardPropGenerator from '../HelperGenerators/ForwardPropGenerator';\r\n\r\nexport default class CompGenerator extends ForwardPropGenerator {\r\n  run() {\r\n    let { props } = this.viewParticle as CompParticle;\r\n    props = this.alterPropViews(props);\r\n    const { tag, children } = this.viewParticle as CompParticle;\r\n\r\n    const dlNodeName = this.generateNodeName();\r\n\r\n    this.addInitStatement(...this.declareCompNode(dlNodeName, tag, props, children));\r\n    const allDependencyIndexArr: number[] = [];\r\n\r\n    // ---- Resolve props\r\n    Object.entries(props).forEach(([key, { value, dependencyIndexArr, dependenciesNode }]) => {\r\n      if (key === 'forwardProps') return;\r\n      if (key === 'didUpdate') return;\r\n      allDependencyIndexArr.push(...dependencyIndexArr);\r\n      if (CompGenerator.lifecycle.includes(key as (typeof CompGenerator.lifecycle)[number])) {\r\n        this.addInitStatement(this.addLifecycle(dlNodeName, key as (typeof CompGenerator.lifecycle)[number], value));\r\n        return;\r\n      }\r\n      if (key === 'ref') {\r\n        this.addInitStatement(this.initElement(dlNodeName, value));\r\n        return;\r\n      }\r\n      if (key === 'elements') {\r\n        this.addInitStatement(this.initElement(dlNodeName, value, true));\r\n        return;\r\n      }\r\n      if (key === '_$content') {\r\n        this.addUpdateStatements(dependencyIndexArr, this.setCompContent(dlNodeName, value, dependenciesNode));\r\n        return;\r\n      }\r\n      if (key === 'props') {\r\n        this.addUpdateStatements(dependencyIndexArr, this.setCompProps(dlNodeName, value, dependenciesNode));\r\n        return;\r\n      }\r\n\r\n      this.addUpdateStatements(dependencyIndexArr, this.setCompProp(dlNodeName, key, value, dependenciesNode));\r\n    });\r\n\r\n    // ---- Add addUpdate last\r\n    if (props.didUpdate) {\r\n      this.addUpdateStatements(allDependencyIndexArr, this.addOnUpdate(dlNodeName, props.didUpdate.value));\r\n    }\r\n\r\n    return dlNodeName;\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * null\r\n   *  or\r\n   * [[prop1, value1, deps1], [prop2, value2, deps2], ...\r\n   */\r\n  private generateCompProps(props: Record<string, DependencyProp>): t.Expression {\r\n    if (Object.keys(props).length === 0) return this.t.nullLiteral();\r\n    return this.t.arrayExpression(\r\n      Object.entries(props).map(([key, { value, dependenciesNode }]) => {\r\n        return this.t.arrayExpression([this.t.stringLiteral(key), value, dependenciesNode]);\r\n      })\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName} = new ${tag}()\r\n   * ${dlNodeName}._$init(${props}, ${content}, ${children}, ${this})\r\n   */\r\n  private declareCompNode(\r\n    dlNodeName: string,\r\n    tag: t.Expression,\r\n    props: Record<string, DependencyProp>,\r\n    children: ViewParticle[]\r\n  ): t.Statement[] {\r\n    const willForwardProps = 'forwardProps' in props;\r\n    const newProps = Object.fromEntries(\r\n      Object.entries(props).filter(\r\n        ([key]) =>\r\n          !['ref', 'elements', 'forwardProps', '_$content', 'didUpdate', 'props', ...CompGenerator.lifecycle].includes(\r\n            key\r\n          )\r\n      )\r\n    );\r\n\r\n    const content = props._$content;\r\n\r\n    return [\r\n      this.t.expressionStatement(\r\n        this.t.assignmentExpression('=', this.t.identifier(dlNodeName), this.t.newExpression(tag, []))\r\n      ),\r\n      this.t.expressionStatement(\r\n        this.t.callExpression(this.t.memberExpression(this.t.identifier(dlNodeName), this.t.identifier('_$init')), [\r\n          this.generateCompProps(newProps),\r\n          content ? this.t.arrayExpression([content.value, content.dependenciesNode]) : this.t.nullLiteral(),\r\n          children.length > 0 ? this.t.identifier(this.declarePropView(children)) : this.t.nullLiteral(),\r\n          willForwardProps ? this.t.identifier('this') : this.t.nullLiteral(),\r\n        ])\r\n      ),\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName}._$setContent(() => ${value}, ${dependenciesNode})\r\n   */\r\n  private setCompContent(dlNodeName: string, value: t.Expression, dependenciesNode: t.ArrayExpression): t.Statement {\r\n    return this.optionalExpression(\r\n      dlNodeName,\r\n      this.t.callExpression(this.t.memberExpression(this.t.identifier(dlNodeName), this.t.identifier('_$setContent')), [\r\n        this.t.arrowFunctionExpression([], value),\r\n        dependenciesNode,\r\n      ])\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName}._$setProp(${key}, () => ${value}, ${dependenciesNode})\r\n   */\r\n  private setCompProp(\r\n    dlNodeName: string,\r\n    key: string,\r\n    value: t.Expression,\r\n    dependenciesNode: t.ArrayExpression\r\n  ): t.Statement {\r\n    return this.optionalExpression(\r\n      dlNodeName,\r\n      this.t.callExpression(this.t.memberExpression(this.t.identifier(dlNodeName), this.t.identifier('_$setProp')), [\r\n        this.t.stringLiteral(key),\r\n        this.t.arrowFunctionExpression([], value),\r\n        dependenciesNode,\r\n      ])\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName}._$setProps(() => ${value}, ${dependenciesNode})\r\n   */\r\n  private setCompProps(dlNodeName: string, value: t.Expression, dependenciesNode: t.ArrayExpression): t.Statement {\r\n    return this.optionalExpression(\r\n      dlNodeName,\r\n      this.t.callExpression(this.t.memberExpression(this.t.identifier(dlNodeName), this.t.identifier('_$setProps')), [\r\n        this.t.arrowFunctionExpression([], value),\r\n        dependenciesNode,\r\n      ])\r\n    );\r\n  }\r\n}\r\n","import { createErrorHandler } from '@inula/error-handler';\r\n\r\nexport const DLError = createErrorHandler(\r\n  'ViewGenerator',\r\n  {\r\n    1: 'Element prop in HTML should be a function or an identifier',\r\n    2: 'Unrecognized HTML common prop',\r\n    3: 'Do prop only accepts function or arrow function',\r\n  },\r\n  {},\r\n  {\r\n    1: 'ExpressionNode only supports prop as element and lifecycle, receiving $0',\r\n  }\r\n);\r\n","import { type types as t } from '@babel/core';\r\nimport { DLError } from '../error';\r\nimport ForwardPropGenerator from './ForwardPropGenerator';\r\n\r\nexport default class HTMLPropGenerator extends ForwardPropGenerator {\r\n  static DelegatedEvents = new Set([\r\n    'beforeinput',\r\n    'click',\r\n    'dblclick',\r\n    'contextmenu',\r\n    'focusin',\r\n    'focusout',\r\n    'input',\r\n    'keydown',\r\n    'keyup',\r\n    'mousedown',\r\n    'mousemove',\r\n    'mouseout',\r\n    'mouseover',\r\n    'mouseup',\r\n    'pointerdown',\r\n    'pointermove',\r\n    'pointerout',\r\n    'pointerover',\r\n    'pointerup',\r\n    'touchend',\r\n    'touchmove',\r\n    'touchstart',\r\n  ]);\r\n\r\n  /**\r\n   * @brief Add any HTML props according to the key\r\n   * @param name\r\n   * @param tag\r\n   * @param key\r\n   * @param value\r\n   * @param dependencyIndexArr\r\n   * @returns t.Statement\r\n   */\r\n  addHTMLProp(\r\n    name: string,\r\n    tag: string,\r\n    key: string,\r\n    value: t.Expression,\r\n    dynamic: boolean,\r\n    dependencyIndexArr: number[],\r\n    dependenciesNode: t.ArrayExpression\r\n  ): t.Statement | null {\r\n    // ---- Dynamic HTML prop with init and update\r\n    if (dynamic) {\r\n      this.addUpdateStatements(\r\n        dependencyIndexArr,\r\n        this.setDynamicHTMLProp(name, tag, key, value, dependenciesNode, true)\r\n      );\r\n      return this.setDynamicHTMLProp(name, tag, key, value, dependenciesNode, false);\r\n    }\r\n    // ---- Static HTML prop with init only\r\n    return this.setStaticHTMLProp(name, tag, key, value);\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * insertNode(${dlNodeName}, ${childNodeName}, ${position})\r\n   */\r\n  insertNode(dlNodeName: string, childNodeName: string, position: number): t.ExpressionStatement {\r\n    return this.t.expressionStatement(\r\n      this.t.callExpression(this.t.identifier(this.importMap.insertNode), [\r\n        this.t.identifier(dlNodeName),\r\n        this.t.identifier(childNodeName),\r\n        this.t.numericLiteral(position),\r\n      ])\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName} && ${expression}\r\n   */\r\n  private setPropWithCheck(dlNodeName: string, expression: t.Expression, check: boolean): t.Statement {\r\n    if (check) {\r\n      return this.optionalExpression(dlNodeName, expression);\r\n    }\r\n    return this.t.expressionStatement(expression);\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * setStyle(${dlNodeName}, ${value})\r\n   */\r\n  private setHTMLStyle(dlNodeName: string, value: t.Expression, check: boolean): t.Statement {\r\n    return this.setPropWithCheck(\r\n      dlNodeName,\r\n      this.t.callExpression(this.t.identifier(this.importMap.setStyle), [this.t.identifier(dlNodeName), value]),\r\n      check\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * setStyle(${dlNodeName}, ${value})\r\n   */\r\n  private setHTMLDataset(dlNodeName: string, value: t.Expression, check: boolean): t.Statement {\r\n    return this.setPropWithCheck(\r\n      dlNodeName,\r\n      this.t.callExpression(this.t.identifier(this.importMap.setDataset), [this.t.identifier(dlNodeName), value]),\r\n      check\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName}.${key} = ${value}\r\n   */\r\n  private setHTMLProp(dlNodeName: string, key: string, value: t.Expression): t.Statement {\r\n    return this.t.expressionStatement(\r\n      this.t.assignmentExpression(\r\n        '=',\r\n        this.t.memberExpression(this.t.identifier(dlNodeName), this.t.identifier(key)),\r\n        value\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName}.setAttribute(${key}, ${value})\r\n   */\r\n  private setHTMLAttr(dlNodeName: string, key: string, value: t.Expression): t.Statement {\r\n    return this.t.expressionStatement(\r\n      this.t.callExpression(this.t.memberExpression(this.t.identifier(dlNodeName), this.t.identifier('setAttribute')), [\r\n        this.t.stringLiteral(key),\r\n        value,\r\n      ])\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName}.addEventListener(${key}, ${value})\r\n   */\r\n  private setHTMLEvent(dlNodeName: string, key: string, value: t.Expression): t.Statement {\r\n    return this.t.expressionStatement(\r\n      this.t.callExpression(\r\n        this.t.memberExpression(this.t.identifier(dlNodeName), this.t.identifier('addEventListener')),\r\n        [this.t.stringLiteral(key), value]\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * setEvent(${dlNodeName}, ${key}, ${value})\r\n   */\r\n  private setEvent(dlNodeName: string, key: string, value: t.Expression, check: boolean): t.Statement {\r\n    return this.setPropWithCheck(\r\n      dlNodeName,\r\n      this.t.callExpression(this.t.identifier(this.importMap.setEvent), [\r\n        this.t.identifier(dlNodeName),\r\n        this.t.stringLiteral(key),\r\n        value,\r\n      ]),\r\n      check\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * delegateEvent(${dlNodeName}, ${key}, ${value})\r\n   */\r\n  private delegateEvent(dlNodeName: string, key: string, value: t.Expression, check: boolean): t.Statement {\r\n    return this.setPropWithCheck(\r\n      dlNodeName,\r\n      this.t.callExpression(this.t.identifier(this.importMap.delegateEvent), [\r\n        this.t.identifier(dlNodeName),\r\n        this.t.stringLiteral(key),\r\n        value,\r\n      ]),\r\n      check\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * setHTMLProp(${dlNodeName}, ${key}, ${valueFunc}, ${dependenciesNode})\r\n   */\r\n  private setCachedProp(\r\n    dlNodeName: string,\r\n    key: string,\r\n    value: t.Expression,\r\n    dependenciesNode: t.ArrayExpression,\r\n    check: boolean\r\n  ): t.Statement {\r\n    return this.setPropWithCheck(\r\n      dlNodeName,\r\n      this.t.callExpression(this.t.identifier(this.importMap.setHTMLProp), [\r\n        this.t.identifier(dlNodeName),\r\n        this.t.stringLiteral(key),\r\n        this.t.arrowFunctionExpression([], value),\r\n        dependenciesNode,\r\n      ]),\r\n      check\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * setHTMLAttr(${dlNodeName}, ${key}, ${valueFunc}, ${dependenciesNode}, ${check})\r\n   */\r\n  private setCachedAttr(\r\n    dlNodeName: string,\r\n    key: string,\r\n    value: t.Expression,\r\n    dependenciesNode: t.ArrayExpression,\r\n    check: boolean\r\n  ): t.Statement {\r\n    return this.setPropWithCheck(\r\n      dlNodeName,\r\n      this.t.callExpression(this.t.identifier(this.importMap.setHTMLAttr), [\r\n        this.t.identifier(dlNodeName),\r\n        this.t.stringLiteral(key),\r\n        this.t.arrowFunctionExpression([], value),\r\n        dependenciesNode,\r\n      ]),\r\n      check\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * setHTMLProps(${dlNodeName}, ${value})\r\n   */\r\n  private setHTMLPropObject(dlNodeName: string, value: t.Expression, check: boolean): t.Statement {\r\n    return this.setPropWithCheck(\r\n      dlNodeName,\r\n      this.t.callExpression(this.t.identifier(this.importMap.setHTMLProps), [this.t.identifier(dlNodeName), value]),\r\n      check\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * setHTMLAttrs(${dlNodeName}, ${value})\r\n   */\r\n  private setHTMLAttrObject(dlNodeName: string, value: t.Expression, check: boolean): t.Statement {\r\n    return this.setPropWithCheck(\r\n      dlNodeName,\r\n      this.t.callExpression(this.t.identifier(this.importMap.setHTMLAttrs), [this.t.identifier(dlNodeName), value]),\r\n      check\r\n    );\r\n  }\r\n\r\n  private static commonHTMLPropKeys = [\r\n    'style',\r\n    'dataset',\r\n    'props',\r\n    'ref',\r\n    'attrs',\r\n    'forwardProps',\r\n    ...HTMLPropGenerator.lifecycle,\r\n  ];\r\n\r\n  /**\r\n   * For style/dataset/ref/attr/prop\r\n   */\r\n  private addCommonHTMLProp(\r\n    dlNodeName: string,\r\n    attrName: string,\r\n    value: t.Expression,\r\n    check: boolean\r\n  ): t.Statement | null {\r\n    if (HTMLPropGenerator.lifecycle.includes(attrName as (typeof HTMLPropGenerator.lifecycle)[number])) {\r\n      if (!check) return this.addLifecycle(dlNodeName, attrName as (typeof HTMLPropGenerator.lifecycle)[number], value);\r\n      return null;\r\n    }\r\n    if (attrName === 'ref') {\r\n      if (!check) return this.initElement(dlNodeName, value);\r\n      return null;\r\n    }\r\n    if (attrName === 'style') return this.setHTMLStyle(dlNodeName, value, check);\r\n    if (attrName === 'dataset') return this.setHTMLDataset(dlNodeName, value, check);\r\n    if (attrName === 'props') return this.setHTMLPropObject(dlNodeName, value, check);\r\n    if (attrName === 'attrs') return this.setHTMLAttrObject(dlNodeName, value, check);\r\n    if (attrName === 'forwardProps') return this.forwardProps(dlNodeName);\r\n    return DLError.throw2();\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * 1. Event listener\r\n   *  - ${dlNodeName}.addEventListener(${key}, ${value})\r\n   * 2. HTML internal attribute -> DOM property\r\n   *  - ${dlNodeName}.${key} = ${value}\r\n   * 3. HTML custom attribute\r\n   *  - ${dlNodeName}.setAttribute(${key}, ${value})\r\n   */\r\n  private setStaticHTMLProp(\r\n    dlNodeName: string,\r\n    tag: string,\r\n    attrName: string,\r\n    value: t.Expression\r\n  ): t.Statement | null {\r\n    if (HTMLPropGenerator.commonHTMLPropKeys.includes(attrName))\r\n      return this.addCommonHTMLProp(dlNodeName, attrName, value, false);\r\n    if (attrName.startsWith('on')) {\r\n      const eventName = attrName.slice(2).toLowerCase();\r\n      if (HTMLPropGenerator.DelegatedEvents.has(eventName)) {\r\n        return this.delegateEvent(dlNodeName, eventName, value, false);\r\n      }\r\n      return this.setHTMLEvent(dlNodeName, eventName, value);\r\n    }\r\n    if (this.isInternalAttribute(tag, attrName)) {\r\n      if (attrName === 'class') attrName = 'className';\r\n      else if (attrName === 'for') attrName = 'htmlFor';\r\n      return this.setHTMLProp(dlNodeName, attrName, value);\r\n    }\r\n    return this.setHTMLAttr(dlNodeName, attrName, value);\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * 1. Event listener\r\n   *  - ${setEvent}(${dlNodeName}, ${key}, ${value})\r\n   * 2. HTML internal attribute -> DOM property\r\n   *  - ${setHTMLProp}(${dlNodeName}, ${key}, ${value})\r\n   * 3. HTML custom attribute\r\n   *  - ${setHTMLAttr}(${dlNodeName}, ${key}, ${value})\r\n   */\r\n  private setDynamicHTMLProp(\r\n    dlNodeName: string,\r\n    tag: string,\r\n    attrName: string,\r\n    value: t.Expression,\r\n    dependenciesNode: t.ArrayExpression,\r\n    check: boolean\r\n  ): t.Statement | null {\r\n    if (HTMLPropGenerator.commonHTMLPropKeys.includes(attrName))\r\n      return this.addCommonHTMLProp(dlNodeName, attrName, value, check);\r\n    if (attrName.startsWith('on')) {\r\n      const eventName = attrName.slice(2).toLowerCase();\r\n      if (HTMLPropGenerator.DelegatedEvents.has(eventName)) {\r\n        return this.delegateEvent(dlNodeName, eventName, value, check);\r\n      }\r\n      return this.setEvent(dlNodeName, eventName, value, check);\r\n    }\r\n    if (this.alterAttributeMap[attrName]) {\r\n      attrName = this.alterAttributeMap[attrName];\r\n    }\r\n    if (this.isInternalAttribute(tag, attrName)) {\r\n      return this.setCachedProp(dlNodeName, attrName, value, dependenciesNode, check);\r\n    }\r\n    return this.setCachedAttr(dlNodeName, attrName, value, dependenciesNode, check);\r\n  }\r\n\r\n  /**\r\n   * @brief Check if the attribute is internal, i.e., can be accessed as js property\r\n   * @param tag\r\n   * @param attribute\r\n   * @returns true if the attribute is internal\r\n   */\r\n  isInternalAttribute(tag: string, attribute: string): boolean {\r\n    return this.elementAttributeMap['*']?.includes(attribute) || this.elementAttributeMap[tag]?.includes(attribute);\r\n  }\r\n}\r\n","import { type types as t } from '@babel/core';\r\nimport { type HTMLParticle } from '@inula/reactivity-parser';\r\nimport HTMLPropGenerator from '../HelperGenerators/HTMLPropGenerator';\r\n\r\nexport default class HTMLGenerator extends HTMLPropGenerator {\r\n  run() {\r\n    const { tag, props, children } = this.viewParticle as HTMLParticle;\r\n\r\n    const dlNodeName = this.generateNodeName();\r\n\r\n    this.addInitStatement(this.declareHTMLNode(dlNodeName, tag));\r\n\r\n    // ---- Resolve props\r\n    // ---- Use the tag name to check if the prop is internal for the tag,\r\n    //      for dynamic tag, we can't check it, so we just assume it's not internal\r\n    //      represent by the \"ANY\" tag name\r\n    const tagName = this.t.isStringLiteral(tag) ? tag.value : 'ANY';\r\n    const allDependencyIndexArr: number[] = [];\r\n    Object.entries(props).forEach(([key, { value, dependencyIndexArr, dependenciesNode, dynamic }]) => {\r\n      if (key === 'didUpdate') return;\r\n      allDependencyIndexArr.push(...(dependencyIndexArr ?? []));\r\n      this.addInitStatement(\r\n        this.addHTMLProp(dlNodeName, tagName, key, value, dynamic, dependencyIndexArr, dependenciesNode)\r\n      );\r\n    });\r\n    if (props.didUpdate) {\r\n      this.addUpdateStatements(allDependencyIndexArr, this.addOnUpdate(dlNodeName, props.didUpdate.value));\r\n    }\r\n\r\n    // ---- Resolve children\r\n    const childNames: string[] = [];\r\n    let mutable = false;\r\n    children.forEach((child, idx) => {\r\n      const [initStatements, childName] = this.generateChild(child);\r\n      childNames.push(childName);\r\n      this.addInitStatement(...initStatements);\r\n      if (child.type === 'html') {\r\n        this.addInitStatement(this.appendChild(dlNodeName, childName));\r\n      } else {\r\n        mutable = true;\r\n        this.addInitStatement(this.insertNode(dlNodeName, childName, idx));\r\n      }\r\n    });\r\n    if (mutable) this.addInitStatement(this.setHTMLNodes(dlNodeName, childNames));\r\n\r\n    return dlNodeName;\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName} = createElement(${tag})\r\n   */\r\n  private declareHTMLNode(dlNodeName: string, tag: t.Expression): t.Statement {\r\n    return this.t.expressionStatement(\r\n      this.t.assignmentExpression(\r\n        '=',\r\n        this.t.identifier(dlNodeName),\r\n        this.t.callExpression(this.t.identifier(this.importMap.createElement), [tag])\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName}._$nodes = [...${childNames}]\r\n   */\r\n  private setHTMLNodes(dlNodeName: string, childNames: string[]): t.Statement {\r\n    return this.t.expressionStatement(\r\n      this.t.assignmentExpression(\r\n        '=',\r\n        this.t.memberExpression(this.t.identifier(dlNodeName), this.t.identifier('_$nodes')),\r\n        this.t.arrayExpression(childNames.map(name => this.t.identifier(name)))\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName}.appendChild(${childNodeName})\r\n   */\r\n  private appendChild(dlNodeName: string, childNodeName: string): t.Statement {\r\n    return this.t.expressionStatement(\r\n      this.t.callExpression(this.t.memberExpression(this.t.identifier(dlNodeName), this.t.identifier('appendChild')), [\r\n        this.t.identifier(childNodeName),\r\n      ])\r\n    );\r\n  }\r\n}\r\n","import { type types as t } from '@babel/core';\r\nimport { type HTMLParticle, type TemplateParticle } from '@inula/reactivity-parser';\r\nimport HTMLPropGenerator from '../HelperGenerators/HTMLPropGenerator';\r\n\r\nexport default class TemplateGenerator extends HTMLPropGenerator {\r\n  run() {\r\n    const { template, mutableParticles, props } = this.viewParticle as TemplateParticle;\r\n\r\n    const dlNodeName = this.generateNodeName();\r\n    // ---- Add template declaration to class\r\n    const templateName = this.addTemplate(template);\r\n    // ---- Declare template node in View body\r\n    this.addInitStatement(this.declareTemplateNode(dlNodeName, templateName));\r\n\r\n    // ---- Insert elements first\r\n    const paths: number[][] = [];\r\n    props.forEach(({ path }) => {\r\n      paths.push(path);\r\n    });\r\n    mutableParticles.forEach(({ path }) => {\r\n      paths.push(path.slice(0, -1));\r\n    });\r\n    const [insertElementStatements, pathNameMap] = this.insertElements(paths, dlNodeName);\r\n    this.addInitStatement(...insertElementStatements);\r\n\r\n    // ---- Resolve props\r\n    const didUpdateMap: Record<string, { deps: number[]; value?: t.Expression }> = {};\r\n    props.forEach(({ tag, path, key, value, dependencyIndexArr, dependenciesNode, dynamic }) => {\r\n      const name = pathNameMap[path.join('.')];\r\n      if (!didUpdateMap[name])\r\n        didUpdateMap[name] = {\r\n          deps: [],\r\n        };\r\n      if (key === 'didUpdate') {\r\n        didUpdateMap[name].value = value;\r\n        return;\r\n      }\r\n\r\n      didUpdateMap[name].deps.push(...dependencyIndexArr);\r\n\r\n      this.addInitStatement(this.addHTMLProp(name, tag, key, value, dynamic, dependencyIndexArr, dependenciesNode));\r\n    });\r\n\r\n    Object.entries(didUpdateMap).forEach(([name, { deps, value }]) => {\r\n      if (!value) return;\r\n      this.addUpdateStatements(deps, this.addOnUpdate(name, value));\r\n    });\r\n\r\n    // ---- Resolve mutable particles\r\n    mutableParticles.forEach(particle => {\r\n      const path = particle.path;\r\n      // ---- Find parent htmlElement\r\n      const parentName = pathNameMap[path.slice(0, -1).join('.')];\r\n      const [initStatements, childName] = this.generateChild(particle);\r\n      this.addInitStatement(...initStatements);\r\n      this.addInitStatement(this.insertNode(parentName, childName, path[path.length - 1]));\r\n    });\r\n\r\n    return dlNodeName;\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * static ${templateName} = (() => {\r\n   *   let _$node0, _$node1, ...\r\n   *   ${template}\r\n   *\r\n   *  return _$node0\r\n   * })()\r\n   */\r\n  private addTemplate(template: HTMLParticle): string {\r\n    const templateName = this.generateTemplateName();\r\n    const [statements, nodeName, , nodeIdx] = this.generateChild(template, false, true);\r\n    this.addStaticClassProperty(\r\n      templateName,\r\n      this.t.callExpression(\r\n        this.t.arrowFunctionExpression(\r\n          [],\r\n          this.t.blockStatement([\r\n            ...this.declareNodes(nodeIdx),\r\n            ...statements,\r\n            this.t.returnStatement(this.t.identifier(nodeName)),\r\n          ])\r\n        ),\r\n        []\r\n      )\r\n    );\r\n\r\n    return templateName;\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName} = ${this.className}.${templateName}.cloneNode(true)\r\n   */\r\n  private declareTemplateNode(dlNodeName: string, templateName: string): t.Statement {\r\n    return this.t.expressionStatement(\r\n      this.t.assignmentExpression(\r\n        '=',\r\n        this.t.identifier(dlNodeName),\r\n        this.t.callExpression(\r\n          this.t.memberExpression(\r\n            this.t.memberExpression(this.t.identifier(this.className), this.t.identifier(templateName)),\r\n            this.t.identifier('cloneNode')\r\n          ),\r\n          [this.t.booleanLiteral(true)]\r\n        )\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName}.firstChild\r\n   *  or\r\n   * ${dlNodeName}.firstChild.nextSibling\r\n   *  or\r\n   * ...\r\n   * ${dlNodeName}.childNodes[${num}]\r\n   */\r\n  private insertElement(dlNodeName: string, path: number[], offset: number): t.Statement {\r\n    const newNodeName = this.generateNodeName();\r\n    if (path.length === 0) {\r\n      return this.t.expressionStatement(\r\n        this.t.assignmentExpression(\r\n          '=',\r\n          this.t.identifier(newNodeName),\r\n          Array.from({ length: offset }).reduce(\r\n            (acc: t.Expression) => this.t.memberExpression(acc, this.t.identifier('nextSibling')),\r\n            this.t.identifier(dlNodeName)\r\n          )\r\n        )\r\n      );\r\n    }\r\n    const addFirstChild = (object: t.Expression) =>\r\n      // ---- ${object}.firstChild\r\n      this.t.memberExpression(object, this.t.identifier('firstChild'));\r\n    const addSecondChild = (object: t.Expression) =>\r\n      // ---- ${object}.firstChild.nextSibling\r\n      this.t.memberExpression(addFirstChild(object), this.t.identifier('nextSibling'));\r\n    const addThirdChild = (object: t.Expression) =>\r\n      // ---- ${object}.firstChild.nextSibling.nextSibling\r\n      this.t.memberExpression(addSecondChild(object), this.t.identifier('nextSibling'));\r\n    const addOtherChild = (object: t.Expression, num: number) =>\r\n      // ---- ${object}.childNodes[${num}]\r\n      this.t.memberExpression(\r\n        this.t.memberExpression(object, this.t.identifier('childNodes')),\r\n        this.t.numericLiteral(num),\r\n        true\r\n      );\r\n    const addNextSibling = (object: t.Expression) =>\r\n      // ---- ${object}.nextSibling\r\n      this.t.memberExpression(object, this.t.identifier('nextSibling'));\r\n    return this.t.expressionStatement(\r\n      this.t.assignmentExpression(\r\n        '=',\r\n        this.t.identifier(newNodeName),\r\n        path.reduce((acc: t.Expression, cur: number, idx) => {\r\n          if (idx === 0 && offset > 0) {\r\n            for (let i = 0; i < offset; i++) acc = addNextSibling(acc);\r\n          }\r\n          if (cur === 0) return addFirstChild(acc);\r\n          if (cur === 1) return addSecondChild(acc);\r\n          if (cur === 2) return addThirdChild(acc);\r\n          return addOtherChild(acc, cur);\r\n        }, this.t.identifier(dlNodeName))\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @brief Insert elements to the template node from the paths\r\n   * @param paths\r\n   * @param dlNodeName\r\n   * @returns\r\n   */\r\n  private insertElements(paths: number[][], dlNodeName: string): [t.Statement[], Record<string, string>] {\r\n    const [statements, collect] = HTMLPropGenerator.statementsCollector();\r\n    const nameMap: Record<string, number[]> = { [dlNodeName]: [] };\r\n\r\n    const commonPrefixPaths = TemplateGenerator.pathWithCommonPrefix(paths);\r\n\r\n    commonPrefixPaths.forEach(path => {\r\n      const res = TemplateGenerator.findBestNodeAndPath(nameMap, path, dlNodeName);\r\n      const [, pat, offset] = res;\r\n      let name = res[0];\r\n\r\n      if (pat.length !== 0 || offset !== 0) {\r\n        collect(this.insertElement(name, pat, offset));\r\n        name = this.generateNodeName(this.nodeIdx);\r\n        nameMap[name] = path;\r\n      }\r\n    });\r\n    const pathNameMap = Object.fromEntries(Object.entries(nameMap).map(([name, path]) => [path.join('.'), name]));\r\n\r\n    return [statements, pathNameMap];\r\n  }\r\n\r\n  // ---- Path related\r\n  /**\r\n   * @brief Extract common prefix from paths\r\n   *  e.g.\r\n   *    [0, 1, 2, 3] + [0, 1, 2, 4] => [0, 1, 2], [0, 1, 2, 3], [0, 1, 2, 4]\r\n   *  [0, 1, 2] is the common prefix\r\n   * @param paths\r\n   * @returns paths with common prefix\r\n   */\r\n  private static pathWithCommonPrefix(paths: number[][]): number[][] {\r\n    const allPaths = [...paths];\r\n    paths.forEach(path0 => {\r\n      paths.forEach(path1 => {\r\n        if (path0 === path1) return;\r\n        for (let i = 0; i < path0.length; i++) {\r\n          if (path0[i] !== path1[i]) {\r\n            if (i !== 0) {\r\n              allPaths.push(path0.slice(0, i));\r\n            }\r\n            break;\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    // ---- Sort by length and then by first element, small to large\r\n    const sortedPaths = allPaths.sort((a, b) => {\r\n      if (a.length !== b.length) return a.length - b.length;\r\n      return a[0] - b[0];\r\n    });\r\n\r\n    // ---- Deduplicate\r\n    const deduplicatedPaths = [...new Set(sortedPaths.map(path => path.join('.')))].map(path =>\r\n      path.split('.').filter(Boolean).map(Number)\r\n    );\r\n\r\n    return deduplicatedPaths;\r\n  }\r\n\r\n  /**\r\n   * @brief Find the best node name and path for the given path by looking into the nameMap.\r\n   *  If there's a full match, return the name and an empty path\r\n   *  If there's a partly match, return the name and the remaining path\r\n   *  If there's a nextSibling match, return the name and the remaining path with sibling offset\r\n   * @param nameMap\r\n   * @param path\r\n   * @param defaultName\r\n   * @returns [name, path, siblingOffset]\r\n   */\r\n  private static findBestNodeAndPath(\r\n    nameMap: Record<string, number[]>,\r\n    path: number[],\r\n    defaultName: string\r\n  ): [string, number[], number] {\r\n    let bestMatchCount = 0;\r\n    let bestMatchName: string | undefined;\r\n    let bestHalfMatch: [string, number, number] | undefined;\r\n    Object.entries(nameMap).forEach(([name, pat]) => {\r\n      let matchCount = 0;\r\n      const pathLength = pat.length;\r\n      for (let i = 0; i < pathLength; i++) {\r\n        if (pat[i] === path[i]) matchCount++;\r\n      }\r\n      if (matchCount === pathLength - 1) {\r\n        const offset = path[pathLength - 1] - pat[pathLength - 1];\r\n        if (offset > 0 && offset <= 3) {\r\n          bestHalfMatch = [name, matchCount, offset];\r\n        }\r\n      }\r\n      if (matchCount !== pat.length) return;\r\n      if (matchCount > bestMatchCount) {\r\n        bestMatchName = name;\r\n        bestMatchCount = matchCount;\r\n      }\r\n    });\r\n    if (!bestMatchName) {\r\n      if (bestHalfMatch) {\r\n        return [bestHalfMatch[0], path.slice(bestHalfMatch[1] + 1), bestHalfMatch[2]];\r\n      }\r\n      return [defaultName, path, 0];\r\n    }\r\n    return [bestMatchName, path.slice(bestMatchCount), 0];\r\n  }\r\n}\r\n","import { type types as t } from '@babel/core';\r\nimport BaseGenerator from '../HelperGenerators/BaseGenerator';\r\nimport { type ForParticle, type ViewParticle } from '@inula/reactivity-parser';\r\n\r\nexport default class ForGenerator extends BaseGenerator {\r\n  run() {\r\n    const { item, array, key, children } = this.viewParticle as ForParticle;\r\n\r\n    const dlNodeName = this.generateNodeName();\r\n\r\n    // ---- Declare for node\r\n    this.addInitStatement(\r\n      this.declareForNode(\r\n        dlNodeName,\r\n        array.value,\r\n        item,\r\n        children,\r\n        BaseGenerator.calcDependencyNum(array.dependencyIndexArr),\r\n        key\r\n      )\r\n    );\r\n\r\n    // ---- Update statements\r\n    this.addUpdateStatements(array.dependencyIndexArr, this.updateForNode(dlNodeName, array.value, item, key));\r\n    this.addUpdateStatementsWithoutDep(this.updateForNodeItem(dlNodeName));\r\n\r\n    return dlNodeName;\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName} = new ForNode(${array}, ${depNum}, ${array}.map(${item} => ${key}),\r\n   * ((${item}, $updateArr, $idx) => {\r\n   *   $updateArr[$idx] = (changed, $item) => {\r\n   *      ${item} = $item\r\n   *      {$updateStatements}\r\n   *   })\r\n   *   ${children}\r\n   *   return [...${topLevelNodes}]\r\n   * })\r\n   */\r\n  private declareForNode(\r\n    dlNodeName: string,\r\n    array: t.Expression,\r\n    item: t.LVal,\r\n    children: ViewParticle[],\r\n    depNum: number,\r\n    key: t.Expression\r\n  ): t.Statement {\r\n    // ---- NodeFunc\r\n    const [childStatements, topLevelNodes, updateStatements, nodeIdx] = this.generateChildren(children, false, true);\r\n\r\n    // ---- Update func\r\n    childStatements.unshift(\r\n      ...this.declareNodes(nodeIdx),\r\n      this.t.expressionStatement(\r\n        this.t.assignmentExpression(\r\n          '=',\r\n          this.t.memberExpression(this.t.identifier('$updateArr'), this.t.identifier('$idx'), true),\r\n          this.t.arrowFunctionExpression(\r\n            [...this.updateParams, this.t.identifier('$item')],\r\n            this.t.blockStatement([\r\n              this.t.expressionStatement(this.t.assignmentExpression('=', item, this.t.identifier('$item'))),\r\n              ...this.geneUpdateBody(updateStatements).body,\r\n            ])\r\n          )\r\n        )\r\n      )\r\n    );\r\n\r\n    // ---- Return statement\r\n    childStatements.push(this.generateReturnStatement(topLevelNodes));\r\n\r\n    return this.t.expressionStatement(\r\n      this.t.assignmentExpression(\r\n        '=',\r\n        this.t.identifier(dlNodeName),\r\n        this.t.newExpression(this.t.identifier(this.importMap.ForNode), [\r\n          array,\r\n          this.t.numericLiteral(depNum),\r\n          this.getForKeyStatement(array, item, key),\r\n          this.t.arrowFunctionExpression(\r\n            [item as any, this.t.identifier('$updateArr'), this.t.identifier('$idx')],\r\n            this.t.blockStatement(childStatements)\r\n          ),\r\n        ])\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${array}.map(${item} => ${key})\r\n   */\r\n  private getForKeyStatement(array: t.Expression, item: t.LVal, key: t.Expression): t.Expression {\r\n    return this.t.isNullLiteral(key)\r\n      ? key\r\n      : this.t.callExpression(this.t.memberExpression(array, this.t.identifier('map')), [\r\n          this.t.arrowFunctionExpression([item as any], key),\r\n        ]);\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName}.updateArray(${array}, ${array}.map(${item} => ${key}))\r\n   */\r\n  private updateForNode(dlNodeName: string, array: t.Expression, item: t.LVal, key: t.Expression): t.Statement {\r\n    return this.optionalExpression(\r\n      dlNodeName,\r\n      this.t.callExpression(this.t.memberExpression(this.t.identifier(dlNodeName), this.t.identifier('updateArray')), [\r\n        array,\r\n        ...this.updateParams.slice(1),\r\n        this.getForKeyStatement(array, item, key),\r\n      ])\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName}?.update(changed)\r\n   */\r\n  private updateForNodeItem(dlNodeName: string): t.Statement {\r\n    return this.optionalExpression(\r\n      dlNodeName,\r\n      this.t.callExpression(\r\n        this.t.memberExpression(this.t.identifier(dlNodeName), this.t.identifier('update')),\r\n        this.updateParams\r\n      )\r\n    );\r\n  }\r\n}\r\n","import { type types as t } from '@babel/core';\r\nimport BaseGenerator from './BaseGenerator';\r\n\r\nexport default class CondGenerator extends BaseGenerator {\r\n  /**\r\n   * @View\r\n   * $thisCond.cond = ${idx}\r\n   */\r\n  geneCondIdx(idx: number): t.ExpressionStatement {\r\n    return this.t.expressionStatement(\r\n      this.t.assignmentExpression(\r\n        '=',\r\n        this.t.memberExpression(this.t.identifier('$thisCond'), this.t.identifier('cond')),\r\n        this.t.numericLiteral(idx)\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * if ($thisCond.cond === ${idx}) {\r\n   *  $thisCond.didntChange = true\r\n   *  return []\r\n   * }\r\n   */\r\n  geneCondCheck(idx: number): t.IfStatement {\r\n    return this.t.ifStatement(\r\n      this.t.binaryExpression(\r\n        '===',\r\n        this.t.memberExpression(this.t.identifier('$thisCond'), this.t.identifier('cond')),\r\n        this.t.numericLiteral(idx)\r\n      ),\r\n      this.t.blockStatement([\r\n        this.t.expressionStatement(\r\n          this.t.assignmentExpression(\r\n            '=',\r\n            this.t.memberExpression(this.t.identifier('$thisCond'), this.t.identifier('didntChange')),\r\n            this.t.booleanLiteral(true)\r\n          )\r\n        ),\r\n        this.t.returnStatement(this.t.arrayExpression([])),\r\n      ])\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName}?.updateCond(key)\r\n   */\r\n  updateCondNodeCond(dlNodeName: string): t.Statement {\r\n    return this.optionalExpression(\r\n      dlNodeName,\r\n      this.t.callExpression(this.t.memberExpression(this.t.identifier(dlNodeName), this.t.identifier('updateCond')), [\r\n        ...this.updateParams.slice(1),\r\n      ])\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName}?.update(changed)\r\n   */\r\n  updateCondNode(dlNodeName: string): t.Statement {\r\n    return this.optionalExpression(\r\n      dlNodeName,\r\n      this.t.callExpression(\r\n        this.t.memberExpression(this.t.identifier(dlNodeName), this.t.identifier('update')),\r\n        this.updateParams\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName} = new CondNode(${depNum}, ($thisCond) => {})\r\n   */\r\n  declareCondNode(dlNodeName: string, condFunc: t.BlockStatement, deps: number[]): t.Statement {\r\n    return this.t.expressionStatement(\r\n      this.t.assignmentExpression(\r\n        '=',\r\n        this.t.identifier(dlNodeName),\r\n        this.t.newExpression(this.t.identifier(this.importMap.CondNode), [\r\n          this.t.numericLiteral(CondGenerator.calcDependencyNum(deps)),\r\n          this.t.arrowFunctionExpression([this.t.identifier('$thisCond')], condFunc),\r\n        ])\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * return $thisCond.cond === ${branchIdx} ? [${nodeNames}] : $thisCond.updateCond()\r\n   */\r\n  geneCondReturnStatement(nodeNames: string[], branchIdx: number): t.Statement {\r\n    // ---- If the returned cond is not the last one,\r\n    //      it means it's been altered in the childrenNodes,\r\n    //      so we update the cond again to get the right one\r\n    return this.t.returnStatement(\r\n      this.t.conditionalExpression(\r\n        this.t.binaryExpression(\r\n          '===',\r\n          this.t.memberExpression(this.t.identifier('$thisCond'), this.t.identifier('cond')),\r\n          this.t.numericLiteral(branchIdx)\r\n        ),\r\n        this.t.arrayExpression(nodeNames.map(name => this.t.identifier(name))),\r\n        this.t.callExpression(\r\n          this.t.memberExpression(this.t.identifier('$thisCond'), this.t.identifier('updateCond')),\r\n          this.updateParams.slice(1)\r\n        )\r\n      )\r\n    );\r\n  }\r\n}\r\n","import { type types as t } from '@babel/core';\r\nimport { type IfParticle, type IfBranch } from '@inula/reactivity-parser';\r\nimport CondGenerator from '../HelperGenerators/CondGenerator';\r\n\r\nexport default class IfGenerator extends CondGenerator {\r\n  run() {\r\n    const { branches } = this.viewParticle as IfParticle;\r\n    const deps = branches.flatMap(({ condition }) => condition.dependencyIndexArr ?? []);\r\n\r\n    // ---- declareIfNode\r\n    const dlNodeName = this.generateNodeName();\r\n    this.addInitStatement(this.declareIfNode(dlNodeName, branches, deps));\r\n\r\n    this.addUpdateStatements(deps, this.updateCondNodeCond(dlNodeName));\r\n    this.addUpdateStatementsWithoutDep(this.updateCondNode(dlNodeName));\r\n\r\n    return dlNodeName;\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * if (${test}) { ${body} } else { ${alternate} }\r\n   */\r\n  geneIfStatement(test: t.Expression, body: t.Statement[], alternate: t.Statement): t.IfStatement {\r\n    return this.t.ifStatement(test, this.t.blockStatement(body), alternate);\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * const ${dlNodeName} = new IfNode(($thisCond) => {\r\n   *   if (cond1) {\r\n   *    if ($thisCond.cond === 0) return\r\n   *    ${children}\r\n   *    $thisCond.cond = 0\r\n   *    return [nodes]\r\n   *   } else if (cond2) {\r\n   *    if ($thisCond.cond === 1) return\r\n   *    ${children}\r\n   *    $thisCond.cond = 1\r\n   *    return [nodes]\r\n   *   }\r\n   * })\r\n   */\r\n  private declareIfNode(dlNodeName: string, branches: IfBranch[], deps: number[]): t.Statement {\r\n    // ---- If no else statement, add one\r\n    if (\r\n      !this.t.isBooleanLiteral(branches[branches.length - 1].condition.value, {\r\n        value: true,\r\n      })\r\n    ) {\r\n      branches.push({\r\n        condition: {\r\n          value: this.t.booleanLiteral(true),\r\n          dependencyIndexArr: [],\r\n          dependenciesNode: this.t.arrayExpression([]),\r\n          dynamic: false,\r\n        },\r\n        children: [],\r\n      });\r\n    }\r\n    const ifStatement = branches.reverse().reduce<any>((acc, { condition, children }, i) => {\r\n      const idx = branches.length - i - 1;\r\n      // ---- Generate children\r\n      const [childStatements, topLevelNodes, updateStatements, nodeIdx] = this.generateChildren(children, false, true);\r\n\r\n      // ---- Even if no updateStatements, we still need reassign an empty updateFunc\r\n      //      to overwrite the previous one\r\n      /**\r\n       * $thisCond.updateFunc = (changed) => { ${updateStatements} }\r\n       */\r\n      const updateNode = this.t.expressionStatement(\r\n        this.t.assignmentExpression(\r\n          '=',\r\n          this.t.memberExpression(this.t.identifier('$thisCond'), this.t.identifier('updateFunc')),\r\n          this.t.arrowFunctionExpression(this.updateParams, this.geneUpdateBody(updateStatements))\r\n        )\r\n      );\r\n\r\n      // ---- Update func\r\n      childStatements.unshift(...this.declareNodes(nodeIdx), updateNode);\r\n\r\n      // ---- Check cond and update cond\r\n      childStatements.unshift(this.geneCondCheck(idx), this.geneCondIdx(idx));\r\n\r\n      // ---- Return statement\r\n      childStatements.push(this.geneCondReturnStatement(topLevelNodes, idx));\r\n\r\n      // ---- else statement\r\n      if (i === 0) return this.t.blockStatement(childStatements);\r\n\r\n      return this.geneIfStatement(condition.value, childStatements, acc);\r\n    }, undefined);\r\n\r\n    return this.declareCondNode(dlNodeName, this.t.blockStatement([ifStatement]), deps);\r\n  }\r\n}\r\n","import { type types as t } from '@babel/core';\r\nimport { type ViewParticle, type DependencyProp, type EnvParticle } from '@inula/reactivity-parser';\r\nimport PropViewGenerator from '../HelperGenerators/PropViewGenerator';\r\n\r\nexport default class EnvGenerator extends PropViewGenerator {\r\n  run() {\r\n    let { props } = this.viewParticle as EnvParticle;\r\n    props = this.alterPropViews(props)!;\r\n    const { children } = this.viewParticle as EnvParticle;\r\n\r\n    const dlNodeName = this.generateNodeName();\r\n\r\n    this.addInitStatement(this.declareEnvNode(dlNodeName, props));\r\n\r\n    // ---- Children\r\n    this.addInitStatement(this.geneEnvChildren(dlNodeName, children));\r\n\r\n    // ---- Update props\r\n    Object.entries(props).forEach(([key, { dependencyIndexArr, value, dependenciesNode }]) => {\r\n      if (!dependencyIndexArr) return;\r\n      this.addUpdateStatements(dependencyIndexArr, this.updateEnvNode(dlNodeName, key, value, dependenciesNode));\r\n    });\r\n\r\n    return dlNodeName;\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * { ${key}: ${value}, ... }\r\n   * { ${key}: ${deps}, ... }\r\n   */\r\n  private generateEnvs(props: Record<string, DependencyProp>): t.Expression[] {\r\n    return [\r\n      this.t.objectExpression(\r\n        Object.entries(props).map(([key, { value }]) => this.t.objectProperty(this.t.identifier(key), value))\r\n      ),\r\n      this.t.objectExpression(\r\n        Object.entries(props)\r\n          .map(\r\n            ([key, { dependenciesNode }]) =>\r\n              dependenciesNode && this.t.objectProperty(this.t.identifier(key), dependenciesNode)\r\n          )\r\n          .filter(Boolean) as t.ObjectProperty[]\r\n      ),\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName} = new EnvNode(envs)\r\n   */\r\n  private declareEnvNode(dlNodeName: string, props: Record<string, DependencyProp>): t.Statement {\r\n    return this.t.expressionStatement(\r\n      this.t.assignmentExpression(\r\n        '=',\r\n        this.t.identifier(dlNodeName),\r\n        this.t.newExpression(this.t.identifier(this.importMap.EnvNode), this.generateEnvs(props))\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName}.initNodes([${childrenNames}])\r\n   */\r\n  private geneEnvChildren(dlNodeName: string, children: ViewParticle[]): t.Statement {\r\n    const [statements, childrenNames] = this.generateChildren(children);\r\n    this.addInitStatement(...statements);\r\n    return this.t.expressionStatement(\r\n      this.t.callExpression(this.t.memberExpression(this.t.identifier(dlNodeName), this.t.identifier('initNodes')), [\r\n        this.t.arrayExpression(childrenNames.map(name => this.t.identifier(name))),\r\n      ])\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName}.updateEnv(${key}, () => ${value}, ${dependenciesNode})\r\n   */\r\n  private updateEnvNode(\r\n    dlNodeName: string,\r\n    key: string,\r\n    value: t.Expression,\r\n    dependenciesNode: t.ArrayExpression\r\n  ): t.Statement {\r\n    return this.optionalExpression(\r\n      dlNodeName,\r\n      this.t.callExpression(this.t.memberExpression(this.t.identifier(dlNodeName), this.t.identifier('updateEnv')), [\r\n        this.t.stringLiteral(key),\r\n        this.t.arrowFunctionExpression([], value),\r\n        dependenciesNode,\r\n      ])\r\n    );\r\n  }\r\n}\r\n","import { type types as t } from '@babel/core';\r\nimport { type TextParticle } from '@inula/reactivity-parser';\r\nimport BaseGenerator from '../HelperGenerators/BaseGenerator';\r\n\r\nexport default class TextGenerator extends BaseGenerator {\r\n  run() {\r\n    const { content } = this.viewParticle as TextParticle;\r\n\r\n    const dlNodeName = this.generateNodeName();\r\n\r\n    this.addInitStatement(this.declareTextNode(dlNodeName, content.value, content.dependenciesNode));\r\n\r\n    if (content.dynamic) {\r\n      this.addUpdateStatements(\r\n        content.dependencyIndexArr,\r\n        this.updateTextNode(dlNodeName, content.value, content.dependenciesNode)\r\n      );\r\n    }\r\n\r\n    return dlNodeName;\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName} = createTextNode(${value}, ${deps})\r\n   */\r\n  private declareTextNode(dlNodeName: string, value: t.Expression, dependenciesNode: t.Expression): t.Statement {\r\n    return this.t.expressionStatement(\r\n      this.t.assignmentExpression(\r\n        '=',\r\n        this.t.identifier(dlNodeName),\r\n        this.t.callExpression(this.t.identifier(this.importMap.createTextNode), [value, dependenciesNode])\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName} && updateText(${dlNodeName}, () => ${value}, ${deps})\r\n   */\r\n  private updateTextNode(dlNodeName: string, value: t.Expression, dependenciesNode: t.Expression): t.Statement {\r\n    return this.t.expressionStatement(\r\n      this.t.logicalExpression(\r\n        '&&',\r\n        this.t.identifier(dlNodeName),\r\n        this.t.callExpression(this.t.identifier(this.importMap.updateText), [\r\n          this.t.identifier(dlNodeName),\r\n          this.t.arrowFunctionExpression([], value),\r\n          dependenciesNode,\r\n        ])\r\n      )\r\n    );\r\n  }\r\n}\r\n","import { type types as t } from '@babel/core';\r\nimport { type ExpParticle } from '@inula/reactivity-parser';\r\nimport ElementGenerator from '../HelperGenerators/ElementGenerator';\r\nimport { DLError } from '../error';\r\n\r\nexport default class ExpGenerator extends ElementGenerator {\r\n  run() {\r\n    let { content, props } = this.viewParticle as ExpParticle;\r\n    content = this.alterPropView(content)!;\r\n    props = this.alterPropViews(props);\r\n\r\n    const dlNodeName = this.generateNodeName();\r\n\r\n    this.addInitStatement(this.declareExpNode(dlNodeName, content.value, content.dependenciesNode));\r\n\r\n    if (content.dynamic) {\r\n      this.addUpdateStatements(\r\n        content.dependencyIndexArr,\r\n        this.updateExpNode(dlNodeName, content.value, content.dependenciesNode)\r\n      );\r\n    }\r\n\r\n    if (props) {\r\n      Object.entries(props).forEach(([key, { value }]) => {\r\n        if (ExpGenerator.lifecycle.includes(key as (typeof ExpGenerator.lifecycle)[number])) {\r\n          return this.addInitStatement(\r\n            this.addLifecycle(dlNodeName, key as (typeof ExpGenerator.lifecycle)[number], value)\r\n          );\r\n        }\r\n        if (key === 'ref') {\r\n          return this.addInitStatement(this.initElement(dlNodeName, value));\r\n        }\r\n        if (key === 'elements') {\r\n          return this.addInitStatement(this.initElement(dlNodeName, value, true));\r\n        }\r\n        if (key === 'didUpdate') {\r\n          return this.addUpdateStatements(content.dependencyIndexArr, this.addOnUpdate(dlNodeName, value));\r\n        }\r\n        DLError.warn1(key);\r\n      });\r\n    }\r\n\r\n    return dlNodeName;\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName} = new ExpNode(${value}, dependenciesNode)\r\n   */\r\n  private declareExpNode(dlNodeName: string, value: t.Expression, dependenciesNode: t.ArrayExpression): t.Statement {\r\n    return this.t.expressionStatement(\r\n      this.t.assignmentExpression(\r\n        '=',\r\n        this.t.identifier(dlNodeName),\r\n        this.t.newExpression(this.t.identifier(this.importMap.ExpNode), [\r\n          value,\r\n          dependenciesNode ?? this.t.nullLiteral(),\r\n        ])\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName}.update(() => value, dependenciesNode)\r\n   */\r\n  private updateExpNode(dlNodeName: string, value: t.Expression, dependenciesNode: t.ArrayExpression): t.Statement {\r\n    return this.optionalExpression(\r\n      dlNodeName,\r\n      this.t.callExpression(this.t.memberExpression(this.t.identifier(dlNodeName), this.t.identifier('update')), [\r\n        this.t.arrowFunctionExpression([], value),\r\n        dependenciesNode ?? this.t.nullLiteral(),\r\n      ])\r\n    );\r\n  }\r\n}\r\n","import { type DependencyProp, type SnippetParticle } from '@inula/reactivity-parser';\r\nimport type { types as t } from '@babel/core';\r\nimport PropViewGenerator from '../HelperGenerators/PropViewGenerator';\r\n\r\nexport default class SnippetGenerator extends PropViewGenerator {\r\n  run() {\r\n    let { props } = this.viewParticle as SnippetParticle;\r\n    props = this.alterPropViews(props);\r\n    const { tag } = this.viewParticle as SnippetParticle;\r\n\r\n    const dlNodeName = this.generateNodeName();\r\n\r\n    const availableProperties = this.snippetPropMap[tag] ?? [];\r\n\r\n    const allDependenciesNode: (t.ArrayExpression | t.NullLiteral)[] = Array.from(\r\n      {\r\n        length: availableProperties.length,\r\n      },\r\n      () => this.t.nullLiteral()\r\n    );\r\n\r\n    const allDependencyIndexArr: number[] = [];\r\n\r\n    Object.entries(props).forEach(([key, { value, dependencyIndexArr, dependenciesNode }]) => {\r\n      if (key === 'didUpdate') return;\r\n      if (SnippetGenerator.lifecycle.includes(key as (typeof SnippetGenerator.lifecycle)[number])) {\r\n        this.addInitStatement(this.addLifecycle(dlNodeName, key as (typeof SnippetGenerator.lifecycle)[number], value));\r\n        return;\r\n      }\r\n      if (!dependencyIndexArr || dependencyIndexArr.length === 0) return;\r\n      allDependencyIndexArr.push(...dependencyIndexArr);\r\n      const depIdx = availableProperties.indexOf(key);\r\n      if (dependenciesNode) allDependenciesNode[depIdx] = dependenciesNode;\r\n      const propChange = 1 << depIdx;\r\n      this.addUpdateStatements(\r\n        dependencyIndexArr,\r\n        this.updateProp(dlNodeName, propChange, key, value, allDependenciesNode[depIdx])\r\n      );\r\n    });\r\n    if (props.didUpdate) {\r\n      this.addUpdateStatements(allDependencyIndexArr, this.addOnUpdate(dlNodeName, props.didUpdate.value));\r\n    }\r\n\r\n    this.addInitStatement(...this.declareSnippetNode(dlNodeName, tag, props, allDependenciesNode));\r\n\r\n    this.addUpdateStatementsWithoutDep(this.updateSnippet(dlNodeName));\r\n\r\n    return dlNodeName;\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * { ${key}: ${value}, ... }\r\n   */\r\n  private genePropNode(props: Record<string, DependencyProp>): t.Expression {\r\n    return this.t.objectExpression(\r\n      Object.entries(props).map(([key, prop]) => {\r\n        return this.t.objectProperty(this.t.identifier(key), prop.value);\r\n      })\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName} = new SnippetNode(${allDependenciesNode})\r\n   * this.${tag}({${props}}, ${dlNodeName})\r\n   */\r\n  private declareSnippetNode(\r\n    dlNodeName: string,\r\n    tag: string,\r\n    props: Record<string, DependencyProp>,\r\n    allDependenciesNode: (t.ArrayExpression | t.NullLiteral)[]\r\n  ): t.Statement[] {\r\n    return [\r\n      this.t.expressionStatement(\r\n        this.t.assignmentExpression(\r\n          '=',\r\n          this.t.identifier(dlNodeName),\r\n          this.t.newExpression(this.t.identifier(this.importMap.SnippetNode), [\r\n            this.t.arrayExpression(allDependenciesNode),\r\n          ])\r\n        )\r\n      ),\r\n      this.t.expressionStatement(\r\n        this.t.callExpression(this.t.memberExpression(this.t.thisExpression(), this.t.identifier(tag)), [\r\n          this.genePropNode(props),\r\n          this.t.identifier(dlNodeName),\r\n        ])\r\n      ),\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName}.updateProp?.(${propChanged}, ...updateParams, () => { ${key}: ${value} }, allDependenciesNode)\r\n   */\r\n  private updateProp(\r\n    dlNodeName: string,\r\n    propChanged: number,\r\n    key: string,\r\n    value: t.Expression,\r\n    allDependenciesNode: t.ArrayExpression | t.NullLiteral\r\n  ): t.Statement {\r\n    return this.optionalExpression(\r\n      dlNodeName,\r\n      this.t.optionalCallExpression(\r\n        this.t.memberExpression(this.t.identifier(dlNodeName), this.t.identifier('updateProp')),\r\n        [\r\n          this.t.numericLiteral(propChanged),\r\n          ...this.updateParams.slice(1),\r\n          this.t.arrowFunctionExpression(\r\n            [],\r\n            this.t.objectExpression([this.t.objectProperty(this.t.identifier(key), value)])\r\n          ),\r\n          allDependenciesNode,\r\n        ],\r\n        true\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName}.update(changed)\r\n   */\r\n  private updateSnippet(dlNodeName: string): t.Statement {\r\n    return this.optionalExpression(\r\n      dlNodeName,\r\n      this.t.optionalCallExpression(\r\n        this.t.memberExpression(this.t.identifier(dlNodeName), this.t.identifier('update')),\r\n        this.updateParams,\r\n        true\r\n      )\r\n    );\r\n  }\r\n}\r\n","import { type types as t } from '@babel/core';\r\nimport { SwitchBranch, SwitchParticle } from '@inula/reactivity-parser';\r\nimport CondGenerator from '../HelperGenerators/CondGenerator';\r\n\r\nexport default class SwitchGenerator extends CondGenerator {\r\n  run() {\r\n    const { branches, discriminant } = this.viewParticle as SwitchParticle;\r\n\r\n    const deps = branches.flatMap(({ case: _case }) => _case.dependencyIndexArr);\r\n    deps.push(...discriminant.dependencyIndexArr);\r\n\r\n    // ---- declareSwitchNode\r\n    const dlNodeName = this.generateNodeName();\r\n    this.addInitStatement(this.declareSwitchNode(dlNodeName, discriminant.value, branches, deps));\r\n\r\n    this.addUpdateStatements(deps, this.updateCondNodeCond(dlNodeName));\r\n    this.addUpdateStatementsWithoutDep(this.updateCondNode(dlNodeName));\r\n\r\n    return dlNodeName;\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * const ${dlNodeName} = new CondNode(($thisCond) => {\r\n   *   switch ($discriminant) {\r\n   *    case ${case0}:\r\n   *      if ($thisCond.case === 0) return\r\n   *    case ${case1}:\r\n   *      if ($thisCond.case === 1) return\r\n   *      return [...${case1Nodes}]\r\n   *    default:\r\n   *      if ($thisCond.case === 2) return\r\n   *  }\r\n   *   _$nodes[0]._$updateFunc = (changed) => {\r\n   *    _$updates.forEach(update => update(changed))\r\n   *  })\r\n   *   return _$nodes\r\n   * })\r\n   */\r\n  private declareSwitchNode(\r\n    dlNodeName: string,\r\n    discriminant: t.Expression,\r\n    branches: SwitchBranch[],\r\n    deps: number[]\r\n  ): t.Statement {\r\n    // ---- Format statements, make fallthrough statements append to the previous case\r\n    const formattedBranches: SwitchBranch[] = branches.map(({ case: _case, break: _break, children }, idx) => {\r\n      if (!_break) {\r\n        for (let i = idx + 1; i < branches.length; i++) {\r\n          children.push(...branches[i].children);\r\n          if (branches[i].break) break;\r\n        }\r\n      }\r\n      return { case: _case, break: _break, children };\r\n    });\r\n    // ---- Add default case\r\n    const defaultCaseIdx = formattedBranches.findIndex(({ case: _case }) => _case === null);\r\n    if (defaultCaseIdx === -1) {\r\n      formattedBranches.push({\r\n        case: {\r\n          value: this.t.booleanLiteral(true),\r\n          dependencyIndexArr: [],\r\n          dependenciesNode: this.t.arrayExpression([]),\r\n          dynamic: false,\r\n        },\r\n        break: true,\r\n        children: [],\r\n      });\r\n    }\r\n\r\n    const switchStatements = formattedBranches.map(({ case: _case, children }, idx) => {\r\n      // ---- Generate case statements\r\n      const [childStatements, topLevelNodes, updateStatements, nodeIdx] = this.generateChildren(children, false, true);\r\n\r\n      // ---- Even if no updateStatements, we still need reassign an empty updateFunc\r\n      //      to overwrite the previous one\r\n      /**\r\n       * $thisCond.updateFunc = (changed) => { ${updateStatements} }\r\n       */\r\n      const updateNode = this.t.expressionStatement(\r\n        this.t.assignmentExpression(\r\n          '=',\r\n          this.t.memberExpression(this.t.identifier('$thisCond'), this.t.identifier('updateFunc')),\r\n          this.t.arrowFunctionExpression(this.updateParams, this.geneUpdateBody(updateStatements))\r\n        )\r\n      );\r\n\r\n      // ---- Update func\r\n      childStatements.unshift(...this.declareNodes(nodeIdx), updateNode);\r\n\r\n      // ---- Check cond and update cond\r\n      childStatements.unshift(this.geneCondCheck(idx), this.geneCondIdx(idx));\r\n\r\n      // ---- Return statement\r\n      childStatements.push(this.geneCondReturnStatement(topLevelNodes, idx));\r\n\r\n      return this.t.switchCase(_case ? _case.value : null, [this.t.blockStatement(childStatements)]);\r\n    });\r\n\r\n    return this.declareCondNode(\r\n      dlNodeName,\r\n      this.t.blockStatement([this.t.switchStatement(discriminant, switchStatements)]),\r\n      deps\r\n    );\r\n  }\r\n}\r\n","import { type types as t } from '@babel/core';\r\nimport BaseGenerator from '../HelperGenerators/BaseGenerator';\r\nimport { TryParticle, type ViewParticle } from '@inula/reactivity-parser';\r\n\r\nexport default class TryGenerator extends BaseGenerator {\r\n  run() {\r\n    const { children, catchChildren, exception } = this.viewParticle as TryParticle;\r\n\r\n    const dlNodeName = this.generateNodeName();\r\n\r\n    // ---- Declare for node\r\n    this.addInitStatement(this.declareTryNode(dlNodeName, children, catchChildren, exception));\r\n\r\n    // ---- Update statements\r\n    this.addUpdateStatementsWithoutDep(this.declareUpdate(dlNodeName));\r\n\r\n    return dlNodeName;\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * $setUpdate($catchable(updateStatements))\r\n   * ${children}\r\n   * return [...${topLevelNodes}]\r\n   */\r\n  private declareTryNodeUpdate(children: ViewParticle[], addCatchable = true): t.Statement[] {\r\n    const [childStatements, topLevelNodes, updateStatements, nodeIdx] = this.generateChildren(children, false, true);\r\n\r\n    const updateFunc = this.t.arrowFunctionExpression(\r\n      [this.t.identifier('$changed')],\r\n      this.geneUpdateBody(updateStatements)\r\n    );\r\n\r\n    childStatements.unshift(\r\n      ...this.declareNodes(nodeIdx),\r\n      this.t.expressionStatement(\r\n        this.t.callExpression(\r\n          this.t.identifier('$setUpdate'),\r\n          addCatchable ? [this.t.callExpression(this.t.identifier('$catchable'), [updateFunc])] : [updateFunc]\r\n        )\r\n      )\r\n    );\r\n    childStatements.push(\r\n      this.t.returnStatement(this.t.arrayExpression(topLevelNodes.map(node => this.t.identifier(node))))\r\n    );\r\n\r\n    return childStatements;\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName} = new TryNode(($setUpdate, $catchable) => {\r\n   *     ${children}\r\n   *   }, ($setUpdate, e) => {\r\n   *     ${catchChildren}\r\n   *  })\r\n   * })\r\n   */\r\n  private declareTryNode(\r\n    dlNodeName: string,\r\n    children: ViewParticle[],\r\n    catchChildren: ViewParticle[],\r\n    exception: TryParticle['exception']\r\n  ): t.Statement {\r\n    const exceptionNodes = exception ? [exception] : [];\r\n    return this.t.expressionStatement(\r\n      this.t.assignmentExpression(\r\n        '=',\r\n        this.t.identifier(dlNodeName),\r\n        this.t.newExpression(this.t.identifier(this.importMap.TryNode), [\r\n          this.t.arrowFunctionExpression(\r\n            [this.t.identifier('$setUpdate'), this.t.identifier('$catchable')],\r\n            this.t.blockStatement(this.declareTryNodeUpdate(children, true))\r\n          ),\r\n          this.t.arrowFunctionExpression(\r\n            [this.t.identifier('$setUpdate'), ...exceptionNodes],\r\n            this.t.blockStatement(this.declareTryNodeUpdate(catchChildren, false))\r\n          ),\r\n        ])\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * ${dlNodeName}?.update(changed)\r\n   */\r\n  private declareUpdate(dlNodeName: string): t.Statement {\r\n    return this.optionalExpression(\r\n      dlNodeName,\r\n      this.t.callExpression(\r\n        this.t.memberExpression(this.t.identifier(dlNodeName), this.t.identifier('update')),\r\n        this.updateParams\r\n      )\r\n    );\r\n  }\r\n}\r\n","import { type types as t } from '@babel/core';\r\nimport { type ViewParticle } from '@inula/reactivity-parser';\r\nimport { type ViewGeneratorConfig } from './types';\r\nimport BaseGenerator, { prefixMap } from './HelperGenerators/BaseGenerator';\r\nimport CompGenerator from './NodeGenerators/CompGenerator';\r\nimport HTMLGenerator from './NodeGenerators/HTMLGenerator';\r\nimport TemplateGenerator from './NodeGenerators/TemplateGenerator';\r\nimport ForGenerator from './NodeGenerators/ForGenerator';\r\nimport IfGenerator from './NodeGenerators/IfGenerator';\r\nimport EnvGenerator from './NodeGenerators/EnvGenerator';\r\nimport TextGenerator from './NodeGenerators/TextGenerator';\r\nimport ExpGenerator from './NodeGenerators/ExpGenerator';\r\nimport SnippetGenerator from './NodeGenerators/SnippetGenerator';\r\nimport SwitchGenerator from './NodeGenerators/SwitchGenerator';\r\nimport TryGenerator from './NodeGenerators/TryGenerator';\r\n\r\nexport default class ViewGenerator {\r\n  config: ViewGeneratorConfig;\r\n  t: typeof t;\r\n\r\n  /**\r\n   * @brief Construct the view generator from config\r\n   * @param config\r\n   */\r\n  constructor(config: ViewGeneratorConfig) {\r\n    this.config = config;\r\n    this.t = config.babelApi.types;\r\n    this.templateIdx = config.templateIdx;\r\n  }\r\n\r\n  /**\r\n   * @brief Different generator classes for different view particle types\r\n   */\r\n  static generatorMap: Record<string, typeof BaseGenerator> = {\r\n    comp: CompGenerator,\r\n    html: HTMLGenerator,\r\n    template: TemplateGenerator,\r\n    for: ForGenerator,\r\n    if: IfGenerator,\r\n    switch: SwitchGenerator,\r\n    env: EnvGenerator,\r\n    text: TextGenerator,\r\n    exp: ExpGenerator,\r\n    snippet: SnippetGenerator,\r\n    try: TryGenerator,\r\n  };\r\n\r\n  /**\r\n   * @brief Generate the view given the view particles, mainly used for child particles parsing\r\n   * @param viewParticles\r\n   * @returns [initStatements, updateStatements, classProperties, topLevelNodes]\r\n   */\r\n  generateChildren(\r\n    viewParticles: ViewParticle[]\r\n  ): [t.Statement[], Record<number, t.Statement[]>, t.ClassProperty[], string[]] {\r\n    const allInitStatements: t.Statement[] = [];\r\n    const allClassProperties: t.ClassProperty[] = [];\r\n    const allUpdateStatements: Record<number, t.Statement[]> = {};\r\n    const topLevelNodes: string[] = [];\r\n\r\n    viewParticles.forEach(viewParticle => {\r\n      const [initStatements, updateStatements, classProperties, nodeName] = this.generateChild(viewParticle);\r\n      allInitStatements.push(...initStatements);\r\n      Object.entries(updateStatements).forEach(([depNum, statements]) => {\r\n        if (!allUpdateStatements[Number(depNum)]) {\r\n          allUpdateStatements[Number(depNum)] = [];\r\n        }\r\n        allUpdateStatements[Number(depNum)].push(...statements);\r\n      });\r\n      allClassProperties.push(...classProperties);\r\n      topLevelNodes.push(nodeName);\r\n    });\r\n\r\n    return [allInitStatements, allUpdateStatements, allClassProperties, topLevelNodes];\r\n  }\r\n\r\n  nodeIdx = -1;\r\n  templateIdx = -1;\r\n  /**\r\n   * @brief Generate the view given the view particle, using generator from the map\r\n   * @param viewParticle\r\n   * @returns\r\n   */\r\n  generateChild(viewParticle: ViewParticle) {\r\n    const { type } = viewParticle;\r\n    const GeneratorClass = ViewGenerator.generatorMap[type];\r\n    if (!GeneratorClass) {\r\n      throw new Error(`Unknown view particle type: ${type}`);\r\n    }\r\n    const generator = new GeneratorClass(viewParticle, this.config);\r\n    generator.nodeIdx = this.nodeIdx;\r\n    generator.templateIdx = this.templateIdx;\r\n    const result = generator.generate();\r\n    this.nodeIdx = generator.nodeIdx;\r\n    this.templateIdx = generator.templateIdx;\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * let node1, node2, ...\r\n   */\r\n  declareNodes(): t.Statement[] {\r\n    if (this.nodeIdx === -1) return [];\r\n    return [\r\n      this.t.variableDeclaration(\r\n        'let',\r\n        Array.from({ length: this.nodeIdx + 1 }, (_, i) =>\r\n          this.t.variableDeclarator(this.t.identifier(`${prefixMap.node}${i}`))\r\n        )\r\n      ),\r\n    ];\r\n  }\r\n\r\n  get updateParams() {\r\n    return [this.t.identifier('$changed')];\r\n  }\r\n}\r\n","import { type types as t } from '@babel/core';\r\nimport { type ViewParticle } from '@inula/reactivity-parser';\r\nimport ViewGenerator from './ViewGenerator';\r\n\r\nexport default class MainViewGenerator extends ViewGenerator {\r\n  /**\r\n   * @brief Generate the main view, i.e., View() { ... }\r\n   * @param viewParticles\r\n   * @returns [viewBody, classProperties, templateIdx]\r\n   */\r\n  generate(viewParticles: ViewParticle[]): [t.BlockStatement, t.ClassProperty[], number] {\r\n    const allClassProperties: t.ClassProperty[] = [];\r\n    const allInitStatements: t.Statement[] = [];\r\n    const allUpdateStatements: Record<number, t.Statement[]> = {};\r\n    const topLevelNodes: string[] = [];\r\n\r\n    viewParticles.forEach(viewParticle => {\r\n      const [initStatements, updateStatements, classProperties, nodeName] = this.generateChild(viewParticle);\r\n      allInitStatements.push(...initStatements);\r\n      Object.entries(updateStatements).forEach(([depNum, statements]) => {\r\n        if (!allUpdateStatements[Number(depNum)]) {\r\n          allUpdateStatements[Number(depNum)] = [];\r\n        }\r\n        allUpdateStatements[Number(depNum)].push(...statements);\r\n      });\r\n      allClassProperties.push(...classProperties);\r\n      topLevelNodes.push(nodeName);\r\n    });\r\n\r\n    const viewBody = this.t.blockStatement([\r\n      ...this.declareNodes(),\r\n      ...this.geneUpdate(allUpdateStatements),\r\n      ...allInitStatements,\r\n      this.geneReturn(topLevelNodes),\r\n    ]);\r\n\r\n    return [viewBody, allClassProperties, this.templateIdx];\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * this._$update = ($changed) => {\r\n   *  if ($changed & 1) {\r\n   *    ...\r\n   *  }\r\n   *  ...\r\n   * }\r\n   */\r\n  private geneUpdate(updateStatements: Record<number, t.Statement[]>): t.Statement[] {\r\n    if (Object.keys(updateStatements).length === 0) return [];\r\n    return [\r\n      this.t.expressionStatement(\r\n        this.t.assignmentExpression(\r\n          '=',\r\n          this.t.memberExpression(this.t.thisExpression(), this.t.identifier('_$update'), false),\r\n          this.t.arrowFunctionExpression(\r\n            this.updateParams,\r\n            this.t.blockStatement([\r\n              ...Object.entries(updateStatements)\r\n                .filter(([depNum]) => depNum !== '0')\r\n                .map(([depNum, statements]) => {\r\n                  return this.t.ifStatement(\r\n                    this.t.binaryExpression('&', this.t.identifier('$changed'), this.t.numericLiteral(Number(depNum))),\r\n                    this.t.blockStatement(statements)\r\n                  );\r\n                }),\r\n              ...(updateStatements[0] ?? []),\r\n            ])\r\n          )\r\n        )\r\n      ),\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * return [${nodeNames}]\r\n   */\r\n  private geneReturn(topLevelNodes: string[]) {\r\n    return this.t.returnStatement(this.t.arrayExpression(topLevelNodes.map(nodeName => this.t.identifier(nodeName))));\r\n  }\r\n}\r\n","import { type types as t } from '@babel/core';\r\nimport { type ViewParticle } from '@inula/reactivity-parser';\r\nimport ViewGenerator from './ViewGenerator';\r\n\r\nexport default class SnippetGenerator extends ViewGenerator {\r\n  /**\r\n   * @brief Generate the snippet, i.e., @View MySnippet({ prop1, prop2 }) { ... }\r\n   *  This is different from the main view in that it has a props node\r\n   *  and is needed to parse twice,\r\n   *    1. for this.deps (viewParticlesWithPropertyDep)\r\n   *    2. for props that passed in this snippet (viewParticlesWithIdentityDep)\r\n   * @param viewParticlesWithPropertyDep\r\n   * @param viewParticlesWithIdentityDep\r\n   * @param propsNode\r\n   * @returns [viewBody, classProperties, templateIdx]\r\n   */\r\n  generate(\r\n    viewParticlesWithPropertyDep: ViewParticle[],\r\n    viewParticlesWithIdentityDep: ViewParticle[],\r\n    propsNode: t.ObjectPattern\r\n  ): [t.BlockStatement, t.ClassProperty[], number] {\r\n    const allClassProperties: t.ClassProperty[] = [];\r\n    const allInitStatements: t.Statement[] = [];\r\n    const propertyUpdateStatements: Record<number, t.Statement[]> = {};\r\n    const identifierUpdateStatements: Record<number, t.Statement[]> = {};\r\n    const topLevelNodes: string[] = [];\r\n\r\n    const templateIdx = this.templateIdx;\r\n    viewParticlesWithPropertyDep.forEach(viewParticle => {\r\n      const [initStatements, updateStatements, classProperties, nodeName] = this.generateChild(viewParticle);\r\n      allInitStatements.push(...initStatements);\r\n      Object.entries(updateStatements).forEach(([depNum, statements]) => {\r\n        if (!propertyUpdateStatements[Number(depNum)]) {\r\n          propertyUpdateStatements[Number(depNum)] = [];\r\n        }\r\n        propertyUpdateStatements[Number(depNum)].push(...statements);\r\n      });\r\n      allClassProperties.push(...classProperties);\r\n      topLevelNodes.push(nodeName);\r\n    });\r\n    // ---- Recover the templateIdx and reinitialize the nodeIdx\r\n    this.templateIdx = templateIdx;\r\n    this.nodeIdx = -1;\r\n    viewParticlesWithIdentityDep.forEach(viewParticle => {\r\n      // ---- We only need the update statements for the second props parsing\r\n      //      because all the init statements are already generated\r\n      //      a little bit time consuming but otherwise we need to write two different generators\r\n      const [, updateStatements] = this.generateChild(viewParticle);\r\n\r\n      Object.entries(updateStatements).forEach(([depNum, statements]) => {\r\n        if (!identifierUpdateStatements[Number(depNum)]) {\r\n          identifierUpdateStatements[Number(depNum)] = [];\r\n        }\r\n        identifierUpdateStatements[Number(depNum)].push(...statements);\r\n      });\r\n    });\r\n\r\n    const hasPropertyUpdateFunc = Object.keys(propertyUpdateStatements).length > 0;\r\n    const hasIdentifierUpdateFunc = Object.keys(identifierUpdateStatements).filter(n => n !== '0').length > 0;\r\n\r\n    const viewBody = this.t.blockStatement([\r\n      ...this.declareNodes(),\r\n      ...(hasPropertyUpdateFunc ? [this.geneUpdateFunc('update', propertyUpdateStatements)] : []),\r\n      ...(hasIdentifierUpdateFunc ? [this.geneUpdateFunc('updateProp', identifierUpdateStatements, propsNode)] : []),\r\n      ...allInitStatements,\r\n      this.geneAddNodes(topLevelNodes),\r\n    ]);\r\n\r\n    return [viewBody, allClassProperties, this.templateIdx];\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * $snippetNode._$nodes = ${topLevelNodes}\r\n   */\r\n  geneAddNodes(topLevelNodes: string[]): t.Statement {\r\n    return this.t.expressionStatement(\r\n      this.t.assignmentExpression(\r\n        '=',\r\n        this.t.memberExpression(this.t.identifier('$snippetNode'), this.t.identifier('_$nodes')),\r\n        this.t.arrayExpression(topLevelNodes.map(nodeName => this.t.identifier(nodeName)))\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * $snippetNode.${name} = (changed) => { ${updateStatements} }\r\n   */\r\n  geneUpdateFunc(\r\n    name: string,\r\n    updateStatements: Record<number, t.Statement[]>,\r\n    propsNode?: t.ObjectPattern\r\n  ): t.Statement {\r\n    return this.t.expressionStatement(\r\n      this.t.assignmentExpression(\r\n        '=',\r\n        this.t.memberExpression(this.t.identifier('$snippetNode'), this.t.identifier(name)),\r\n        this.geneUpdateBody(updateStatements, propsNode)\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @View\r\n   * (changed) => {\r\n   *  if (changed & 1) {\r\n   *    ...\r\n   *  }\r\n   *  ...\r\n   * }\r\n   */\r\n  private geneUpdateBody(\r\n    updateStatements: Record<number, t.Statement[]>,\r\n    propsNode?: t.ObjectPattern\r\n  ): t.ArrowFunctionExpression {\r\n    const bodyEntryNodes: t.Statement[] = [];\r\n    // ---- Args\r\n    const args: t.Identifier[] = this.updateParams;\r\n    if (propsNode) {\r\n      // ---- Add $snippetProps and $depsArr to args\r\n      args.push(this.t.identifier('$snippetPropsFunc'), this.t.identifier('$depsArr'));\r\n\r\n      // ---- Add cache\r\n      /**\r\n       * if ($snippetNode.cached(depsArr, changed)) return\r\n       */\r\n      bodyEntryNodes.push(\r\n        this.t.ifStatement(\r\n          this.t.callExpression(\r\n            this.t.memberExpression(this.t.identifier('$snippetNode'), this.t.identifier('cached')),\r\n            [this.t.identifier('$depsArr'), this.t.identifier('$changed')]\r\n          ),\r\n          this.t.blockStatement([this.t.returnStatement()])\r\n        )\r\n      );\r\n\r\n      /**\r\n       * const $snippetProps = $snippetPropsFunc()\r\n       */\r\n      bodyEntryNodes.push(\r\n        this.t.variableDeclaration('const', [\r\n          this.t.variableDeclarator(\r\n            this.t.identifier('$snippetProps'),\r\n            this.t.callExpression(this.t.identifier('$snippetPropsFunc'), [])\r\n          ),\r\n        ])\r\n      );\r\n\r\n      /**\r\n       * ${prop} = $snippetProps\r\n       */\r\n      propsNode.properties\r\n        .filter(prop => this.t.isObjectProperty(prop))\r\n        .forEach((prop, idx) => {\r\n          const depNum = 1 << idx;\r\n          if (!updateStatements[depNum]) updateStatements[depNum] = [];\r\n          updateStatements[depNum].unshift(\r\n            this.t.expressionStatement(\r\n              this.t.assignmentExpression('=', this.t.objectPattern([prop]), this.t.identifier('$snippetProps'))\r\n            )\r\n          );\r\n        });\r\n    }\r\n    // ---- End\r\n    const runAllStatements = propsNode ? [] : updateStatements[0] ?? [];\r\n\r\n    return this.t.arrowFunctionExpression(\r\n      args,\r\n      this.t.blockStatement([\r\n        ...bodyEntryNodes,\r\n        ...Object.entries(updateStatements)\r\n          .filter(([depNum]) => depNum !== '0')\r\n          .map(([depNum, statements]) => {\r\n            return this.t.ifStatement(\r\n              this.t.binaryExpression('&', this.t.identifier('$changed'), this.t.numericLiteral(Number(depNum))),\r\n              this.t.blockStatement(statements)\r\n            );\r\n          }),\r\n        ...runAllStatements,\r\n      ])\r\n    );\r\n  }\r\n}\r\n","import { type ViewParticle } from '@inula/reactivity-parser';\r\nimport { type ViewGeneratorConfig } from './types';\r\nimport { type types as t } from '@babel/core';\r\nimport MainViewGenerator from './MainViewGenerator';\r\nimport SnippetGenerator from './SnippetGenerator';\r\n\r\nexport function generateView(\r\n  viewParticles: ViewParticle[],\r\n  config: ViewGeneratorConfig\r\n): [t.BlockStatement, t.ClassProperty[], number] {\r\n  return new MainViewGenerator(config).generate(viewParticles);\r\n}\r\n\r\nexport function generateSnippet(\r\n  viewParticlesWithPropertyDep: ViewParticle[],\r\n  viewParticlesWithIdentityDep: ViewParticle[],\r\n  propNode: t.ObjectPattern,\r\n  config: ViewGeneratorConfig\r\n): [t.BlockStatement, t.ClassProperty[], number] {\r\n  return new SnippetGenerator(config).generate(viewParticlesWithPropertyDep, viewParticlesWithIdentityDep, propNode);\r\n}\r\n\r\nexport * from './types';\r\n","import { type types as t, NodePath } from '@babel/core';\r\nimport * as babel from '@babel/core';\r\nimport { Option } from './types';\r\nimport type { Scope } from '@babel/traverse';\r\n\r\nfunction replaceFnWithClass(path: NodePath<t.FunctionDeclaration>, classTransformer: ClassComponentTransformer) {\r\n  const originalName = path.node.id.name;\r\n  const tempName = path.node.id.name + 'Temp';\r\n  const classComp = classTransformer.genClassComponent(tempName);\r\n  path.replaceWith(classComp);\r\n  path.scope.rename(tempName, originalName);\r\n}\r\n\r\nexport class PluginProvider {\r\n  // ---- Plugin Level ----\r\n  private readonly babelApi: typeof babel;\r\n  private readonly t: typeof t;\r\n\r\n  private programNode: t.Program | undefined;\r\n\r\n  constructor(babelApi: typeof babel, options: Option) {\r\n    this.babelApi = babelApi;\r\n    this.t = babelApi.types;\r\n  }\r\n\r\n  functionDeclarationVisitor(path: NodePath<t.FunctionDeclaration>): void {\r\n    // find Component function by:\r\n    // 1. has JSXElement as return value\r\n    // 2. name is capitalized\r\n    if (path.node.id?.name[0] !== path.node.id?.name[0].toUpperCase()) return;\r\n    const returnStatement = path.node.body.body.find(n => this.t.isReturnStatement(n)) as t.ReturnStatement;\r\n    if (!returnStatement) return;\r\n    if (!(this.t.isJSXElement(returnStatement.argument) || this.t.isJSXFragment(returnStatement.argument))) return;\r\n    const classTransformer = new ClassComponentTransformer(this.babelApi, path);\r\n    // transform the parameters to props\r\n    const params = path.node.params;\r\n    const props = params[0];\r\n    classTransformer.transformProps(props);\r\n    // iterate the function body orderly\r\n    const body = path.node.body.body;\r\n    body.forEach((node, idx) => {\r\n      if (this.t.isVariableDeclaration(node)) {\r\n        classTransformer.transformStateDeclaration(node);\r\n        return;\r\n      }\r\n      // handle method\r\n      if (this.t.isFunctionDeclaration(node)) {\r\n        classTransformer.transformMethods(node);\r\n        return;\r\n      }\r\n\r\n      // handle watch\r\n      if (classTransformer.shouldTransformWatch(node)) {\r\n        // transform the watch statement to watch method\r\n        classTransformer.transformWatch(node);\r\n        return;\r\n      }\r\n\r\n      // handle return statement\r\n      if (this.t.isReturnStatement(node)) {\r\n        // handle early return\r\n        if (idx !== body.length - 1) {\r\n          // transform the return statement to render method\r\n          // TODO: handle early return\r\n          throw new Error('Early return is not supported yet.');\r\n        }\r\n        // transform the return statement to render method\r\n        classTransformer.transformRenderMethod(node);\r\n        return;\r\n      }\r\n    });\r\n\r\n    // replace the function declaration with class declaration\r\n    replaceFnWithClass(path, classTransformer);\r\n  }\r\n}\r\n\r\ntype ToWatchNode =\r\n  | t.ExpressionStatement\r\n  | t.ForStatement\r\n  | t.WhileStatement\r\n  | t.IfStatement\r\n  | t.SwitchStatement\r\n  | t.TryStatement;\r\n\r\nclass ClassComponentTransformer {\r\n  properties: (t.ClassProperty | t.ClassMethod)[] = [];\r\n  private readonly babelApi: typeof babel;\r\n  private readonly t: typeof t;\r\n  private readonly functionScope: Scope;\r\n\r\n  valueWrapper(node) {\r\n    return this.t.file(this.t.program([this.t.isStatement(node) ? node : this.t.expressionStatement(node)]));\r\n  }\r\n\r\n  addProperty(prop: t.ClassProperty | t.ClassMethod, name?: string) {\r\n    this.properties.push(prop);\r\n    if (name) {\r\n      // replace the variable in scope to process the variable in class scope\r\n      // e.g. replace () => count++ to () => this.count++\r\n      // TODO: search for better solution\r\n      this.functionScope.rename(name, `this.${name}`);\r\n      this.functionScope.path.traverse({\r\n        Identifier: path => {\r\n          if (path.node.name === `this.${name}`) {\r\n            path.replaceWith(this.t.memberExpression(this.t.thisExpression(), this.t.identifier(name)));\r\n          }\r\n        },\r\n      });\r\n    }\r\n  }\r\n\r\n  constructor(babelApi: typeof babel, fnNode: NodePath<t.FunctionDeclaration>) {\r\n    this.babelApi = babelApi;\r\n    this.t = babelApi.types;\r\n    // get the function body scope\r\n    this.functionScope = fnNode.scope;\r\n  }\r\n\r\n  // transform function component to class component extends View\r\n  genClassComponent(name: string) {\r\n    return this.t.classDeclaration(\r\n      this.t.identifier(name),\r\n      this.t.identifier('View'),\r\n      this.t.classBody(this.properties),\r\n      []\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Transform state declaration to class property\r\n   * if the variable is declared with `let` or `const`, it should be transformed to class property\r\n   * @param node\r\n   */\r\n  transformStateDeclaration(node: t.VariableDeclaration) {\r\n    // iterate the declarations\r\n    node.declarations.forEach(declaration => {\r\n      const id = declaration.id;\r\n      // handle destructuring\r\n      if (this.t.isObjectPattern(id)) {\r\n        return this.transformPropsDestructuring(id);\r\n      } else if (this.t.isArrayPattern(id)) {\r\n        // TODO: handle array destructuring\r\n      } else if (this.t.isIdentifier(id)) {\r\n        // clone the id\r\n        const cloneId = this.t.cloneNode(id);\r\n        this.addProperty(this.t.classProperty(cloneId, declaration.init), id.name);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Transform render method to Body method\r\n   * The Body method should return the original return statement\r\n   * @param node\r\n   */\r\n  transformRenderMethod(node: t.ReturnStatement) {\r\n    const body = this.t.classMethod(\r\n      'method',\r\n      this.t.identifier('Body'),\r\n      [],\r\n      this.t.blockStatement([node]),\r\n      false,\r\n      false\r\n    );\r\n    this.addProperty(body, 'Body');\r\n  }\r\n\r\n  transformLifeCycle() {}\r\n\r\n  transformComputed() {}\r\n\r\n  transformMethods(node: t.FunctionDeclaration) {\r\n    // transform the function declaration to class method\r\n    const methodName = node.id?.name;\r\n    if (!methodName) return;\r\n    const method = this.t.classMethod(\r\n      'method',\r\n      this.t.identifier(methodName),\r\n      node.params,\r\n      node.body,\r\n      node.generator,\r\n      node.async\r\n    );\r\n    this.addProperty(method, methodName);\r\n  }\r\n\r\n  transformProps(param: t.Identifier | t.RestElement | t.Pattern) {\r\n    if (!param) return;\r\n    // handle destructuring\r\n    if (this.isObjDestructuring(param)) {\r\n      this.transformPropsDestructuring(param);\r\n      return;\r\n    }\r\n    if (this.t.isIdentifier(param)) {\r\n      // TODO: handle props identifier\r\n      return;\r\n    }\r\n    throw new Error('Unsupported props type, please use object destructuring or identifier.');\r\n  }\r\n\r\n  // transform node to method with watch decorator\r\n  transformWatch(node: ToWatchNode) {\r\n    const id = this.functionScope.generateUidIdentifier('watch');\r\n    const method = this.t.classMethod('method', id, [], this.t.blockStatement([node]), false, false);\r\n    method.decorators = [this.t.decorator(this.t.identifier('Watch'))];\r\n    this.addProperty(method);\r\n  }\r\n\r\n  private isObjDestructuring(param: t.Identifier | t.RestElement | t.Pattern): param is t.ObjectPattern {\r\n    return this.t.isObjectPattern(param);\r\n  }\r\n\r\n  private transformPropsDestructuring(param: t.ObjectPattern) {\r\n    const propNames: t.Identifier[] = [];\r\n    param.properties.forEach(prop => {\r\n      if (this.t.isObjectProperty(prop)) {\r\n        const key = prop.key;\r\n        if (this.t.isIdentifier(key)) {\r\n          if (this.t.isAssignmentPattern(prop.value)) {\r\n            // handle default value\r\n            const defaultValue = prop.value.right;\r\n            this.addProp(key, defaultValue);\r\n            propNames.push(key);\r\n            return;\r\n          } else if (this.t.isIdentifier(prop.value)) {\r\n            // handle simple destructuring\r\n            this.addProp(key, undefined, prop.value.name === 'children');\r\n            propNames.push(key);\r\n            return;\r\n          } else if (this.t.isObjectPattern(prop.value)) {\r\n            // TODO: handle nested destructuring\r\n            this.transformPropsDestructuring(prop.value);\r\n            return;\r\n          }\r\n          return;\r\n        }\r\n        // handle default value\r\n        if (this.t.isAssignmentPattern(prop.value)) {\r\n          const defaultValue = prop.value.right;\r\n          const propName = prop.value.left;\r\n          if (this.t.isIdentifier(propName)) {\r\n            this.addProp(propName, defaultValue);\r\n            propNames.push(propName);\r\n          }\r\n          // TODO: handle nested destructuring\r\n          return;\r\n        }\r\n        throw new Error('Unsupported props destructuring, please use simple object destructuring.');\r\n      } else {\r\n        // TODO: handle rest element\r\n      }\r\n    });\r\n\r\n    return propNames;\r\n  }\r\n\r\n  // add prop to class, like @prop name = '';\r\n  private addProp(key: t.Identifier, defaultValue?: t.Expression, isChildren = false) {\r\n    // clone the key to avoid reference issue\r\n    const id = this.t.cloneNode(key);\r\n    this.addProperty(\r\n      this.t.classProperty(\r\n        id,\r\n        defaultValue ?? undefined,\r\n        undefined,\r\n        // use prop decorator\r\n        [this.t.decorator(this.t.identifier(isChildren ? 'Children' : 'Prop'))],\r\n        undefined,\r\n        false\r\n      ),\r\n      key.name\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Check if the node should be transformed to watch method, including:\r\n   * 1. call expression.\r\n   * 2. for loop\r\n   * 3. while loop\r\n   * 4. if statement\r\n   * 5. switch statement\r\n   * 6. assignment expression\r\n   * 7. try statement\r\n   * 8. ++/-- expression\r\n   * @param node\r\n   */\r\n  shouldTransformWatch(node: t.Node): node is ToWatchNode {\r\n    if (this.t.isExpressionStatement(node)) {\r\n      if (this.t.isCallExpression(node.expression)) {\r\n        return true;\r\n      }\r\n      if (this.t.isAssignmentExpression(node.expression)) {\r\n        return true;\r\n      }\r\n      if (this.t.isUpdateExpression(node.expression)) {\r\n        return true;\r\n      }\r\n    }\r\n    if (this.t.isForStatement(node)) {\r\n      return true;\r\n    }\r\n    if (this.t.isWhileStatement(node)) {\r\n      return true;\r\n    }\r\n    if (this.t.isIfStatement(node)) {\r\n      return true;\r\n    }\r\n    if (this.t.isSwitchStatement(node)) {\r\n      return true;\r\n    }\r\n    if (this.t.isTryStatement(node)) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n}\r\n","/*\n * Copyright (c) 2024 Huawei Technologies Co.,Ltd.\n *\n * openInula is licensed under Mulan PSL v2.\n * You can use this software according to the terms and conditions of the Mulan PSL v2.\n * You may obtain a copy of Mulan PSL v2 at:\n *\n *          http://license.coscl.org.cn/MulanPSL2\n *\n * THIS SOFTWARE IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND,\n * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,\n * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.\n * See the Mulan PSL v2 for more details.\n */\n\nimport { PluginObj } from '@babel/core';\nimport { Option } from './types';\nimport * as babel from '@babel/core';\nimport { PluginProvider } from './pluginProvider';\n\nexport default function (api: typeof babel, options: Option): PluginObj {\n  const pluginProvider = new PluginProvider(api, options);\n\n  return {\n    name: 'zouyu-2',\n    visitor: {\n      FunctionDeclaration(path) {\n        pluginProvider.functionDeclarationVisitor(path);\n      },\n    },\n  };\n}\n","/*\n * Copyright (c) 2024 Huawei Technologies Co.,Ltd.\n *\n * openInula is licensed under Mulan PSL v2.\n * You can use this software according to the terms and conditions of the Mulan PSL v2.\n * You may obtain a copy of Mulan PSL v2 at:\n *\n *          http://license.coscl.org.cn/MulanPSL2\n *\n * THIS SOFTWARE IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND,\n * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,\n * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.\n * See the Mulan PSL v2 for more details.\n */\n\nimport { Option } from './types';\nimport type { ConfigAPI, TransformOptions } from '@babel/core';\nimport transformer from './plugin';\n\nexport default function (_: ConfigAPI, options: Option): TransformOptions {\n  return {\n    plugins: [\n      ['@babel/plugin-syntax-jsx'],\n      ['@babel/plugin-syntax-typescript', { isTSX: true }],\n      [transformer, options],\n    ],\n  };\n}\nexport const plugin = transformer;\n\nexport type { Option };\n"],"mappings":"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AM,CACxBiC,EAAe,2BAA2BjC,CAAI,CAChD,CACF,CACF,CACF,CCHO,IAAMkC,GAASC,wKpC5BTC,GAAU,QAAQ,IAAI,WAAa,cAEnCC,GAAoB,CAC/B,MAAO,YACP,IAAK,SACP,EAEaC,EAAsB,CAEjC,OACA,MACA,QACA,UACA,SACA,OACA,UAEA,MACA,SACA,QAEA,MACA,SACA,OACF,EAEaC,EAAkB,CAC7B,IACA,OACA,UACA,OACA,UACA,QACA,QACA,IACA,OACA,MACA,MACA,aACA,OACA,KACA,SACA,SACA,UACA,OACA,OACA,MACA,WACA,OACA,WACA,KACA,MACA,UACA,MACA,SACA,MACA,KACA,KACA,KACA,QACA,WACA,aACA,SACA,SACA,OACA,KACA,KACA,KACA,KACA,KACA,KACA,OACA,SACA,SACA,KACA,OACA,IACA,SACA,MACA,QACA,MACA,MACA,QACA,SACA,KACA,OACA,OACA,MACA,OACA,OACA,OACA,QACA,MACA,WACA,SACA,KACA,WACA,SACA,SACA,IACA,UACA,MACA,WACA,IACA,KACA,KACA,OACA,IACA,OACA,SACA,UACA,SACA,OACA,QACA,SACA,OACA,SACA,QACA,MACA,UACA,MACA,QACA,QACA,KACA,WACA,WACA,QACA,KACA,QACA,OACA,QACA,KACA,QACA,IACA,KACA,MACA,QACA,MACA,UACA,SACA,WACA,UACA,MACA,QACA,SACA,MACA,OACA,QACA,WACA,UACA,SACA,UACA,UACA,WACA,WACA,SACA,OACA,UACA,WACA,QACA,YACA,KACA,MACA,SACA,SACA,KACA,MACA,UACA,gBACA,mBACA,SACA,WACA,OACA,OACA,UACA,UACA,gBACA,sBACA,cACA,mBACA,oBACA,oBACA,iBACA,eACA,UACA,UACA,UACA,UACA,UACA,iBACA,UACA,UACA,cACA,eACA,WACA,eACA,qBACA,cACA,SACA,eACA,SACA,gBACA,IACA,QACA,OACA,iBACA,SACA,OACA,WACA,QACA,OACA,UACA,UACA,WACA,iBACA,OACA,MACA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","names":["apiPolyfills","assertVersion","api","range","throwVersionError","version","Object","assign","targets","assumption","declare","builder","options","dirname","_clonedApi2","clonedApi","name","keys","_clonedApi","copyApiObject","declarePreset","exports","proto","test","getPrototypeOf","hasOwnProperty","call","Number","isInteger","Error","limit","stackTraceLimit","err","slice","code","_helperPluginUtils","require","_default","exports","default","declare","api","options","assertVersion","version","legacy","undefined","Error","decoratorsBeforeExport","name","manipulateOptions","generatorOpts","parserOpts","plugins","push","allowCallParenthesized","transform","import_plugin_syntax_decorators","minimatch","createErrorHandler","errorSpace","throwMap","errorMap","warningMap","handleError","map","type","func","code","msg","args","arg","i","methods","notDescribed","DLError","createErrorHandler","ViewParser","config","statement","lastViewUnit","type","childViewUnits","expression","node","conditions","condition","ifBody","altBody","branches","s","caseBodyPre","caseBody","isBreak","children","branch","tryBody","catchBodyNode","left","item","array","key","forBody","forBodyStatements","childNodes","firstStatement","keyNode","directives","statements","forBodyBlockStatement","body","propNode","dlViewPropResult","innerPath","id","newNode","props","n","property","prop","contentProp","tagName","isViewProp","tagType","tag","isPure","tagTarget","parseView","ViewParser","config","context","node","child","type","tag","openingName","name","toMemberExpression","namespace","props","propMap","prop","childUnits","unit","text","children","lastUnit","condition","attr","propName","specifier","value","propNode","viewPropMap","parseViewProp","innerPath","id","newNode","staticProps","htmlUnit","mutableUnits","generateMutableUnit","path","maxHtmlIdx","htmlIdx","idx","templateProps","generateVariableProp","key","viewUnit","arrayAttr","keyAttr","arr","item","forBody","forBodyStatements","childNodes","firstStatement","keyNode","directives","s","statements","parseView","DLError","createErrorHandler","_ReactivityParser","config","viewUnit","htmlUnit","unit","staticProps","prop","key","children","mutableParticles","generateMutableUnit","path","child","idx","templateProps","generateVariableProp","textUnit","dependencyIndexArr","dependenciesNode","dynamic","innerHTMLParticle","id","compUnit","compParticle","forUnit","prevIdentifierDepMap","keyDep","n","forParticle","ifUnit","branch","switchUnit","tryUnit","envUnit","expUnit","snippetUnit","snippetParticle","units","node","directIdentifierDeps","identifierDepNodes","directPropertyDeps","propertyDepNodes","directDependencies","identifierMapDependencies","deps","depNodes","availableIdentifiers","assignDeps","wrappedNode","innerPath","idName","dep","dependencyNodes","i","m","propertyKey","parentPath","pParentPath","depNode","depsArray","parser","parsedUnit","value","viewPropMap","props","parentNode","identifierKeys","reversePath","checkParam","param","el","leftPath","isInFunction","isManual","isFirstParam","ReactivityParser","__publicField","parseReactivity","viewUnits","usedProperties","dlParticle","prefixMap","BaseGenerator","viewParticle","config","ViewGenerator","acc","key","elements","element","statements","value","dependencies","statement","depNum","nodeName","viewParticles","mergeStatements","newIdx","initStatements","updateStatements","classProperties","topLevelNodes","nodeIdx","_","name","idx","dep","node","dlNodeName","expression","newStatements","LifecycleGenerator","type","__publicField","PropViewGenerator","props","prop","propViewNode","propViewIdentifier","viewPropMap","newValue","innerPath","id","allDepsNum","allDeps","i","ElementGenerator","el","elNode","elementNode","ForwardPropsGenerator","CompGenerator","tag","children","allDependencyIndexArr","dependencyIndexArr","dependenciesNode","willForwardProps","newProps","content","DLError","M","_HTMLPropGenerator","dynamic","childNodeName","position","check","attrName","eventName","attribute","HTMLPropGenerator","HTMLGenerator","tagName","childNames","mutable","child","childName","TemplateGenerator","template","mutableParticles","templateName","paths","path","insertElementStatements","pathNameMap","didUpdateMap","deps","particle","parentName","offset","newNodeName","addFirstChild","object","addSecondChild","addThirdChild","addOtherChild","num","addNextSibling","cur","collect","nameMap","res","pat","allPaths","path0","path1","sortedPaths","a","b","defaultName","bestMatchCount","bestMatchName","bestHalfMatch","matchCount","pathLength","ForGenerator","item","array","childStatements","CondGenerator","condFunc","nodeNames","branchIdx","IfGenerator","branches","condition","test","body","alternate","ifStatement","updateNode","EnvGenerator","childrenNames","TextGenerator","ExpGenerator","SnippetGenerator","availableProperties","allDependenciesNode","depIdx","propChange","propChanged","SwitchGenerator","discriminant","_case","formattedBranches","_break","switchStatements","TryGenerator","catchChildren","exception","addCatchable","updateFunc","exceptionNodes","_ViewGenerator","allInitStatements","allClassProperties","allUpdateStatements","GeneratorClass","generator","result","MainViewGenerator","viewParticlesWithPropertyDep","viewParticlesWithIdentityDep","propsNode","propertyUpdateStatements","identifierUpdateStatements","templateIdx","hasPropertyUpdateFunc","hasIdentifierUpdateFunc","n","bodyEntryNodes","args","runAllStatements","generateView","generateSnippet","propNode","replaceFnWithClass","path","classTransformer","originalName","tempName","classComp","PluginProvider","babelApi","options","_a","_b","returnStatement","n","ClassComponentTransformer","props","body","node","idx","fnNode","prop","name","declaration","id","cloneId","methodName","method","param","propNames","key","defaultValue","propName","isChildren","plugin_default","api","pluginProvider","plugin","plugin_default","devMode","alterAttributeMap","reactivityFuncNames","defaultHTMLTags","availableDecoNames","dlightDefaultPackageName","importMap","name","importsToDelete","tag","defaultAttributeMap","_PluginProvider","babelApi","types","includes","excludes","enableDevTools","htmlTags","attributeMap","key","isWatcher","isStatic","isChildren","path","node","dlightImports","n","i","importNode","specifier","value","filename","watchDeco","deps","depsNode","listenDepStrings","arg","pseudoMethod","str","decorators","isModel","isProp","isEnv","propertyIdx","watcherNode","childrenFuncCallNode","getterNode","derivedStatusKey","decoratorName","idx","reverseDeps","idxNode","d","usedProperties","propertyArr","depReversedMap","isPropOrEnv","isContent","newUpdateProp","assignPath","funcNameNode","callee","usedPropertySet","mainView","snippetNodes","viewNode","isSnippet","isMainView","exp","newViewNode","snippetNames","v","snippetPropSubDepMap","prop","props","p","subDeps","_","templateIdx","viewUnits","returnNode","parseView","b","viewParticles","N","body","classProperties","generateView","snippetProp","identifierDepMap","dep","viewParticlesProperty","viewParticlesIdentifier","snippetPropMap","newTemplateIdx","generateSnippet","fileName","pattern","minimatch","deco","imp","s","args","propsArg","contentArg","propsNode","mergedPropsNode","spreadPropsNode","contentNode","modelDecorator","names","parentPath","pParentPath","depNode","innerPath","constructor","isClassLevel","assignDeps","depNodes","propertyKey","dependencyNodes","m","depArr","wrappedNode","reversedMap","findEntry","found","entryValue","mountNode","mounting","parentNode","propertyNode","methodNode","currentNode","returns","inNestedFunction","newNode","idName","reversePath","checkParam","param","el","identifierKeys","leftPath","stopNode","isInFunction","isFunction","isManual","length","PluginProvider","__publicField","PluginProviderClass","plugin_default","api","options","files","excludeFiles","defaultHtmlTags","pluginProvider","src_default","syntaxDecorators","plugin","minimatch","src_default","options","preFiles","preExcludeFiles","files","excludeFiles","code","id","enter","allowedPath","notAllowedPath","transform"]}